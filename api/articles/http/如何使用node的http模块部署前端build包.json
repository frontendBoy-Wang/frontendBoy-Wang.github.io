{"title":"如何使用node的http模块部署前端build包","uid":"4ec1a2110135da03fdd6a951884bb497","slug":"http/如何使用node的http模块部署前端build包","date":"2023-02-10T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/http/如何使用node的http模块部署前端build包.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/60.png","content":"<h1 id=\"创建简单的静态文件服务器：使用Node-js和HTTP模块\"><a href=\"#创建简单的静态文件服务器：使用Node-js和HTTP模块\" class=\"headerlink\" title=\"创建简单的静态文件服务器：使用Node.js和HTTP模块\"></a>创建简单的静态文件服务器：使用Node.js和HTTP模块</h1><p>在Web开发中，经常需要搭建一个能够提供静态文件访问的服务器。无论是用于本地开发调试，还是用于部署网站，这都是一个常见的需求。本篇文章将介绍如何使用Node.js和其内置的HTTP模块来创建一个简单的静态文件服务器。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>首先，确保你已经安装了Node.js环境。如果没有安装，可以到Node.js官网（<a href=\"https://nodejs.org/\">https://nodejs.org/</a>）下载并安装最新版本。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>接下来，我们将通过以下代码来创建一个简单的静态文件服务器：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const http &#x3D; require(&#39;http&#39;);\nconst fs &#x3D; require(&#39;fs&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 省略上面提到的代码，详见下文\n&#125;);\n\nconst port &#x3D; process.env.PORT || &#39;3030&#39;;\nserver.listen(port, () &#x3D;&gt; &#123;\n    console.log(&#96;Server running at http:&#x2F;&#x2F;localhost:$&#123;port&#125;&#x2F;&#96;);\n&#125;);</code></pre>\n\n<p>代码解释：我们首先导入了Node.js内置的<code>http</code>、<code>fs</code>和<code>path</code>模块，分别用于创建HTTP服务器、读取文件和处理文件路径。然后使用<code>http.createServer</code>方法创建了一个HTTP服务器，并传入了一个回调函数处理请求和响应。接着定义了服务器监听的端口号，并通过<code>server.listen</code>方法来启动服务器。</p>\n<p>接下来，我们需要完善回调函数中的逻辑，使其能够根据请求的路径返回相应的静态文件内容。以下是完整的代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 上面提到的回调函数\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    let filePath &#x3D; &#39;.&#39; + req.url;\n    if (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;&#39;) &#123;\n        filePath &#x3D; &#39;.&#x2F;index.html&#39;;\n    &#125;\n\n    &#x2F;&#x2F; 省略文件类型判断和读取文件的部分，详见下文\n&#125;);\n\n&#x2F;&#x2F; 省略端口设置和服务器启动的部分</code></pre>\n\n<p>在上面的代码中，我们根据请求的URL构造了文件路径<code>filePath</code>，并设置了默认的文件路径为<code>&#39;./index.html&#39;</code>。接下来，我们需要根据文件的扩展名来确定其Content-Type，并读取文件内容，然后将文件内容作为响应返回给客户端。具体的文件类型判断和读取文件的部分如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 文件类型判断和读取文件的部分\nconst extname &#x3D; String(path.extname(filePath)).toLowerCase();\nconst contentType &#x3D; &#123;\n    &#39;.html&#39;: &#39;text&#x2F;html&#39;,\n    &#39;.js&#39;: &#39;text&#x2F;javascript&#39;,\n    &#x2F;&#x2F; ... 其他文件类型的Content-Type\n&#125;[extname] || &#39;application&#x2F;octet-stream&#39;;\n\nfs.readFile(filePath, function (error, content) &#123;\n    if (error) &#123;\n        if (error.code &#x3D;&#x3D;&#x3D; &#39;ENOENT&#39;) &#123; &#x2F;&#x2F; 文件不存在\n            fs.readFile(&#39;.&#x2F;404.html&#39;, function (error, content) &#123;\n                res.writeHead(404, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);\n                res.end(content, &#39;utf-8&#39;);\n            &#125;);\n        &#125; else &#123; &#x2F;&#x2F; 其他错误\n            res.writeHead(500);\n            res.end(&#39;Sorry, check with the site admin for error: &#39; + error.code + &#39; ..\\n&#39;);\n            res.end();\n        &#125;\n    &#125; else &#123; &#x2F;&#x2F; 文件存在\n        res.writeHead(200, &#123;&#39;Content-Type&#39;: contentType&#125;);\n        res.end(content, &#39;utf-8&#39;);\n    &#125;\n&#125;);</code></pre>\n\n<p>在上面的代码中，我们首先通过<code>path.extname</code>方法获取文件的扩展名，然后根据扩展名确定其Content-Type，并使用<code>fs.readFile</code>方法读取文件内容。如果读取文件出现错误，我们会返回相应的状态码和错误信息；如果文件存在，则根据Content-Type设置响应头，并将文件内容返回给客户端。</p>\n<h2 id=\"运行服务器\"><a href=\"#运行服务器\" class=\"headerlink\" title=\"运行服务器\"></a>运行服务器</h2><p>保存以上代码到一个文件（比如<code>server.js</code>），然后打开命令行，进入文件所在目录，运行以下命令启动服务器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">node server.js</code></pre>\n\n<p>此时，服务器会在默认端口3030上启动，你可以打开浏览器访问<code>http://localhost:3030/</code>来查看效果。如果需要修改端口，可以通过设置环境变量<code>PORT</code>来改变监听的端口号，比如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">PORT&#x3D;8080 node server.js</code></pre>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过本篇文章，我们学习了如何使用Node.js和HTTP模块来创建一个简单的静态文件服务器。这个服务器可以用于提供HTML、CSS、JavaScript等静态文件，在开发调试和部署网站时非常有用。希望这篇文章能够帮助你更好地理解Node.js的HTTP模块以及静态文件服务器的实现原理。</p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const http &#x3D; require(&#39;http&#39;);  &#x2F;&#x2F; 导入内置的 http 模块\nconst fs &#x3D; require(&#39;fs&#39;);  &#x2F;&#x2F; 导入内置的文件系统模块\nconst path &#x3D; require(&#39;path&#39;);  &#x2F;&#x2F; 导入内置的路径处理模块\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    let filePath &#x3D; &#39;.&#39; + req.url;  &#x2F;&#x2F; 构造文件路径，以当前目录为根目录\n    if (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;&#39;) &#123;  &#x2F;&#x2F; 如果文件路径为根路径\n        filePath &#x3D; &#39;.&#x2F;index.html&#39;;  &#x2F;&#x2F; 默认返回 index.html 文件\n    &#125;\n\n    const extname &#x3D; String(path.extname(filePath)).toLowerCase();  &#x2F;&#x2F; 获取文件的扩展名并转换为小写\n    const contentType &#x3D; &#123;  &#x2F;&#x2F; 定义不同文件类型对应的 Content-Type\n        &#39;.html&#39;: &#39;text&#x2F;html&#39;,\n        &#39;.js&#39;: &#39;text&#x2F;javascript&#39;,\n        &#39;.css&#39;: &#39;text&#x2F;css&#39;,\n        &#39;.json&#39;: &#39;application&#x2F;json&#39;,\n        &#39;.png&#39;: &#39;image&#x2F;png&#39;,\n        &#39;.jpg&#39;: &#39;image&#x2F;jpg&#39;,\n        &#39;.gif&#39;: &#39;image&#x2F;gif&#39;,\n        &#39;.svg&#39;: &#39;image&#x2F;svg+xml&#39;,\n        &#39;.wav&#39;: &#39;audio&#x2F;wav&#39;,\n        &#39;.mp4&#39;: &#39;video&#x2F;mp4&#39;,\n        &#39;.woff&#39;: &#39;application&#x2F;font-woff&#39;,\n        &#39;.ttf&#39;: &#39;application&#x2F;font-ttf&#39;,\n        &#39;.eot&#39;: &#39;application&#x2F;vnd.ms-fontobject&#39;,\n        &#39;.otf&#39;: &#39;application&#x2F;font-otf&#39;,\n        &#39;.wasm&#39;: &#39;application&#x2F;wasm&#39;\n    &#125;[extname] || &#39;application&#x2F;octet-stream&#39;;  &#x2F;&#x2F; 如果找不到对应的 Content-Type，默认使用 application&#x2F;octet-stream\n\n    fs.readFile(filePath, function (error, content) &#123;  &#x2F;&#x2F; 读取文件内容的回调函数\n        if (error) &#123;  &#x2F;&#x2F; 如果读取文件出现错误\n            if (error.code &#x3D;&#x3D;&#x3D; &#39;ENOENT&#39;) &#123;  &#x2F;&#x2F; 如果文件不存在\n                fs.readFile(&#39;.&#x2F;404.html&#39;, function (error, content) &#123;  &#x2F;&#x2F; 读取 404.html 文件\n                    res.writeHead(404, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);  &#x2F;&#x2F; 返回状态码和 Content-Type\n                    res.end(content, &#39;utf-8&#39;);  &#x2F;&#x2F; 返回文件内容\n                &#125;);\n            &#125; else &#123;  &#x2F;&#x2F; 其他错误\n                res.writeHead(500);  &#x2F;&#x2F; 返回状态码 500\n                res.end(&#39;Sorry, check with the site admin for error: &#39; + error.code + &#39; ..\\n&#39;);  &#x2F;&#x2F; 返回错误信息\n                res.end();  &#x2F;&#x2F; 结束响应\n            &#125;\n        &#125; else &#123;  &#x2F;&#x2F; 如果文件存在\n            res.writeHead(200, &#123;&#39;Content-Type&#39;: contentType&#125;);  &#x2F;&#x2F; 返回状态码和对应的 Content-Type\n            res.end(content, &#39;utf-8&#39;);  &#x2F;&#x2F; 返回文件内容\n        &#125;\n    &#125;);\n\n&#125;);\n\nconst port &#x3D; process.env.PORT || &#39;3030&#39;;  &#x2F;&#x2F; 设置服务器监听的端口号，默认为 3030\nserver.listen(port, () &#x3D;&gt; &#123;\n    console.log(&#96;Server running at http:&#x2F;&#x2F;localhost:$&#123;port&#125;&#x2F;&#96;);  &#x2F;&#x2F; 在控制台输出服务器启动信息\n&#125;);</code></pre>\n\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>运行server.js文件，需要把文件放的build目录里面。如果想要放到build目录外面则要更改<br>这里build的目录设置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let filePath &#x3D; &#39;.&#x2F;build&#39; + req.url;\nif (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;build&#x2F;&#39;) &#123;\n    filePath &#x3D; &#39;.&#x2F;build&#x2F;index.html&#39;;\n&#125;</code></pre>","feature":false,"text":"创建简单的静态文件服务器：使用Node.js和HTTP模块在Web开发中，经常需要搭建一个能够提供静态文件访问的服务器。无论是用于本地开发调试，还是用于部署网站，这都是一个常见的需求。本篇文章将介绍如何使用Node.js和其内置的HTTP模块来创建一个简单的静态文件服务器。 准备...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"运维","slug":"运维","count":1,"path":"api/categories/运维.json"}],"tags":[{"name":"运维 前端部署 node","slug":"运维-前端部署-node","count":1,"path":"api/tags/运维-前端部署-node.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A%E4%BD%BF%E7%94%A8Node-js%E5%92%8CHTTP%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">创建简单的静态文件服务器：使用Node.js和HTTP模块</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">准备工作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">运行服务器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">完整代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F\"><span class=\"toc-text\">注意</span></a></li></ol></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"Gin入门教程：从零开始学习Go语言Web框架","uid":"3140e76ccb52a413540ef6b8d667bcb4","slug":"go/Gin入门教程：从零开始学习Go语言Web框架","date":"2023-03-01T02:14:26.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/go/Gin入门教程：从零开始学习Go语言Web框架.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/10.png","text":" 在Go语言的Web开发领域，Gin框架无疑是一个备受关注的轻量级框架。它具有快速、高效、易用等特点，非常适合用于构建Web应用程序。本篇博客将带领大家从零开始学习Gin框架，包括安装、基本用法和常用功能等内容。Gin 是一个用 Go 语言编写的 Web 框架，它提供了快速构建高...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"}],"tags":[{"name":"gin go","slug":"gin-go","count":1,"path":"api/tags/gin-go.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":true},"next_post":{"title":"Nuxt.js，Next.js，Nest.js傻傻分不清？","uid":"cc1bedd8e44831bc22e0a5fe2a764356","slug":"node/Nuxt.js，Next.js，Nest.js傻傻分不清","date":"2023-02-02T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/node/Nuxt.js，Next.js，Nest.js傻傻分不清.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/32.png","text":"三者区别Nuxt.js和Next.js都是服务端渲染框架(SSR)，属于前端框架,Nest.js则是node框架,属于后端框架。 虽然名字看起来都很像但是确实不一样的框架。其中Nuxt.js是vue的ssr框架，Next.js是react的ssr框架 都是比vue和react更上...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"node","slug":"node","count":2,"path":"api/categories/node.json"}],"tags":[{"name":"Nuxt.js Next.js Nest.js","slug":"Nuxt-js-Next-js-Nest-js","count":1,"path":"api/tags/Nuxt-js-Next-js-Nest-js.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":true}}