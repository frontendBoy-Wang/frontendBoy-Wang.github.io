{"title":"一个基于vite构建的vue3+pinia+ts+elementUI plus的初始化开箱即用的项目模版","uid":"a7e01fb13cc6c5d9b1c60619ae2f3415","slug":"vue/一个基于vite构建的vue3+pinia+ts+elementUI plus的初始化开箱即用的项目模版","date":"2022-10-08T15:14:01.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/vue/一个基于vite构建的vue3+pinia+ts+elementUI plus的初始化开箱即用的项目模版.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/75.jpeg","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><a href=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/833e5084cfb74b629479288361ff267d~tplv-k3u1fbpfcp-zoom-1.image\"></a></h1><h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>vue3如今已经成为默认版本了，相信大多数公司已经全面拥抱vue3了。</p>\n<p>而Vite作为新一代的新型前端构建工具，使用它能够显著提升前端开发体验。</p>\n<h1 id=\"什么是Vite\"><a href=\"#什么是Vite\" class=\"headerlink\" title=\"什么是Vite\"></a>什么是Vite</h1><p>这里借用官方的介绍：</p>\n<ul>\n<li>  一个开发服务器，它基于 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\">原生 ES 模块</a> 提供了 <a href=\"https://cn.vitejs.dev/guide/features.html\">丰富的内建功能</a>，如速度快到惊人的 <a href=\"https://cn.vitejs.dev/guide/features.html#hot-module-replacement\">模块热更新（HMR）</a>。</li>\n<li>  一套构建指令，它使用 <a href=\"https://rollupjs.org/\">Rollup</a> 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。</li>\n</ul>\n<h1 id=\"Vite的优势\"><a href=\"#Vite的优势\" class=\"headerlink\" title=\"Vite的优势\"></a>Vite的优势</h1><ul>\n<li>  开箱即用</li>\n<li>  具备插件API和JS API</li>\n</ul>\n<!---->\n\n<ul>\n<li>  高度的可扩展性</li>\n<li>  热更新</li>\n</ul>\n<!---->\n\n<ul>\n<li>  高效，快速</li>\n</ul>\n<h2 id=\"搭建第一个-Vite-项目\"><a href=\"#搭建第一个-Vite-项目\" class=\"headerlink\" title=\"搭建第一个 Vite 项目\"></a>搭建第一个 Vite 项目</h2><p><strong>兼容性注意</strong></p>\n<p>Vite 需要 <a href=\"https://nodejs.org/en/\">Node.js</a> 版本 &gt;= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。</p>\n<p><strong>NPM:</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">npm create vite@latest\nnpm create @vitejs&#x2F;app \nnpm init vite@latest\nnpm init @vitejs&#x2F;app </code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49af0c8624084b0fa8de4ffe20939d53~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p><strong>Yarn:</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn create vite</code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d7fd23808b46de892195fe78e09ae5~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>创建Vite项目的命令有很多，大同小异，但是我推荐使用 yarn的方式，谁用谁知道，命令简洁，速度更快，当然也有其它的方式，可以看一下官网的推荐方式，这个选择自己喜欢的就好了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># npm 6.x\nnpm create vite@latest my-vue-app --template vue\n\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app -- --template vue</code></pre>\n\n<p>初始化好之后的目录：</p>\n<pre class=\"line-numbers language-cmd\" data-language=\"cmd\"><code class=\"language-cmd\">│  ├─public # 静态资源目录\n│  │      favicon.ico \n│  │\n│  ├─src\n│  │  │  App.vue # 入口vue文件\n│  │  │  main.ts # 入口文件\n│  │  ├─assets # 资源文件目录\n│  │  │      logo.png\n│  │  │\n│  │  └─components # 组件文件目录\n│  │         HelloWorld.vue\n│  │\n│  │ .gitignore\n│  │ index.html # Vite项目的入口文件 \n│  │ package.json\n│  │ README.md\n│  │ tsconfig.json # tsconfig配置文件\n│  │ vite.config.ts # vite配置文件</code></pre>\n\n<p>执行：<code>npm i</code>或者<code>yarn</code>安装依赖，再执行 <code>npm run dev</code> 或者 <code>yarn dev</code> 打开浏览器输入<a href=\"http://localhost:3000/\">http://localhost:3000</a></p>\n<p>即可看到</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e172ddb0ec6046c39a3d82085947f247~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>这样一个vue3+vite+ts的项目初始化就完成了</p>\n<p>运行项目不会默认打开浏览器,需要在package.json里面 ,在vite 后面加上–open</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/755fe9a7d178488d8368e3cd1648720f~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h1 id=\"安装vue全家桶\"><a href=\"#安装vue全家桶\" class=\"headerlink\" title=\"安装vue全家桶\"></a>安装vue全家桶</h1><h2 id=\"Pinia状态管理\"><a href=\"#Pinia状态管理\" class=\"headerlink\" title=\"Pinia状态管理\"></a>Pinia状态管理</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0dc9ef3b8334be58875854e3b12baea~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>由于 vuex 4 对 typescript 的支持让人感到难过，所以状态管理弃用了 vuex 而采取了 pinia. pinia 的作者是 Vue 核心团队成员</p>\n<p>尤大好像说 pinia 可能会代替 vuex，所以请放心使用。</p>\n<p>Pinia 与 Vuex 的区别：</p>\n<ul>\n<li>  id 是必要的，它将所使用 store 连接到 devtools。</li>\n<li>  创建方式：new Vuex.Store(…)(vuex3)，createStore(…)(vuex4)。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  对比于 vuex3 ，state 现在是一个函数返回对象。</li>\n<li>  没有 mutations，不用担心，state 的变化依然记录在 devtools 中。</li>\n</ul>\n<p>安装 pinia</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">yarn add pinia\n# or with npm\nnpm install pinia</code></pre>\n\n<p>main.ts</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\n\nconst app &#x3D; createApp(App)\napp.use(createPinia())\ncreateApp(App).mount(&#39;#app&#39;)</code></pre>\n\n<p>新建store文件夹，新建index.ts</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123;defineStore&#125; from &#39;pinia&#39;\n\nexport const useStore &#x3D; defineStore(&#39;storeId&#39;, &#123;\n    state: () &#x3D;&gt; &#123;\n        return &#123;\n            counter: 0,\n            name: &#39;Eduardo&#39;,\n            isAdmin: true,\n        &#125;\n    &#125;,\n&#125;)</code></pre>\n\n<p>组件内使用</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport HelloWorld from &#39;.&#x2F;components&#x2F;Hello&#39;\nimport &#123;useStore&#125; from &quot;@&#x2F;store&#x2F;store&quot;;\nimport &#123;index&#125; from &quot;@&#x2F;types&quot;;\n\nconst store:index &#x3D; useStore()\nconsole.log(useStore().$state)\n\n\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;&#123;&#123; store.name &#125;&#125;&lt;&#x2F;div&gt;\n  &lt;HelloWorld&#x2F;&gt;\n&lt;&#x2F;template&gt;</code></pre>\n\n<h3 id=\"getters-用法介绍\"><a href=\"#getters-用法介绍\" class=\"headerlink\" title=\"getters 用法介绍\"></a>getters 用法介绍</h3><p>Pinia 中的 getter 与 Vuex 中的 getter 、组件中的计算属性具有相同的功能</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ca8a62b70b42ed94238198e0582258~tplv-k3u1fbpfcp-zoom-1.image\"><br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc256875d96c4cef95979b99d43f3d1f~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h3 id=\"actions\"><a href=\"#actions\" class=\"headerlink\" title=\"actions\"></a>actions</h3><p>这里与 Vuex 有极大的不同，Pinia 仅提供了一种方法来定义如何更改状态的规则，放弃 mutations 只依靠 Actions，这是一项重大的改变。</p>\n<p>Pinia 让 Actions 更加的灵活：</p>\n<ul>\n<li>  可以通过组件或其他 action 调用</li>\n<li>  可以从其他 store 的 action 中调用</li>\n</ul>\n<!---->\n\n<ul>\n<li>  直接在 store 实例上调用</li>\n<li>  支持同步或异步</li>\n</ul>\n<!---->\n\n<ul>\n<li>  有任意数量的参数</li>\n<li>  可以包含有关如何更改状态的逻辑（也就是 vuex 的 mutations 的作用）</li>\n</ul>\n<!---->\n\n<ul>\n<li>  可以 $patch 方法直接更改状态属性</li>\n</ul>\n<h2 id=\"VueRouter\"><a href=\"#VueRouter\" class=\"headerlink\" title=\"VueRouter\"></a>VueRouter</h2><p>yarn add vue-router@4<br>在 src 文件下新增 router 文件夹 =&gt; router.ts 文件,内容如下:</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123;createRouter, createWebHistory, RouteRecordRaw&#125; from &#39;vue-router&#39;\n\nconst routes: RouteRecordRaw[] &#x3D; [\n    &#123;\n        path: &#39;&#x2F;&#39;,\n        name: &#39;Login&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;pages&#x2F;login&#x2F;Login.vue&#39;), &#x2F;&#x2F; 注意这里要带上 文件后缀.vue\n    &#125;,\n]\n\nconst router &#x3D; createRouter(&#123;\n    history: createWebHistory(),\n    routes,\n&#125;)\n\nexport default router</code></pre>\n\n<p>修改入口文件 mian.ts :</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\nimport router from &quot;@&#x2F;router&#x2F;router&quot;;\n\nconst app &#x3D; createApp(App)\napp.use(createPinia()).use(router)\n\napp.mount(&#39;#app&#39;)</code></pre>\n\n\n<p>到这里路由的基础配置已经完成了,更多配置信息可以查看 vue-router 官方文档:</p>\n<p>vue-router: <a href=\"https://next.router.vuejs.org/zh/guide/\">https://next.router.vuejs.org/zh/guide/</a></p>\n<p>vue-router4.x 支持 typescript，配置路由的类型是 RouteRecordRaw，这里 meta 可以让我们有更多的发挥空间，这里提供一些参考</p>\n<ul>\n<li>  title:string; 页面标题，通常必选。</li>\n<li>  icon?:string; 图标，一般配合菜单使用。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  auth?:boolean; 是否需要登录权限。</li>\n<li>  ignoreAuth?:boolean; 是否忽略权限。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  roles?:RoleEnum[]; 可以访问的角色</li>\n<li>  keepAlive?:boolean; 是否开启页面缓存</li>\n</ul>\n<!---->\n\n<ul>\n<li>  hideMenu?:boolean; 有些路由我们并不想在菜单中显示，比如某些编辑页面。</li>\n<li>  order?:number; 菜单排序。</li>\n</ul>\n<!---->\n\n<ul>\n<li>  frameUrl?:string; 嵌套外链。</li>\n</ul>\n<h2 id=\"Element-ui-plus\"><a href=\"#Element-ui-plus\" class=\"headerlink\" title=\"Element-ui plus\"></a>Element-ui plus</h2><p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40d5cc2a5f304f329e96bfc9542ddf7e~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>Element Plus 目前还处于快速开发迭代中。目前使用2.0.1版可以结合vite-plugin-style-import插件按需加载样式。 unplugin-vue-components 按需自动导入组件 使用 Element Plus组件时可以直接使用</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"># 选择一个你喜欢的包管理器\n\n# NPM\n$ npm install element-plus --save\n\n# Yarn\n$ yarn add element-plus\n\n# pnpm\n$ pnpm install element-plus</code></pre>\n\n<p>main.ts</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\nimport router from &#39;.&#x2F;router&#x2F;router&#39;\nimport ElementPlus from &#39;element-plus&#39;\nimport &#39;element-plus&#x2F;dist&#x2F;index.css&#39;\n\nconst app &#x3D; createApp(App)\napp\n    .use(createPinia())\n    .use(router)\n    .use(ElementPlus, &#123;size: &#39;small&#39;, zIndex: 3000&#125;)\n\napp.mount(&#39;#app&#39;)</code></pre>\n\n\n\n\n<h2 id=\"Axios封装\"><a href=\"#Axios封装\" class=\"headerlink\" title=\"Axios封装\"></a>Axios封装</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\"># 安装 axios \nyarn add axios \n# 安装 nprogress 用于请求 loading \n# 也可以根据项目需求自定义其它 loading yarn add nprogress \n# 类型声明，或者添加一个包含 &#96;declare module &#39;nprogress&#39; yarn add @types&#x2F;nprogress --dev</code></pre>\n\n<p>实际使用中可以根据项目修改，比如RESTful api中可以自行添加put和delete请求,ResType也可以根据后端的通用返回值动态的去修改</p>\n<p>新增 http文件夹，http下新增 Http.ts 文件以及 api 文件夹:</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/718ed759ae8f4fe7bf31c611473a7c2e~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>http.ts</p>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">import axios, &#123;AxiosError, AxiosRequestConfig, AxiosResponse&#125; from &quot;axios&quot;;\nimport NProgress from &#39;nprogress&#39;\nimport &#123;Message&#125; from &#39;@element-plus&#x2F;icons-vue&#39;\n\ninterface ResType&lt;T&gt; &#123;\n    code: number\n    data?: T\n    msg: string\n    err?: string\n&#125;\n\ninterface Http &#123;\n    get&lt;T&gt;(url: string, params?: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    post&lt;T&gt;(url: string, params?: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    upload&lt;T&gt;(url: string, params: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    download(url: string): void\n&#125;\n\n&#x2F;&#x2F; 设置请求头和请求路径\naxios.defaults.baseURL &#x3D; &#39;&#x2F;api&#39;\naxios.defaults.timeout &#x3D; 10000\naxios.defaults.headers.post[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;json;charset&#x3D;UTF-8&#39;\n\n&#x2F;&#x2F;请求拦截器\naxios.interceptors.request.use(\n    (config: AxiosRequestConfig) &#x3D;&gt; &#123;\n        const token &#x3D; window.sessionStorage.getItem(&#39;token&#39;)\n        if (token) &#123;\n            &#x2F;&#x2F; @ts-ignore\n            config.headers.token &#x3D; token\n        &#125;\n        return config\n    &#125;,\n    (error: Error) &#x3D;&gt; &#123;\n        return error\n    &#125;\n)\n&#x2F;&#x2F; 响应拦截\naxios.interceptors.response.use(\n    (res: AxiosResponse) &#x3D;&gt; &#123;\n        &#x2F;&#x2F;发请求前做的一些处理，数据转化，配置请求头，设置token,设置loading等，根据需求去添加\n        switch (res.data.code) &#123;\n            case 111:\n                sessionStorage.setItem(&#39;token&#39;, &#39;&#39;);\n                return res\n            case 200:\n                return JSON.stringify(res.data)\n            default :\n                return\n        &#125;\n    &#125;,\n    (error: AxiosError) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 接收到异常响应的处理开始\n        if (error &amp;&amp; error.response) &#123;\n            &#x2F;&#x2F; 1.公共错误处理\n            &#x2F;&#x2F; 2.根据响应码具体处理\n            switch (error.response.status) &#123;\n                case 400:\n                    error.message &#x3D; &#39;错误请求&#39;\n                    break;\n                case 401:\n                    error.message &#x3D; &#39;未授权，请重新登录&#39;\n                    break;\n                case 403:\n                    error.message &#x3D; &#39;拒绝访问&#39;\n                    break;\n                case 404:\n                    error.message &#x3D; &#39;请求错误,未找到该资源&#39;\n                    window.location.href &#x3D; &quot;&#x2F;NotFound&quot;\n                    break;\n                case 405:\n                    error.message &#x3D; &#39;请求方法未允许&#39;\n                    break;\n                case 408:\n                    error.message &#x3D; &#39;请求超时&#39;\n                    break;\n                case 500:\n                    error.message &#x3D; &#39;服务器端出错&#39;\n                    break;\n                case 501:\n                    error.message &#x3D; &#39;网络未实现&#39;\n                    break;\n                case 502:\n                    error.message &#x3D; &#39;网络错误&#39;\n                    break;\n                case 503:\n                    error.message &#x3D; &#39;服务不可用&#39;\n                    break;\n                case 504:\n                    error.message &#x3D; &#39;网络超时&#39;\n                    break;\n                case 505:\n                    error.message &#x3D; &#39;http版本不支持该请求&#39;\n                    break;\n                default:\n                    error.message &#x3D; &#96;连接错误$&#123;error.response.status&#125;&#96;\n            &#125;\n        &#125; else &#123;\n            &#x2F;&#x2F; 超时处理\n            if (JSON.stringify(error).includes(&#39;timeout&#39;)) &#123;\n                Message.error(&#39;服务器响应超时，请刷新当前页&#39;)\n            &#125;\n            Message.error(&#39;连接服务器失败&#39;)\n        &#125;\n        Message.error(error.message)\n        &#x2F;&#x2F;处理结束\n        &#x2F;&#x2F;如果不需要错误处理，以上的处理过程都可省略\n        return Promise.resolve(error.response)\n    &#125;\n)\n\nconst Http: Http &#x3D; &#123;\n    get(url, params) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .get(url, &#123;params&#125;)\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    post(url, params) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .post(url, JSON.stringify(params))\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    upload(url, file) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .post(url, file, &#123;\n                    headers: &#123;&#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39;&#125;,\n                &#125;)\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    download(url) &#123;\n        const iframe &#x3D; document.createElement(&#39;iframe&#39;)\n        iframe.style.display &#x3D; &#39;none&#39;\n        iframe.src &#x3D; url\n        iframe.onload &#x3D; function () &#123;\n            document.body.removeChild(iframe)\n        &#125;\n        document.body.appendChild(iframe)\n    &#125;,\n&#125;\n\nexport default Http;</code></pre>\n\n<p>在http文件夹下创建api文件夹用于统一存放接口文件,统一管理api</p>\n<p>http/api/login.ts</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b75534861544f47adf05f56016c3730~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">import http from &quot;@&#x2F;http&#x2F;Http&quot;;\n\nexport async function login(data: &#123; userName: string, password: string &#125;) &#123;\n    return http.post(&#96;&#x2F;login&#96;, data)\n&#125;</code></pre>\n\n<p>至此,一个简单地请求封装完成了!!!!</p>\n<p>除了自己手动封装 axios ,这里还推荐一个 vue3 的请求库: VueRequest,非常好用,下面来看看 VueRequest有哪些比较好用的功能吧!!!</p>\n<ul>\n<li>  所有数据都具有响应式</li>\n<li>  轮询请求</li>\n</ul>\n<!---->\n\n<ul>\n<li>  自动处理错误重试</li>\n<li>  内置请求缓存</li>\n</ul>\n<!---->\n\n<ul>\n<li>  节流请求与防抖请求</li>\n<li>  聚焦页面时自动重新请求</li>\n</ul>\n<!---->\n\n<ul>\n<li>  ⚙️ 强大的分页扩展以及加载更多扩展</li>\n<li>  完全使用 Typescript 编写，具有强大的类型提示</li>\n</ul>\n<!---->\n\n<ul>\n<li>  ⚡️ 兼容 Vite</li>\n<li>  轻量化</li>\n</ul>\n<!---->\n\n<ul>\n<li>  开箱即用</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/618991c7855c46a9a93ba13e11ee1eae~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h2 id=\"tsx支持\"><a href=\"#tsx支持\" class=\"headerlink\" title=\"tsx支持\"></a>tsx支持</h2><p>首先需要安装官方维护的vite插件@vitejs/plugin-vue-jsx,这个插件其实核心还是@vue/babel-plugin-jsx,只是在这个插件上封装了一层供vite插件调用。所以关于vue的jsx语法规范可以直接参看@vue/babel-plugin-jsx,文档链接如下，建议大家可以先读一遍语法规范。官方写得比较详细，后续我也会结合实际讲解一下大部分规范的用法，vue jsx语法规范。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ npm install @vitejs&#x2F;plugin-vue-jsx -D\n#or \n$ yarn add @vitejs&#x2F;plugin-vue-jsx -D </code></pre>\n\n<p>安装完之后在vite.config.ts进行插件使用，代码如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123; defineConfig &#125; from &quot;vite&quot;;\nimport vue from &quot;@vitejs&#x2F;plugin-vue&quot;;\nimport vueJsx from &quot;@vitejs&#x2F;plugin-vue-jsx&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [\n    vue(),\n    vueJsx() &#x2F;&#x2F;插件使用\n  ],\n&#125;);</code></pre>\n\n<h2 id=\"环境变量配置\"><a href=\"#环境变量配置\" class=\"headerlink\" title=\"环境变量配置\"></a>环境变量配置</h2><p>vite 提供了两种模式：具有开发服务器的开发模式（development）和生产模式（production）</p>\n<p>项目根目录新建: .env.development</p>\n<p><code>NODE_ENV=development VITE_APP_WEB_URL= &#39;YOUR WEB URL&#39;</code></p>\n<p>项目根目录新建: .env.production</p>\n<p><code>NODE_ENV=production VITE_APP_WEB_URL= &#39;YOUR WEB URL&#39;</code></p>\n<p>组件中使用：</p>\n<p><code>console.log(import.meta.env.VITE_APP_WEB_URL)</code></p>\n<p>配置 package.json:</p>\n<p>打包区分开发环境和生产环境</p>\n<p><code>&quot;build:dev&quot;: &quot;vite build --mode development&quot;,</code></p>\n<p><code>&quot;build:pro&quot;: &quot;vite build --mode production&quot;,</code></p>\n<h1 id=\"Vite-常用基础配置\"><a href=\"#Vite-常用基础配置\" class=\"headerlink\" title=\"Vite 常用基础配置\"></a>Vite 常用基础配置</h1><h3 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h3><p>运行 代理 和 打包 配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;配置代理\n    server: &#123;\n        host: &#39;0.0.0.0&#39;,\n        port: 3000,\n        open: true,\n        https: false,\n        proxy: &#123;&#125;\n    &#125;,\n      \n      &#x2F;&#x2F; 生产环境打包配置\n    &#x2F;&#x2F;去除 console debugger\n    build: &#123;\n        terserOptions: &#123;\n            compress: &#123;\n                drop_console: true,\n                drop_debugger: true,\n            &#125;,\n        &#125;,\n    &#125;,</code></pre>\n\n<h3 id=\"生产环境生成-gz-文件\"><a href=\"#生产环境生成-gz-文件\" class=\"headerlink\" title=\"生产环境生成 .gz 文件\"></a>生产环境生成 .gz 文件</h3><p>开启 gzip 可以极大的压缩静态资源，对页面加载的速度起到了显著的作用。\\</p>\n<p>使用 vite-plugin-compression 可以 gzip 或 brotli 的方式来压缩资源，这一步需要服务器端的配合，vite 只能帮你打包出 .gz 文件。此插件使用简单，你甚至无需配置参数，引入即可。</p>\n<p><code># 安装 yarn add --dev vite-plugin-compression</code></p>\n<p>plugins 中添加：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"> import viteCompression from &#39;vite-plugin-compression&#39;\n\n&#x2F;&#x2F;配置插件\n    plugins: [\n        vue(),\n        vueJsx(),\n        viteCompression(&#123;\n            verbose: true,\n            disable: false,\n            threshold: 10240,\n            algorithm: &#39;gzip&#39;,\n            ext: &#39;.gz&#39;,\n        &#125;),\n    ],</code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03ae3ac0703342e2b2d185598b845b14~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<h3 id=\"最终-vite-config-ts\"><a href=\"#最终-vite-config-ts\" class=\"headerlink\" title=\"最终 vite.config.ts\"></a>最终 vite.config.ts</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">import &#123;defineConfig&#125; from &#39;vite&#39;\nimport vue from &#39;@vitejs&#x2F;plugin-vue&#39;\nimport vueJsx from &#39;@vitejs&#x2F;plugin-vue-jsx&#39;\nimport * as path from &quot;path&quot;\nimport viteCompression from &#39;vite-plugin-compression&#39;\n\nexport default defineConfig(&#123;\n    base: &#39;.&#x2F;&#39;, &#x2F;&#x2F;打包路径\n\n    &#x2F;&#x2F;配置插件\n    plugins: [\n        vue(),\n        vueJsx(),\n        viteCompression(&#123;\n            verbose: true,\n            disable: false,\n            threshold: 10240,\n            algorithm: &#39;gzip&#39;,\n            ext: &#39;.gz&#39;,\n        &#125;),\n    ],\n    &#x2F;&#x2F;配置路径别名\n    resolve: &#123;\n        alias: &#123;\n            &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),\n        &#125;,\n    &#125;,\n    &#x2F;&#x2F;配置代理\n    server: &#123;\n        host: &#39;0.0.0.0&#39;,\n        port: 3000,\n        open: true,\n        https: false,\n        proxy: &#123;&#125;\n    &#125;,\n\n    &#x2F;&#x2F; 生产环境打包配置\n    &#x2F;&#x2F;去除 console debugger\n    build: &#123;\n        terserOptions: &#123;\n            compress: &#123;\n                drop_console: true,\n                drop_debugger: true,\n            &#125;,\n        &#125;,\n    &#125;,\n&#125;)</code></pre>\n\n<h2 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h2><p>可以查看官方文档：<a href=\"https://vitejs.cn/plugins/\">https://vitejs.cn/plugins/</a>\\</p>\n<ul>\n<li>  @vitejs/plugin-vue 提供 Vue 3 单文件组件支持</li>\n<li>  @vitejs/plugin-vue-jsx 提供 Vue 3 JSX 支持（通过 专用的 Babel 转换插件）</li>\n</ul>\n<!---->\n\n<ul>\n<li>  @vitejs/plugin-legacy 为打包后的文件提供传统浏览器兼容性支持</li>\n<li>  unplugin-vue-components 组件的按需自动导入</li>\n</ul>\n<!---->\n\n<ul>\n<li>  vite-plugin-compression 使用 gzip 或者 brotli 来压缩资源</li>\n</ul>\n<h2 id=\"非常推荐使用的-hooks-库\"><a href=\"#非常推荐使用的-hooks-库\" class=\"headerlink\" title=\"非常推荐使用的 hooks 库\"></a>非常推荐使用的 hooks 库</h2><p>因为vue3.x和react hooks真的很像，所以就称为 hooks\\</p>\n<p>VueUse：<a href=\"https://vueuse.org/\">https://vueuse.org/</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a2e600b674468ca0818b4528a009b6~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>看到这个库的第一眼，让我立马想到了 react 的 ahooks</p>\n<p>VueUse 是一个基于 Composition API 的实用函数集合。通俗的来说，这就是一个工具函数包，它可以帮助你快速实现一些常见的功能，免得你自己去写，解决重复的工作内容。以及进行了基于 Composition API 的封装。让你在 vue3 中更加得心应手。</p>\n<p>想要入手 vue3 的小伙伴，赶快学习起来吧！！！</p>\n<p>最后给大家奉上仓库地址吧：<a href=\"https://gitee.com/frontendBoy_wang/vite-vue3-ts-pinia-element_plus-template.git\">https://gitee.com/frontendBoy_wang/vite-vue3-ts-pinia-element_plus-template.git</a></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>公众号：前端少年汪</p>\n<p>专注分享 web 前端相关技术文章、视频教程资源、热点资讯等，如果喜欢我的分享，给 点一个赞 或者 ➕关注 都是对我最大的支持。</p>\n","feature":true,"text":"前言vue3如今已经成为默认版本了，相信大多数公司已经全面拥抱vue3了。 而Vite作为新一代的新型前端构建工具，使用它能够显著提升前端开发体验。 什么是Vite这里借用官方的介绍： 一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"前端","slug":"前端","count":5,"path":"api/categories/前端.json"}],"tags":[{"name":"vue JS","slug":"vue-JS","count":1,"path":"api/tags/vue-JS.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFVite\"><span class=\"toc-text\">什么是Vite</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Vite%E7%9A%84%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">Vite的优势</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA-Vite-%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">搭建第一个 Vite 项目</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85vue%E5%85%A8%E5%AE%B6%E6%A1%B6\"><span class=\"toc-text\">安装vue全家桶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Pinia%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">Pinia状态管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#getters-%E7%94%A8%E6%B3%95%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">getters 用法介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#actions\"><span class=\"toc-text\">actions</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#VueRouter\"><span class=\"toc-text\">VueRouter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Element-ui-plus\"><span class=\"toc-text\">Element-ui plus</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Axios%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">Axios封装</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#tsx%E6%94%AF%E6%8C%81\"><span class=\"toc-text\">tsx支持</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">环境变量配置</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Vite-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">Vite 常用基础配置</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">基础配置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90-gz-%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">生产环境生成 .gz 文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%BB%88-vite-config-ts\"><span class=\"toc-text\">最终 vite.config.ts</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6\"><span class=\"toc-text\">常用插件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%9E%E5%B8%B8%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%9A%84-hooks-%E5%BA%93\"><span class=\"toc-text\">非常推荐使用的 hooks 库</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E\"><span class=\"toc-text\">写在最后</span></a></li></ol></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"如何实现一个WebComponent组件","uid":"83d359dd0111440bbb3e9ab60e3adbe5","slug":"js/如何实现一个WebComponent组件","date":"2022-11-04T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/如何实现一个WebComponent组件.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/17.png","text":" 作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的 HTML（以及相关的样式和脚本），有时你不得不写代码来呈现自定义 UI 控件，并且如果你不小心的话，多次使用它们会使你的页面变得一团糟。 什么是Web Conmpon...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":5,"path":"api/categories/前端.json"},{"name":"js","slug":"前端/js","count":2,"path":"api/categories/前端/js.json"},{"name":"html","slug":"前端/js/html","count":1,"path":"api/categories/前端/js/html.json"}],"tags":[{"name":"web组件","slug":"web组件","count":1,"path":"api/tags/web组件.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"打工人面试避坑指南","uid":"5dcbffe5ec49005d84a364d2e66ecd0a","slug":"面试/2022年金三银四面试避坑指南","date":"2022-09-22T18:34:26.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/面试/2022年金三银四面试避坑指南.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/9.png","text":" 找工作如同西游取经，一波三折，九九八十一难，处处是坑啊。 工作内容(1)具体做什么其实这个部分，在之前的面试环节很多同学可能已经问过，这里的话其实可以再详细问问，比如具体负责什么业务线的工作，主要的工作内容是什么，会先从哪方面的工作入手等等，可以再具体详细地问一问HR。 (2)...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"面试","slug":"面试","count":2,"path":"api/categories/面试.json"}],"tags":[{"name":"工作 面试 避坑","slug":"工作-面试-避坑","count":1,"path":"api/tags/工作-面试-避坑.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}