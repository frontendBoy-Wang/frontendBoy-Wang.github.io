{"title":"go-redis使用入门","uid":"3b6ae5332ee3a25497987c8c3919316f","slug":"go/go-redis使用入门","date":"2023-04-18T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/go/go-redis使用入门.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/41.png","content":"<h1 id=\"安装go-redis\"><a href=\"#安装go-redis\" class=\"headerlink\" title=\"安装go-redis\"></a>安装go-redis</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;redis 6\ngo get github.com&#x2F;go-redis&#x2F;redis&#x2F;v8\n&#x2F;&#x2F;redis 7\ngo get github.com&#x2F;go-redis&#x2F;redis&#x2F;v9</code></pre>\n\n<h1 id=\"初始化连接redis\"><a href=\"#初始化连接redis\" class=\"headerlink\" title=\"初始化连接redis\"></a>初始化连接redis</h1><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func redisInit() &#123;\n\t&#x2F;&#x2F;初始化redis，连接地址和端口，密码，数据库名称\n\trdb &#x3D; redis.NewClient(&amp;redis.Options&#123;\n\t\tAddr:     &quot;localhost:6379&quot;,\n\t\tPassword: &quot;wmq12138&quot;,\n\t\tDB:       0,\n\t&#125;)\n&#125;</code></pre>\n\n<h1 id=\"入门案例\"><a href=\"#入门案例\" class=\"headerlink\" title=\"入门案例\"></a>入门案例</h1><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n)\n\nvar rdb *redis.Client\n\nfunc main() &#123;\n\tredisInit()\n\t&#x2F;&#x2F;创建上下文\n\tctx :&#x3D; context.Background()\n\t&#x2F;&#x2F;set方法设置key和value，处理返回的错误，参数（上下文，key名，value值，过期时间）\n\terr :&#x3D; rdb.Set(ctx, &quot;goredistest&quot;, &quot;test&quot;, 0).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F;get方法获取value\n\tval, err :&#x3D; rdb.Get(ctx, &quot;goredistest&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F;do方法使用原生命令,返回值是一个interface类型\n\tresult, err :&#x3D; rdb.Do(ctx, &quot;get&quot;, &quot;goredistest&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\tfmt.Println(&quot;get:&quot;, val)\n\tfmt.Print(&quot;原生命令：&quot;, result.(string))\n\n&#125;</code></pre>\n\n<h1 id=\"连接配置\"><a href=\"#连接配置\" class=\"headerlink\" title=\"连接配置\"></a>连接配置</h1><p>redis.NewClient(&amp;redis.Options{}),其中Options是连接的配置，是一个结构体类型，以下是配置选项和说明</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type Options struct &#123;\n  &#x2F;&#x2F; 网络类型：[ tcp , unix ]\n  &#x2F;&#x2F; 默认是 tcp\n  Network string\n\n  &#x2F;&#x2F; host:port 地址\n  Addr string\n\n  &#x2F;&#x2F; 要使用的 TLS 配置。 当设置 TLS 时将协商。\n  TLSConfig *tls.Config\n  &#x2F;&#x2F;创建一个新的连接，优先于Newwork和Addr选项\n  Dialer func(ctx context.Context, network, addr string) (net.Conn, error)\n  &#x2F;&#x2F; 新建一个redis连接的时候，会回调这个函数\n  OnConnect func(ctx context.Context, cn *Conn) error\n  &#x2F;&#x2F; 当连接到使用 Redis ACL 系统的 Redis 6.0 或更高版本的实例时，\n  &#x2F;&#x2F; 使用指定的 用户名 对当前连接进行身份验证  (ACL 列表中定义的连接之一)。\n  Username string\n\n  &#x2F;&#x2F; 可选密码。 \n  &#x2F;&#x2F; 必须与 requirepass 服务器配置选项中指定的密码（如果连接到 Redis 5.0 或更低版本的实例）\n  &#x2F;&#x2F; 或 连接到使用 Redis ACL 系统的 Redis 6.0 或更高版本的实例时的用户密码 匹配。\n  Password string\n\n  &#x2F;&#x2F; 连接到服务器后要选择的数据库。\n  DB int\n\n  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 重试、退避时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  &#x2F;&#x2F; 放弃前的最大重试次数。\n  &#x2F;&#x2F; 默认是 3 次重试； -1（非 0）禁用重试。\n  MaxRetries int\n  &#x2F;&#x2F; 每次重试之间的最小退避。\n  &#x2F;&#x2F; 默认为 8 毫秒； -1 禁用退避。\n  MinRetryBackoff time.Duration\n   &#x2F;&#x2F; 每次重试之间的最大退避。\n  &#x2F;&#x2F; 默认为 512 毫秒； -1 禁用退避。\n  MaxRetryBackoff time.Duration\n\n  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;连接超时、读超时、写超时&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  &#x2F;&#x2F; 建立新连接的拨号超时。\n  &#x2F;&#x2F; 默认为 5 秒。\n  DialTimeout time.Duration\n  &#x2F;&#x2F; 套接字读取超时。 \n  &#x2F;&#x2F; 如果达到，命令将失败并超时而不是阻塞。\n  &#x2F;&#x2F; 使用值 -1 表示无超时，使用 0 表示默认值。\n  &#x2F;&#x2F; 默认为 3 秒。\n  ReadTimeout time.Duration\n  &#x2F;&#x2F; 套接字写入超时。 \n  &#x2F;&#x2F; 如果达到，命令将失败并超时而不是阻塞。\n  &#x2F;&#x2F; 默认为 ReadTimeout。\n  WriteTimeout time.Duration\n\n  &#x2F;&#x2F; 连接池的类型。\n  &#x2F;&#x2F; FIFO 池为 true，LIFO 池为 false。\n  &#x2F;&#x2F; 请注意，与 lifo 相比，fifo 的开销更高。\n  PoolFIFO bool\n\n  &#x2F;&#x2F; 最大套接字连接数。\n  &#x2F;&#x2F; 默认为每个可用 CPU 10 个连接，由 runtime.GOMAXPROCS 报告。  \n  PoolSize int\n\n  &#x2F;&#x2F; 建立新连接缓慢时有用的最小空闲连接数。\n  MinIdleConns int\n\n  &#x2F;&#x2F; 客户端退出（关闭）连接的连接年龄。\n  &#x2F;&#x2F; 默认是不关闭老化的连接。\n  MaxConnAge time.Duration\n\n  &#x2F;&#x2F; 如果所有连接都忙，则客户端在返回错误之前等待连接的时间。\n  &#x2F;&#x2F; 默认为 ReadTimeout + 1 秒。\n  PoolTimeout time.Duration\n\n  &#x2F;&#x2F; 客户端关闭空闲连接的时间。\n  &#x2F;&#x2F; 应该小于服务器的超时时间。\n  &#x2F;&#x2F; 默认为 5 分钟。 -1 禁用空闲超时检查。\n  IdleTimeout time.Duration\n\n  &#x2F;&#x2F; 空闲连接 reaper 进行空闲检查的频率。\n  &#x2F;&#x2F; 默认为 1 分钟。 -1 禁用空闲连接reaper，\n  &#x2F;&#x2F; 但如果设置了 IdleTimeout，空闲连接仍会被客户端丢弃。\n  IdleCheckFrequency time.Duration\n  \n  &#x2F;&#x2F; 在从节点上启用只读查询。\n  readOnly bool\n\n  &#x2F;&#x2F; 用于实现断路器或速率限制器的限制器接口。\n  Limiter Limiter\n&#125;</code></pre>\n\n<hr>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n\t&quot;time&quot;\n)\n\nvar rdb *redis.Client          &#x2F;&#x2F;创建redis客户端实例\nvar ctx &#x3D; context.Background() &#x2F;&#x2F;创建上下文</code></pre>\n\n<h2 id=\"string类型的操作方法\"><a href=\"#string类型的操作方法\" class=\"headerlink\" title=\"string类型的操作方法\"></a>string类型的操作方法</h2><ul>\n<li>  Get</li>\n<li>  Set</li>\n<li>  GetSet</li>\n<li>  SetNX</li>\n<li>  MGset</li>\n<li>  MSet</li>\n<li>  Incr,IncrBy</li>\n<li>  Decr,DecrBy</li>\n<li>  Del</li>\n<li>  Expire</li>\n</ul>\n<h3 id=\"Get-获取key的值，返回值：错误信息error和value\"><a href=\"#Get-获取key的值，返回值：错误信息error和value\" class=\"headerlink\" title=\"Get 获取key的值，返回值：错误信息error和value\"></a>Get 获取key的值，返回值：错误信息error和value</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;get 方法 返回值和错误信息\nfunc Get(k string) string &#123;\n\tstr, err :&#x3D; rdb.Get(ctx, k).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n\tfmt.Println(&quot;key&quot;, k, &quot;的值：&quot;, str)\n\treturn str\n&#125;</code></pre>\n\n<h3 id=\"Set-设置key和value，以及key的过期时间expiration-返回值：error\"><a href=\"#Set-设置key和value，以及key的过期时间expiration-返回值：error\" class=\"headerlink\" title=\"Set 设置key和value，以及key的过期时间expiration 返回值：error\"></a>Set 设置key和value，以及key的过期时间expiration 返回值：error</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;set 方法\nfunc Set(key string, val interface&#123;&#125;, expiration time.Duration) &#123;\n\terr :&#x3D; rdb.Set(ctx, key, val, expiration).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"GetSet-设置一个key的值，并且返回这个key的旧值\"><a href=\"#GetSet-设置一个key的值，并且返回这个key的旧值\" class=\"headerlink\" title=\"GetSet 设置一个key的值，并且返回这个key的旧值\"></a>GetSet 设置一个key的值，并且返回这个key的旧值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">func GetSet(k string, v interface&#123;&#125;) interface&#123;&#125; &#123;\n\toldValue, err :&#x3D; rdb.GetSet(ctx, k, v).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n\tfmt.Println(&quot;设置一个key的值，并返回这个key的旧值:&quot;, oldValue)\n\treturn oldValue\n&#125;</code></pre>\n\n<h3 id=\"SetNX-如果key不存在，则设置这个key的值\"><a href=\"#SetNX-如果key不存在，则设置这个key的值\" class=\"headerlink\" title=\"SetNX 如果key不存在，则设置这个key的值\"></a>SetNX 如果key不存在，则设置这个key的值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">func SetNx(k string, v interface&#123;&#125;, t time.Duration) &#123;\n\terr :&#x3D; rdb.SetNX(ctx, k, v, t)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"MGet-批量查询key的值\"><a href=\"#MGet-批量查询key的值\" class=\"headerlink\" title=\"MGet 批量查询key的值\"></a>MGet 批量查询key的值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">func MGet(k ...string) &#123;\n\terr :&#x3D; rdb.MGet(ctx, k...)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"MSet-批量设置key的值\"><a href=\"#MSet-批量设置key的值\" class=\"headerlink\" title=\"MSet 批量设置key的值\"></a>MSet 批量设置key的值</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;MSet 批量设置key的值\nfunc MSet(values ...interface&#123;&#125;) &#123;\n\trdb.MSet(ctx, values)\n&#125;</code></pre>\n\n<h3 id=\"Del-删除单个或者多个key\"><a href=\"#Del-删除单个或者多个key\" class=\"headerlink\" title=\"Del 删除单个或者多个key\"></a>Del 删除单个或者多个key</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;delOneKeys 删除单个key\nfunc delOneKeys(k string) &#123;\n    rdb.Del(ctx, k)\n&#125;\n\n&#x2F;&#x2F;delKeys 删除多个key\nfunc delKeys(k ...string) &#123;\n\trdb.Del(ctx, k...)\n&#125;</code></pre>\n\n<h3 id=\"Expire-设置key的过期时间\"><a href=\"#Expire-设置key的过期时间\" class=\"headerlink\" title=\"Expire 设置key的过期时间\"></a>Expire 设置key的过期时间</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">func expire(k string, t time.Duration) &#123;\n\trdb.Expire(ctx, k, t)\n&#125;</code></pre>\n\n<h3 id=\"Incr针对一个key的数值进行递增操作\"><a href=\"#Incr针对一个key的数值进行递增操作\" class=\"headerlink\" title=\"Incr针对一个key的数值进行递增操作\"></a>Incr针对一个key的数值进行递增操作</h3><p>IncrBy指定每次递增多少 IncrByFloat 指定每次递增多少，跟IncrBy的区别是累加的是浮点数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;addVal 针对一个key的数值进行递增操作\nfunc addVal(k string) &#123;\n\t&#x2F;&#x2F; Incr函数每次加一\n\tval, err :&#x3D; rdb.Incr(ctx, &quot;key&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, val)\n\n\t&#x2F;&#x2F; IncrBy函数，可以指定每次递增多少\n\tvalBy, err :&#x3D; rdb.IncrBy(ctx, &quot;key&quot;, 2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valBy)\n\n\t&#x2F;&#x2F; IncrByFloat函数，可以指定每次递增多少，跟IncrBy的区别是累加的是浮点数\n\tvalFloat, err :&#x3D; rdb.IncrByFloat(ctx, &quot;key1&quot;, 2.2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valFloat)\n&#125;</code></pre>\n\n<h3 id=\"Decr-针对一个key的数值进行递减操作\"><a href=\"#Decr-针对一个key的数值进行递减操作\" class=\"headerlink\" title=\"Decr 针对一个key的数值进行递减操作\"></a>Decr 针对一个key的数值进行递减操作</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func Decr() &#123;\n\t&#x2F;&#x2F; Decr函数每次减一\n\tval, err :&#x3D; rdb.Decr(ctx, &quot;key&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, val)\n\n\t&#x2F;&#x2F; DecrBy函数，可以指定每次递减多少\n\tvalBy, err :&#x3D; rdb.DecrBy(ctx, &quot;key&quot;, 2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valBy)\n&#125;</code></pre>\n\n<h2 id=\"Hash类型的操作方法\"><a href=\"#Hash类型的操作方法\" class=\"headerlink\" title=\"Hash类型的操作方法\"></a>Hash类型的操作方法</h2><p><strong>内部采用数组+链表结构，采用链地址法解决哈希冲突。</strong></p>\n<ul>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_1-hset\">1. HSet</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_2-hget\">2. HGet</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_3-hgetall\">3. HGetAll</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_4-hincrby\">4. HIncrBy</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_5-hkeys\">5. HKeys</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_6-hlen\">6. HLen</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_7-hmget\">7. HMGet</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_8-hmset\">8. HMSet</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_9-hsetnx\">9. HSetNX</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_10-hdel\">10. HDel</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_11-hexists\">11. HExists</a></li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; HashMethods Hash 操作方法\nfunc HashMethods() &#123;\n\t&#x2F;&#x2F;●  HSet\n\t&#x2F;&#x2F; user_1 是hash key，username 是字段名, zhangsan是字段值\n\trdb.HSet(ctx, &quot;user_1&quot;, &quot;username&quot;, &quot;zhangsan&quot;, &quot;f1&quot;, &quot;f_v1&quot;)\n\t&#x2F;&#x2F;● 2. HGet \t根据key和field字段，查询field字段的值\n\tresult, _ :&#x3D; rdb.HGet(ctx, &quot;user_1&quot;, &quot;username&quot;).Result()\n\tfmt.Println(result)\n\n\t&#x2F;&#x2F;● 3. HGetAll\t获取所有的字段和值\n\tall, _ :&#x3D; rdb.HGetAll(ctx, &quot;user_1&quot;).Result()\n\tfmt.Println(all)\n\t&#x2F;&#x2F;● 4. HIncrBy 累加count字段的值，一次性累加2， user_1为hash key\n\tcount, err :&#x3D; rdb.HIncrBy(ctx, &quot;user_1&quot;, &quot;count&quot;, 2).Result()\n\tfmt.Println(count, err)\n\t&#x2F;&#x2F;● 5. HKeys根据key返回所有的字段名\n\tkeys :&#x3D; rdb.HKeys(ctx, &quot;user_1&quot;)\n\tfmt.Println(keys)\n\t&#x2F;&#x2F;● 6. HLen根据key，查询hash的字段数量\n\ti, err :&#x3D; rdb.HLen(ctx, &quot;user_1&quot;).Result()\n\tfmt.Println(i)\n\t&#x2F;&#x2F;● 7. HMGet根据key和多个字段名，批量查询多个hash字段值\n\tb, err :&#x3D; rdb.HMGet(ctx, &quot;user_1&quot;, &quot;f1&quot;, &quot;count&quot;).Result()\n\tfmt.Println(b)\n\t&#x2F;&#x2F;● 8. HMSet根据key和多个字段名和字段值，批量设置hash字段值\n\t&#x2F;&#x2F; 初始化hash数据的多个字段值\n\tdata :&#x3D; make(map[string]interface&#123;&#125;)\n\tdata[&quot;id&quot;] &#x3D; 1\n\tdata[&quot;username&quot;] &#x3D; &quot;lisi&quot;\n\t&#x2F;&#x2F; 一次性保存多个hash字段值\n\trdb.HMSet(ctx, &quot;key&quot;, data).Err()\n\n\t&#x2F;&#x2F;● 9. HSetNX如果field字段不存在，则设置hash字段值\n\trdb.HSetNX(ctx, &quot;user_1&quot;, &quot;f2&quot;, &quot;f2value&quot;)\n\t&#x2F;&#x2F;● 10. HDel根据key和字段名，删除hash字段，支持批量删除hash字段\n\t&#x2F;&#x2F; 删除一个字段id\n\trdb.HDel(ctx, &quot;key&quot;, &quot;id&quot;)\n\t&#x2F;&#x2F; 删除多个字段\n\trdb.HDel(ctx, &quot;key&quot;, &quot;id&quot;, &quot;username&quot;)\n\t&#x2F;&#x2F;● 11. HExists检测hash字段名是否存在\n\terr &#x3D; rdb.HExists(ctx,&quot;key&quot;, &quot;id&quot;).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Println(err)\n\t&#125;\n\n&#125;</code></pre>\n\n<h2 id=\"List的操作方法\"><a href=\"#List的操作方法\" class=\"headerlink\" title=\"List的操作方法\"></a>List的操作方法</h2><ul>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_1-lpush\">1. LPush</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_2-lpushx\">2. LPushX</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_3-rpop\">3. RPop</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_4-rpush\">4. RPush</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_5-rpushx\">5. RPushX</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_6-lpop\">6. LPop</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_7-llen\">7. LLen</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_8-lrange\">8. LRange</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_9-lrem\">9. LRem</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_10-lindex\">10. LIndex</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_11-linsert\">11. LInsert</a></li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;ListOperateMethods List操作方法\nfunc ListOperateMethods() &#123;\n\t&#x2F;&#x2F;● 1. LPush 添加到list的左侧,LPush支持一次插入一个或者任意个数据\n\trdb.LPush(ctx, &quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w&quot;)\n\t&#x2F;&#x2F;● 2. LPushX 跟LPush的区别是，仅当列表存在的时候才插入数据,用法完全一样。\n\trdb.LPushX(ctx, &quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w&quot;)\n\t&#x2F;&#x2F;● 3. RPop从列表的右边删除第一个数据，并返回删除的数据\n\trdb.RPop(ctx, &quot;w1&quot;)\n\t&#x2F;&#x2F;● 4. RPush\n\trdb.RPush(ctx, &quot;w1&quot;, &quot;wmq&quot;, &quot;wmq2&quot;)\n\t&#x2F;&#x2F;● 5. RPushX 跟RPush的区别是，仅当列表存在的时候才插入数据, 他们用法一样\n\trdb.RPushX(ctx, &quot;w1&quot;, &quot;wm3&quot;, &quot;w3&quot;)\n\t&#x2F;&#x2F;● 6. LPop从列表左边删除第一个数据，并返回删除的数据\n\tval, _ :&#x3D; rdb.LPop(ctx, &quot;w1&quot;).Result()\n\tfmt.Println(val)\n\t&#x2F;&#x2F;● 7. LLen返回列表的大小\n\tlLen, _ :&#x3D; rdb.LLen(ctx, &quot;w1&quot;).Result()\n\tfmt.Println(lLen)\n\t&#x2F;&#x2F;● 8. LRange返回列表的一个范围内的数据，也可以返回全部数据\n\tresult, _ :&#x3D; rdb.LRange(ctx, &quot;w1&quot;, 0, lLen).Result()\n\tfmt.Println(result)\n\t&#x2F;&#x2F;● 9. LRem删除列表中的数据 从列表左边开始，删除100， 如果出现重复元素，仅删除1次，也就是删除第一个\n\tdels, _ :&#x3D; rdb.LRem(ctx, &quot;key&quot;, 1, &quot;w1&quot;).Result()\n\tfmt.Println(dels)\n\t&#x2F;&#x2F;● 10. LIndex\n\t&#x2F;&#x2F; 列表索引从0开始计算，这里返回第6个元素\n\tval, _ &#x3D; rdb.LIndex(ctx, &quot;w1&quot;, 5).Result()\n\n\tfmt.Println(val)\n\t&#x2F;&#x2F;● 11. LInsert&#x2F;&#x2F; 在列表中5的前面插入4\n\t&#x2F;&#x2F;&#x2F;&#x2F; before是之前的意思\n\tinsert :&#x3D; rdb.LInsert(ctx, &quot;w1&quot;, &quot;after&quot;, 1, 2)\n\tfmt.Println(insert)\n&#125;</code></pre>\n\n<h2 id=\"Set的操作方法\"><a href=\"#Set的操作方法\" class=\"headerlink\" title=\"Set的操作方法\"></a>Set的操作方法</h2><p><strong>Set是无序且不会重复的字符串集合</strong> set和list的区别是set不包含重复的元素</p>\n<ul>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_1-sadd\">1. SAdd</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_2-scard\">2. SCard</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_3-sismember\">3. SIsMember</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_4-smembers\">4. SMembers</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_5-srem\">5. SRem</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_6-spop-spopn\">6. SPop,SPopN</a></li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;\tSet操作方法\nfunc setOperateMethods() &#123;\n\t&#x2F;&#x2F;● 1. SAdd\n\trdb.SAdd(ctx, &quot;set_key&quot;, 100, 10, 32, 4, 100, 5)\n\t&#x2F;&#x2F;● 2. SCard\n\tres, _ :&#x3D; rdb.SCard(ctx, &quot;set_key&quot;).Result()\n\tfmt.Println(res)\n\n\t&#x2F;&#x2F;● 3. SIsMember判断元素是否在集合中\n\tresult, _ :&#x3D; rdb.SIsMember(ctx, &quot;set_key&quot;, 900).Result()\n\tfmt.Println(result)\n\t&#x2F;&#x2F;● 4. SMembers 获取集合中所有的元素\n\tstrings, _ :&#x3D; rdb.SMembers(ctx, &quot;set_key&quot;).Result()\n\tfmt.Println(strings)\n\n\t&#x2F;&#x2F;● 5. SRem删除集合元素\n\ti, _ :&#x3D; rdb.SRem(ctx, &quot;set_key&quot;, 100, 4).Result()\n\tfmt.Println(&quot;返回删除的个数&quot;, i)\n\t&#x2F;&#x2F;● 6. SPop,SPopN 随机返回集合中的元素，并且删除返回的元素\n\trdb.SPop(ctx, &quot;set_key&quot;)\n\tfmt.Println(rdb.SMembers(ctx, &quot;set_key&quot;).Result())\n\n\t&#x2F;&#x2F; 随机返回集合中的一个元素，并且删除这个元素\n\tval, _ :&#x3D; rdb.SPop(ctx,&quot;key&quot;).Result()\n\tfmt.Println(val)\n\n\t&#x2F;&#x2F; 随机返回集合中的5个元素，并且删除这些元素\n\tvals, _ :&#x3D; rdb.SPopN(ctx,&quot;key&quot;, 5).Result()\n\tfmt.Println(vals)\n\n&#125;</code></pre>\n\n<h2 id=\"sorted-set操作方法\"><a href=\"#sorted-set操作方法\" class=\"headerlink\" title=\"sorted set操作方法\"></a>sorted set操作方法</h2><p>有序的，非重复的的字符串集合</p>\n<ul>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_1-zadd\">1. ZAdd</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_2-zcard\">2. ZCard</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_3-zcount\">3. ZCount</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_4-zincrby\">4. ZIncrBy</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_5-zrange-zrevrange\">5. ZRange,ZRevRange</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_6-zrangebyscore\">6. ZRangeByScore</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_7-zrevrangebyscore\">7. ZRevRangeByScore</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_8-zrangebyscorewithscores\">8. ZRangeByScoreWithScores</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_9-zrem\">9. ZRem</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_10-zremrangebyrank\">10. ZRemRangeByRank</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_11-zremrangebyscore\">11.ZRemRangeByScore</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_12-zscore\">12. ZScore</a></li>\n<li>  <a href=\"https://www.mszlu.com/go/go-redis/02/02.html#_13-zrank\">13. ZRank</a></li>\n</ul>\n<hr>\n<h1 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h1><p>Redis提供了发布订阅功能，可以用于消息的传输，Redis的发布订阅机制包括三个部分，发布者，订阅者和Channel。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9191e7cbae14520ae300552b6546303~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。</p>\n<h2 id=\"订阅者-subscriber\"><a href=\"#订阅者-subscriber\" class=\"headerlink\" title=\"订阅者 subscriber\"></a>订阅者 subscriber</h2><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;subscriber 订阅者订阅channel1的消息\nfunc subscriber() &#123;\n\t&#x2F;&#x2F; 订阅channel1这个channel\n\tsub :&#x3D; rdb.Subscribe(ctx, &quot;channel1&quot;)\n\t&#x2F;&#x2F; sub.Channel() 返回go channel，可以循环读取redis服务器发过来的消息\n\tfor msg :&#x3D; range sub.Channel() &#123;\n\t\t&#x2F;&#x2F; 打印收到的消息\n\t\tfmt.Println( msg.Channel, msg.Payload)\n\t\tfmt.Println()\n\t&#125;\n\t&#x2F;&#x2F;或者\n\tfor &#123;\n\t\tmsg, err :&#x3D; sub.ReceiveMessage(ctx)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tfmt.Println(err)\n\t\t&#125;\n\t\tfmt.Println(msg.Channel, msg.Payload)\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"发布者-publisher\"><a href=\"#发布者-publisher\" class=\"headerlink\" title=\"发布者 publisher\"></a>发布者 publisher</h2><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n\t&quot;strconv&quot;\n)\n\nvar rdb *redis.Client          &#x2F;&#x2F;创建redis客户端实例\nvar ctx &#x3D; context.Background() &#x2F;&#x2F;创建上下文\nfunc main() &#123;\n\t&#x2F;&#x2F;初始化redis，连接地址和端口，密码，数据库名称\n\trdb &#x3D; redis.NewClient(&amp;redis.Options&#123;\n\t\tAddr:     &quot;localhost:6379&quot;,\n\t\tPassword: &quot;&quot;,\n\t\tDB:       0,\n\t&#125;)\n\t&#x2F;&#x2F; 将&quot;message&quot;消息发送到channel1这个通道上\n\n\tfor i :&#x3D; 1; i &lt;&#x3D; 100; i++ &#123;\n\t\tfmt.Println(i)\n\t\tstr :&#x3D; strconv.Itoa(i) + &quot;.message收到前端回答&quot;\n\t\trdb.Publish(ctx, &quot;channel1&quot;, str)\n\t&#125;\n&#125;</code></pre>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7de52b591b14ae5a5f25d9f5552c228~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>其他的一些方法</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func cancelSub() &#123;\n\t&#x2F;&#x2F; 订阅channel1这个channel\n\tsub :&#x3D; rdb.Subscribe(ctx, &quot;channel1&quot;)\n\t&#x2F;&#x2F; 取消订阅\n\tsub.Unsubscribe(ctx, &quot;channel1&quot;)\n&#125;\n\nfunc querySubCount() &#123;\n\t&#x2F;&#x2F; 查询channel_1通道的订阅者数量\n\tchs, _ :&#x3D; rdb.PubSubNumSub(ctx, &quot;channel_1&quot;).Result()\n\tfor ch, count :&#x3D; range chs &#123;\n\t\tfmt.Println(ch)    &#x2F;&#x2F; channel名字\n\t\tfmt.Println(count) &#x2F;&#x2F; channel的订阅者数量\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"事务操作\"><a href=\"#事务操作\" class=\"headerlink\" title=\"事务操作\"></a>事务操作</h2><p>redis事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>\n<ul>\n<li>  事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>\n</ul>\n<h3 id=\"TxPinline\"><a href=\"#TxPinline\" class=\"headerlink\" title=\"TxPinline\"></a>TxPinline</h3><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;事务操作\n&#x2F;&#x2F;TxPinline\nfunc Txline() &#123;\n\t&#x2F;&#x2F; 开启一个TxPipeline事务\npipe :&#x3D; rdb.TxPipeline()\n\n&#x2F;&#x2F; 执行事务操作，可以通过pipe读写redis\nincr :&#x3D; pipe.Incr(ctx,&quot;tx_pipeline_counter&quot;)\npipe.Expire(ctx,&quot;tx_pipeline_counter&quot;, time.Hour)\n\n&#x2F;&#x2F; 上面代码等同于执行下面redis命令\n&#x2F;&#x2F;\n&#x2F;&#x2F;     MULTI\n&#x2F;&#x2F;     INCR pipeline_counter\n&#x2F;&#x2F;     EXPIRE pipeline_counts 3600\n&#x2F;&#x2F;     EXEC\n\n&#x2F;&#x2F; 通过Exec函数提交redis事务\n_, err :&#x3D; pipe.Exec(ctx)\n\n&#x2F;&#x2F; 提交事务后，我们可以查询事务操作的结果\n&#x2F;&#x2F; 前面执行Incr函数，在没有执行exec函数之前，实际上还没开始运行。\nfmt.Println(incr.Val(), err)\n&#125;</code></pre>\n\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><p>redis乐观锁支持，可以通过watch监听一些Key, 如果这些key的值没有被其他人改变的话，才可以提交事务</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func watch() &#123;\n\n\t&#x2F;&#x2F; 定义一个回调函数，用于处理事务逻辑\n\tfn :&#x3D; func(tx *redis.Tx) error &#123;\n\t\t&#x2F;&#x2F; 先查询下当前watch监听的key的值\n\t\tv, err :&#x3D; tx.Get(ctx, &quot;key&quot;).Int()\n\t\tif err !&#x3D; nil &amp;&amp; err !&#x3D; redis.Nil &#123;\n\t\t\treturn err\n\t\t&#125;\n\t\t&#x2F;&#x2F; 这里可以处理业务\n\t\tv++\n\n\t\t&#x2F;&#x2F; 如果key的值没有改变的话，Pipelined函数才会调用成功\n\t\t_, err &#x3D; tx.Pipelined(ctx, func(pipe redis.Pipeliner) error &#123;\n\t\t\t&#x2F;&#x2F; 在这里给key设置最新值\n\t\t\tpipe.Set(ctx, &quot;key&quot;, v, 0)\n\t\t\treturn nil\n\t\t&#125;)\n\t\treturn err\n\t&#125;\n\n\t&#x2F;&#x2F; 使用Watch监听一些Key, 同时绑定一个回调函数fn, 监听Key后的逻辑写在fn这个回调函数里面\n\t&#x2F;&#x2F; 如果想监听多个key，可以这么写：client.Watch(ctx,fn, &quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;)\n\trdb.Watch(ctx, fn, &quot;key&quot;)\n&#125;</code></pre>","feature":false,"text":"安装go-redis&#x2F;&#x2F;redis 6 go get github.com&#x2F;go-redis&#x2F;redis&#x2F;v8 &#x2F;&#x2F;redis 7 go get github.com&#x2F;go-redis&#x2F;re...","link":"","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"go","slug":"go","count":3,"path":"api/categories/go.json"}],"tags":[{"name":"go","slug":"go","count":1,"path":"api/tags/go.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85go-redis\"><span class=\"toc-text\">安装go-redis</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5redis\"><span class=\"toc-text\">初始化连接redis</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">入门案例</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">连接配置</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">string类型的操作方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Get-%E8%8E%B7%E5%8F%96key%E7%9A%84%E5%80%BC%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AFerror%E5%92%8Cvalue\"><span class=\"toc-text\">Get 获取key的值，返回值：错误信息error和value</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Set-%E8%AE%BE%E7%BD%AEkey%E5%92%8Cvalue%EF%BC%8C%E4%BB%A5%E5%8F%8Akey%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4expiration-%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9Aerror\"><span class=\"toc-text\">Set 设置key和value，以及key的过期时间expiration 返回值：error</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GetSet-%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AAkey%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E8%BF%99%E4%B8%AAkey%E7%9A%84%E6%97%A7%E5%80%BC\"><span class=\"toc-text\">GetSet 设置一个key的值，并且返回这个key的旧值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SetNX-%E5%A6%82%E6%9E%9Ckey%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AE%E8%BF%99%E4%B8%AAkey%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">SetNX 如果key不存在，则设置这个key的值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MGet-%E6%89%B9%E9%87%8F%E6%9F%A5%E8%AF%A2key%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">MGet 批量查询key的值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MSet-%E6%89%B9%E9%87%8F%E8%AE%BE%E7%BD%AEkey%E7%9A%84%E5%80%BC\"><span class=\"toc-text\">MSet 批量设置key的值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Del-%E5%88%A0%E9%99%A4%E5%8D%95%E4%B8%AA%E6%88%96%E8%80%85%E5%A4%9A%E4%B8%AAkey\"><span class=\"toc-text\">Del 删除单个或者多个key</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Expire-%E8%AE%BE%E7%BD%AEkey%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">Expire 设置key的过期时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Incr%E9%92%88%E5%AF%B9%E4%B8%80%E4%B8%AAkey%E7%9A%84%E6%95%B0%E5%80%BC%E8%BF%9B%E8%A1%8C%E9%80%92%E5%A2%9E%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Incr针对一个key的数值进行递增操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Decr-%E9%92%88%E5%AF%B9%E4%B8%80%E4%B8%AAkey%E7%9A%84%E6%95%B0%E5%80%BC%E8%BF%9B%E8%A1%8C%E9%80%92%E5%87%8F%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">Decr 针对一个key的数值进行递减操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hash%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Hash类型的操作方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#List%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">List的操作方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Set%E7%9A%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Set的操作方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#sorted-set%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">sorted set操作方法</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">发布订阅</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%A2%E9%98%85%E8%80%85-subscriber\"><span class=\"toc-text\">订阅者 subscriber</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%91%E5%B8%83%E8%80%85-publisher\"><span class=\"toc-text\">发布者 publisher</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">事务操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TxPinline\"><span class=\"toc-text\">TxPinline</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#watch\"><span class=\"toc-text\">watch</span></a></li></ol></li></ol></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"是时候该知道React中的Key属性的作用与最佳实践了","uid":"e4991464a66a20205c1c693e50c451bc","slug":"react/是时候该知道React中的Key属性的作用与最佳实践了","date":"2023-05-04T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/react/是时候该知道React中的Key属性的作用与最佳实践了.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/21.png","text":" 前言在React中，我们常常会遇到需要渲染列表或循环生成组件的场景。为了提高性能和优化用户体验，React引入了一个特殊的属性——key。本文将详细介绍React中key属性的作用、原理，并提供一些最佳实践。 一、Key属性的作用Key属性是React要求使用者在渲染多个组件时...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"react","slug":"react","count":3,"path":"api/categories/react.json"},{"name":"前端","slug":"react/前端","count":1,"path":"api/categories/react/前端.json"},{"name":"diff","slug":"react/前端/diff","count":1,"path":"api/categories/react/前端/diff.json"}],"tags":[{"name":"前端 react diff 虚拟dom","slug":"前端-react-diff-虚拟dom","count":1,"path":"api/tags/前端-react-diff-虚拟dom.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"前端项目(Vue,React)性能优化","uid":"aede38527e7a3b6a941a59510b6feb5f","slug":"js/前端项目(Vue,React)性能优化","date":"2023-04-18T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/前端项目(Vue,React)性能优化.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/48.png","text":"前言前端随着node等JavaScript运行时平台的出现，逐渐向工程化方向发展。项目开发也越来越规范化，但是随着项目的体积越来越大，依赖库越来越多，项目的运行，热更新和打包发布也是越来越慢，甚至卡顿。这个时候就需要对项目进行“瘦身”（性能优化）了。本文就围绕着如何给前端项目进行...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":1,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":1,"path":"api/tags/性能优化.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}