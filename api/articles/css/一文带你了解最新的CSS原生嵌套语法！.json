{"title":"一文带你了解最新的CSS原生嵌套语法！","uid":"644c16caca9a76ed91ed819723a4678a","slug":"css/一文带你了解最新的CSS原生嵌套语法！","date":"2023-06-10T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/css/一文带你了解最新的CSS原生嵌套语法！.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/33.png","content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/714bff47a0244fa4a4b66e5038ddff78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3840&h=2160&s=5018148&e=jpg&b=51acc3\" alt=\"wallhaven-3lrw69.jpg\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>CSS nesting provides the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of the parent rule. Similar behavior previously required a CSS pre-processor.   </p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>CSS嵌套提供了将一个样式规则嵌套在另一个样式中的能力，子规则的选择器相对于父规则的选择器。类似的行为以前需要CSS预处理器。</p></blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62c9dc3d4c9946588aee7189229fcade~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3010&h=1718&s=476287&e=png&a=1&b=27221a\" alt=\"image.png\"></p>\n<p>在Web开发中，CSS是一种关键的技术，用于样式化HTML元素。而为了更好地组织和管理样式代码，CSS原生嵌套语法应运而生。本文将带你深入了解CSS原生嵌套语法，探索其用法、特性和优势。</p>\n<ol>\n<li><p>什么是CSS原生嵌套语法？<br>CSS原生嵌套语法是一种CSS预处理器中常见的语法，它允许我们在样式表中使用嵌套的规则和选择器来组织样式代码。通过嵌套语法，我们可以更清晰地表示元素之间的层级关系，提高代码的可读性和维护性。</p>\n</li>\n<li><p>基本语法规则</p>\n</li>\n</ol>\n<ul>\n<li>选择器嵌套：在嵌套语法中，我们可以使用父元素的选择器作为子元素的前缀，以表示它们之间的层级关系。例如，<code>ul li</code>选择器表示选中所有父元素为<code>ul</code>的子元素为<code>li</code>的元素。</li>\n<li>属性嵌套：除了选择器嵌套外，我们还可以在嵌套语法中使用属性嵌套。例如，使用<code>font</code>属性时，我们可以使用<code>font-size</code>、<code>font-weight</code>等相关属性来设置字体的样式。这样可以更好地组织和管理属性相关的代码。</li>\n<li>伪元素嵌套：CSS原生嵌套语法还支持伪元素的嵌套。例如，我们可以使用<code>::after</code>伪元素来添加内容，并在其中定义样式。</li>\n</ul>\n<ol start=\"3\">\n<li><p>继承与覆盖<br>CSS原生嵌套语法具有继承和覆盖的特性。当子元素嵌套在父元素内部时，它会继承父元素的样式属性，从而减少代码的重复性。同时，如果需要覆盖父元素的样式，只需在子元素中重新定义该属性即可。</p>\n</li>\n<li><p>嵌套选择器的应用<br>嵌套选择器是CSS原生嵌套语法的一大亮点，它能够帮助我们编写更具可读性和维护性的选择器。通过嵌套选择器，我们可以更准确地选择特定的元素，并避免使用过于具体的选择器。这使得我们的样式表更加简洁和可扩展。</p>\n</li>\n<li><p>注意事项<br>在使用CSS原生嵌套语法时，需要注意以下几点：</p>\n</li>\n</ol>\n<ul>\n<li>避免过度嵌套：过多的嵌套可能会导致代码难以阅读和理解，应尽量保持嵌套层级的简洁性。</li>\n<li>选择器优先级：在嵌套语法中，选择器的优先级可能会增加。因此，在编写样式时，需要注意选择器的权重，以避免产生意外的结果。</li>\n</ul>\n<p>让我们来看看 CSS 嵌套语法是如何使用的！<br>从上面的浏览器版本支持来看（我使用的是谷歌浏览器）</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6780ba0131a4ea1a6b551f56cd546db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2842&h=1634&s=500093&e=png&a=1&b=242018\" alt=\"image.png\"><br>其中淡紫色是部分支持，绿色是完全支持。所以要先查看一下自己的浏览器的版本。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var browserVersion &#x3D; navigator.userAgent;\nconsole.log(browserVersion);\n\nMozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;118.0.0.0 Safari&#x2F;537.36</code></pre>\n<p>我的浏览器是118.0.0.0,支持部分特性。</p>\n<p>嵌套，就是将一个 CSS 规则放在另一个（嵌套规则）中，子规则的选择器将相对于父规则的选择器。这有利于代码的模块化和可维护性。原来只能在 CSS <a href=\"\">预处理器</a>中使用的嵌套功能，现在在原生 CSS 中也可以使用。<br>对比一下原生css嵌套和sass嵌套</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">main .colortable td &#123;  \n  text-align:center;  \n&#125;  \n  \nmain .colortable td.c &#123;  \n  text-transform:uppercase;  \n&#125;  \n  \nmain.colortable td:first-child, table.colortable td:first-child+td &#123;  \n  border:1px solid black;  \n&#125;  \n  \nmain.colortable th &#123;  \n  text-align:center;  \n  background:black;  \n  color:white;  \n&#125;\n</code></pre>\n<p>如果使用 CSS 嵌套时，就是这样的：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">main.colortable &#123;  \n  &amp; td &#123;  \n    text-align:center;  \n    &amp;.c &#123; text-transform:uppercase &#125;  \n    &amp;:first-child, &amp;:first-child + td &#123; border:1px solid black &#125;  \n  &#125;  \n  &amp; th &#123;  \n    text-align:center;  \n    background:black;  \n    color:white;  \n  &#125;  \n&#125;</code></pre>\n<p>使用嵌套不仅消除重复，相关规则的分组还提高了生成的 CSS 的可读性和可维护性。是不是好看多了</p>\n<h1 id=\"嵌套的规则\"><a href=\"#嵌套的规则\" class=\"headerlink\" title=\"嵌套的规则\"></a>嵌套的规则</h1><p>嵌套的规则可以使用嵌套选择器(&amp;)直接引用父规则的匹配元素，或者用相对选择器语法指定后代以外的关系</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.a &#123;  \n  color: red;  \n  \n  &amp;:hover &#123;  \n    color: blue;  \n  &#125;  \n&#125;  \n  \n&#x2F;* 相当于: *&#x2F;  \n  \n.a &#123; color: red; &#125;  \n.a:hover &#123; color: blue; &#125;</code></pre>\n\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">.a &#123;  \n  color: red;  \n  \n  + .b &#123;  \n    color: blue;  \n  &#125;  \n&#125;  \n  \n&#x2F;* 相当于: *&#x2F;  \n  \n.a &#123; color: red; &#125;  \n.a + .b &#123; color: blue; &#125;</code></pre>\n<h1 id=\"嵌套选择器\"><a href=\"#嵌套选择器\" class=\"headerlink\" title=\"嵌套选择器\"></a>嵌套选择器</h1><p>在使用嵌套规则时，必须能够引用父规则匹配的元素。为此，规范中定义了一个新的选择器，即<strong>嵌套选择器</strong>，写为 <code>&amp;</code> 。</p>\n<p>当在嵌套样式规则的选择器中使用时，嵌套选择器表示与父规则匹配的元素。当在任何其他上下文中使用时，它表示与该上下文中的 :scope 相同的元素。</p>\n<p>嵌套选择器可以通过 <code>:is()</code> 选择器将其替换为父样式规则的选择器。例如：</p>\n<pre class=\"line-numbers language-css\" data-language=\"css\"><code class=\"language-css\">a, b &#123;  \n  &amp; c &#123; color: blue; &#125;  \n&#125;\n这就相当于\n:is(a, b) c &#123; color: blue; &#125;</code></pre>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>CSS原生嵌套语法是一种用于组织和管理样式代码的强大工具。通过选择器嵌套、属性嵌套和伪元素嵌套等基本语法规则，我们可以更好地表达元素之间的层级关系和样式属性。继承与覆盖的特性使得代码更具灵活性和可维护性。同时，嵌套选择器的应用能够提高选择器的可读性和可扩展性。然而，在使用CSS原生嵌套语法时，需要避免过度嵌套和注意选择器的优先级。通过合理地运用这些技巧，我们能够更高效地编写和维护CSS样式表，提升Web开发的效率。</p>\n","feature":false,"text":" 前言 CSS nesting provides the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of ...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"css","slug":"css","count":1,"path":"api/categories/css.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E7%9A%84%E8%A7%84%E5%88%99\"><span class=\"toc-text\">嵌套的规则</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B5%8C%E5%A5%97%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">嵌套选择器</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"Vue3中使用TailwindCSS","uid":"8aa850786bf761363cb2e372eeaddd10","slug":"css/Vue3中使用TailwindCSS","date":"2023-07-10T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/css/Vue3中使用TailwindCSS.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/20.png","text":"前言当谈到前端开发框架时，Tailwind CSS 是一个备受瞩目的选择。它是一款功能强大且灵活的CSS框架，提供了大量的实用工具类，帮助开发者快速构建现代化的用户界面。在本篇技术博客中，我们将深入了解 Tailwind CSS 的主题和使用。 Tailwind CSS 是一种流...","link":"","photos":[],"count_time":{"symbolsCount":"3.5k","symbolsTime":"3 mins."},"categories":[{"name":"TailwindCSS","slug":"TailwindCSS","count":1,"path":"api/categories/TailwindCSS.json"}],"tags":[{"name":"css","slug":"css","count":2,"path":"api/tags/css.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"一文带你搞懂浏览器的事件循环机制！","uid":"063f99f939e2a1e1a5f4f8ebf1d3e74e","slug":"js/一文带你搞懂浏览器的事件循环机制！","date":"2023-06-10T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/一文带你搞懂浏览器的事件循环机制！.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/23.png","text":"什么是事件循环Event Loop 也叫做“事件循环”，它其实与 JavaScript 的运行机制有关，乍一看云里雾里，不用着急，读完本文你便会知晓它的含义，这一切都要从 JavaScript 的初始设计说起。 并发模型JavaScript 的并发模型是基于事件循环机制的，这个机...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"js","slug":"js","count":1,"path":"api/categories/js.json"}],"tags":[{"name":"js 事件循环","slug":"js-事件循环","count":1,"path":"api/tags/js-事件循环.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}