{"title":"react18新特性","uid":"353ce1343760f6de753e88dbaf24c997","slug":"react/听说你还不知道React18新特性？看我给你整明白！","date":"2023-03-17T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/react/听说你还不知道React18新特性？看我给你整明白！.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/37.png","content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186a3370c05644129c57e076bd1c47e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3840&h=2160&s=11790803&e=png&b=e9e0eb\" alt=\"wallhaven-9m3r9k_3840x2160.png\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>目前react的最新版本是18.2.0。React 团队在 2022 年 3 月 29 日正式发布了 React 的第 18 个版本 是 React 框架的最新版本，它主要着眼于解决 React 应用在性能、稳定性、开发体验等方面的问题。本文将介绍 React 18 的升级内容、新特性、新的 API、底层逻辑更新等方面的内容，并通过示例展示其使用效果。 我将在这篇文章里简单介绍 React 18 的新特性，React Concurrent Mode（并发模式）的实现，以及简要的升级指南。</p>\n<h1 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h1><ul>\n<li>  react18 已经不支持IE浏览器</li>\n<li>  新项目： 直接用 <code>npm</code> 或者 <code>yarn</code> 安装最新版依赖即可（如果是js，可以不需要安装types类型声明文件）</li>\n<li>  改变根节点的挂载方式使用新的 API <code>createRoot</code>，使用旧的 API 仍然兼容，只有在使用 <code>createRoot</code> 了之后才会有 React 18 的新特性。</li>\n</ul>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">ReactDOM.createRoot(document.getElementById(&#39;root&#39;)!).render(\n  &lt;React.StrictMode&gt;\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &lt;App&#x2F;&gt;\n    &lt;&#x2F;Provider&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n)</code></pre>\n\n<p>在这个示例中，我们使用了 <code>ReactDOM.createRoot</code> 方法创建了一个根节点，并使用 <code>render</code> 方法将组件渲染到根节点中。这样可以让 React 应用更快地响应用户操作，提高用户体验。</p>\n<h1 id=\"react18-setState异步同步\"><a href=\"#react18-setState异步同步\" class=\"headerlink\" title=\"react18 setState异步同步\"></a>react18 setState异步同步</h1><p>在 React 18 中，<code>setState</code> 的行为有一些改变，它将更倾向于以异步方式进行更新，但也提供了一些选项来控制同步更新。下面是关于 React 18 中 <code>setState</code> 的异步和同步行为的解释：</p>\n<h2 id=\"1-异步更新（默认行为）：\"><a href=\"#1-异步更新（默认行为）：\" class=\"headerlink\" title=\"1.  异步更新（默认行为）：\"></a>1.  异步更新（默认行为）：</h2><p>在 React 18 中，默认情况下，<code>setState</code> 方法会以异步方式进行更新。这意味着它会将多个状态更新批量处理，并在适当的时机进行合并和应用，以优化性能。这样做可以减少不必要的重渲染，并提高应用程序的响应性。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\n&#x2F;&#x2F; 异步更新\nthis.setState(&#123; count: this.state.count + 1 &#125;);</code></pre>\n\n<h2 id=\"2-同步更新（使用-flushSync）：\"><a href=\"#2-同步更新（使用-flushSync）：\" class=\"headerlink\" title=\"2.  同步更新（使用 flushSync）：\"></a>2.  同步更新（使用 <code>flushSync</code>）：</h2><p>尽管 <code>setState</code> 默认以异步方式进行更新，但在某些情况下，您可能需要立即获取更新后的状态。为了实现此目的，React 18 提供了 <code>flushSync</code> 方法，可以强制执行同步更新。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; flushSync &#125; from &#39;react-dom&#39;;\n\n&#x2F;&#x2F; 同步更新\n\nflushSync(() &#x3D;&gt; &#123;\n\n  this.setState(&#123; count: this.state.count + 1 &#125;);\n\n&#125;);</code></pre>\n\n<p>通过使用 <code>flushSync</code> 包裹 <code>setState</code> 的调用，您可以确保在执行下一个任务之前立即获取到更新后的状态。请注意，使用 <code>flushSync</code> 可能会对性能产生影响，并且应谨慎使用，以避免阻塞主线程。</p>\n<p>需要注意的是，React 18 引入了一种新的异步渲染优先级机制，称为 <code>useTransition</code>。通过使用 <code>useTransition</code>，您可以控制异步更新的优先级。这对于在高优先级工作（例如用户交互）和低优先级工作（例如懒加载数据）之间进行平衡非常有用。然而，它不直接影响 <code>setState</code> 的异步/同步行为，而是影响更新的优先级。</p>\n<p>总结一下，在 React 18 中，<code>setState</code> 通常以异步方式进行更新，并且使用 <code>flushSync</code> 可以实现同步更新。此外，您还可以使用 <code>useTransition</code> 提供的优先级控制来平衡不同任务之间的更新。</p>\n<h1 id=\"React18-新增API\"><a href=\"#React18-新增API\" class=\"headerlink\" title=\"React18 新增API\"></a>React18 新增API</h1><p>React 18 是 React 的一个重要版本，它包含了一些新的特性和改进，其中一些会对应用程序的开发流程、性能和用户体验产生重要影响。以下是 React 18 中新增的一些 API：</p>\n<h2 id=\"1-startTransition\"><a href=\"#1-startTransition\" class=\"headerlink\" title=\"1.  startTransition\"></a>1.  <code>startTransition</code></h2><p><code>startTransition</code> 是一个新的 React API，旨在帮助开发者优化应用程序的性能和用户体验。这个函数可以告诉 React 在下次重新渲染组件时，应该延迟更新状态。这样，一些较慢的操作（例如异步请求等）就可以在后台执行，不会影响应用程序的交互性能。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; startTransition &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  const [results, setResults] &#x3D; useState([]);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      fetch(&#96;&#x2F;api&#x2F;search?query&#x3D;$&#123;searchTerm&#125;&#96;)\n\n        .then(response &#x3D;&gt; response.json())\n\n        .then(data &#x3D;&gt; setResults(data));\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &lt;ul&gt;\n\n        &#123;results.map(result &#x3D;&gt; (\n\n          &lt;li key&#x3D;&#123;result.id&#125;&gt;&#123;result.title&#125;&lt;&#x2F;li&gt;\n\n        ))&#125;\n\n      &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用 <code>startTransition</code> 函数将异步请求和状态更新操作包裹起来，以告诉 React 在下一次重新渲染之前应该延迟更新状态。</p>\n<h2 id=\"2-useTransition\"><a href=\"#2-useTransition\" class=\"headerlink\" title=\"2.  useTransition\"></a>2.  <code>useTransition</code></h2><p><code>useTransition</code> 是 <code>startTransition</code> 的 hook 版本。它可以在函数组件中使用，从而让开发者更方便地控制异步操作的状态。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; useState, useTransition &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  const [results, setResults] &#x3D; useState([]);\n\n  const [isPending, setIsPending] &#x3D; useState(false);\n\n  const [startTransition, isPendingTransition] &#x3D; useTransition(&#123; timeoutMs: 3000 &#125;);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      setIsPending(true);\n\n      fetch(&#96;&#x2F;api&#x2F;search?query&#x3D;$&#123;searchTerm&#125;&#96;)\n\n        .then(response &#x3D;&gt; response.json())\n\n        .then(data &#x3D;&gt; setResults(data))\n\n        .finally(() &#x3D;&gt; setIsPending(false));\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &#123;isPendingTransition ? &lt;p&gt;Loading...&lt;&#x2F;p&gt; : null&#125;\n\n      &lt;ul&gt;\n\n        &#123;results.map(result &#x3D;&gt; (\n\n          &lt;li key&#x3D;&#123;result.id&#125;&gt;&#123;result.title&#125;&lt;&#x2F;li&gt;\n\n        ))&#125;\n\n      &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用 <code>useTransition</code> hook 来控制异步请求的状态，并在加载数据时显示一个 Loading… 的提示信息。</p>\n<h2 id=\"3-createRoot\"><a href=\"#3-createRoot\" class=\"headerlink\" title=\"3.  createRoot\"></a>3.  <code>createRoot</code></h2><p><code>createRoot</code> 是一个新的入口函数，用于创建根 React 组件。它可以替代原先的 <code>ReactDOM.render</code> 方法，使得开发者可以将多个根节点渲染到一个页面上。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nimport &#123; createRoot &#125; from &#39;react-dom&#39;;\n\nfunction App() &#123;\n\n  return (\n\n    &lt;div&gt;Hello, world!&lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n&#x2F;&#x2F; 原先的使用方式\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));\n\n&#x2F;&#x2F; 新的使用方式\n\nconst rootElement &#x3D; document.getElementById(&#39;root&#39;);\n\ncreateRoot(rootElement).render(&lt;App &#x2F;&gt;);</code></pre>\n\n<p>在上述代码中，我们使用 <code>createRoot</code> 函数来创建根 React 组件，并将其渲染到页面上。这样，我们就可以使用多个根节点来构建各种复杂的应用程序界面。</p>\n<h2 id=\"4-useDeferredValue\"><a href=\"#4-useDeferredValue\" class=\"headerlink\" title=\"4.  useDeferredValue\"></a>4.  <code>useDeferredValue</code></h2><p><code>useDeferredValue</code> 是一个新的 hook，可以将某个状态值的更新延迟一段时间后再执行，从而提高应用程序的性能和用户体验。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nimport &#123; useState, useDeferredValue &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n  &#125;\n\n  const deferredSearchTerm &#x3D; useDeferredValue(searchTerm, &#123;\n\n    timeoutMs: 1000\n\n  &#125;);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &lt;p&gt;Search term: &#123;deferredSearchTerm&#125;&lt;&#x2F;p&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用 <code>useDeferredValue</code> hook 将搜索词的更新延迟了一秒钟。这样，用户在快速输入搜索词时，不会因为频繁的重新渲染而出现卡顿等问题。</p>\n<h2 id=\"5-useTransition\"><a href=\"#5-useTransition\" class=\"headerlink\" title=\"5.  useTransition\"></a>5.  <code>useTransition</code></h2><p>上面已经提到过了，在 React 18 中新增了 <code>useTransition</code> hook，用于帮助开发者控制异步操作的状态。</p>\n<h2 id=\"6-useMutableSource\"><a href=\"#6-useMutableSource\" class=\"headerlink\" title=\"6.  useMutableSource\"></a>6.  <code>useMutableSource</code></h2><p><code>useMutableSource</code> 是一个新的 hook，用于获取可变数据源，并可以在多个组件之间共享状态。它可以帮助开发者拆分组件逻辑，并使其更加灵活和可复用。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; useMutableSource &#125; from &#39;react&#39;;\n\nconst myDataSource &#x3D; &#123;\n\n  get: () &#x3D;&gt; (&#123; count: 0 &#125;),\n\n  subscribe: (handleUpdate) &#x3D;&gt; &#123;\n\n    const intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      handleUpdate(&#123; count: Math.floor(Math.random() * 100) &#125;);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; clearInterval(intervalId);\n\n  &#125;\n\n&#125;;\n\nfunction Counter() &#123;\n\n  const [dataSource, setDataSource] &#x3D; useState(() &#x3D;&gt; myDataSource);\n\n  const [count, setCount] &#x3D; useState(0);\n\n  function handleUpdate(data) &#123;\n\n    setCount(count &#x3D;&gt; count + data.count);\n\n  &#125;\n\n  useEffect(() &#x3D;&gt; &#123;\n\n    const unsubscribe &#x3D; dataSource.subscribe(handleUpdate);\n\n    return unsubscribe;\n\n  &#125;, [dataSource]);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setDataSource(myDataSource)&#125;&gt;Restart&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\nfunction App() &#123;\n\n  const [dataSource, setDataSource] &#x3D; useState(() &#x3D;&gt; myDataSource);\n\n  const [, forceUpdate] &#x3D; useReducer(x &#x3D;&gt; x + 1, 0);\n\n  function handleRestart() &#123;\n\n    setDataSource(myDataSource);\n\n    forceUpdate();\n\n  &#125;\n\n  const count &#x3D; useMutableSource(dataSource, (&#123; count &#125;) &#x3D;&gt; count);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;handleRestart&#125;&gt;Restart&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用 <code>myDataSource</code> 作为可变数据源，并将其共享到多个组件中。在 <code>Counter</code> 组件中，我们订阅了数据源的更新，并实时反映出计数器的变化。在 <code>App</code> 组件中，我们使用了 <code>useMutableSource</code> hook 来获取数据源的值，从而实现了多组件之间的状态共享。</p>\n<p>总而言之，React 18 中引入了许多有用的新特性和 API，包括 <code>startTransition</code>、<code>useTransition</code>、<code>createRoot</code>、<code>useDeferredValue</code>、<code>useMutableSource</code> 等。这些新特性和 API 可以让开发者更方便地构建高性能、灵活和可复用的 React 应用程序。</p>\n<h1 id=\"新增Hooks\"><a href=\"#新增Hooks\" class=\"headerlink\" title=\"新增Hooks\"></a>新增Hooks</h1><p>React 18 引入了一些新的 hooks，以帮助开发者更好地管理状态和副作用。以下是 React 18 中新增的一些 hooks：</p>\n<h2 id=\"1-useTransition\"><a href=\"#1-useTransition\" class=\"headerlink\" title=\"1.  useTransition\"></a>1.  <code>useTransition</code></h2><p><code>useTransition</code> 允许开发者在处理潜在的延迟操作时控制异步更新的优先级。它接受一个配置对象，可以设置超时时间和中断标志等选项。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; useTransition &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n\n  const [isPending, startTransition] &#x3D; useTransition(&#123; timeoutMs: 2000 &#125;);\n\n  function handleClick() &#123;\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      &#x2F;&#x2F; 执行某个需要较长时间的操作\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;开始操作&lt;&#x2F;button&gt;\n\n      &#123;isPending &amp;&amp; &lt;p&gt;操作进行中...&lt;&#x2F;p&gt;&#125;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>useTransition</code> hook 来控制长时间操作的优先级，并在操作进行中显示一个提示信息。</p>\n<h2 id=\"2-useDeferredValue\"><a href=\"#2-useDeferredValue\" class=\"headerlink\" title=\"2.  useDeferredValue\"></a>2.  <code>useDeferredValue</code></h2><p><code>useDeferredValue</code> 允许开发者将某个状态的更新推迟到未来的帧中。这对于处理与用户输入相关的操作非常有用，可以避免在频繁输入时产生连续的重渲染。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; useState, useDeferredValue &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  function handleChange(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n  &#125;\n\n  const deferredSearchTerm &#x3D; useDeferredValue(searchTerm, &#123;\n\n    timeoutMs: 500\n\n  &#125;);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n\n      &lt;p&gt;搜索词: &#123;deferredSearchTerm&#125;&lt;&#x2F;p&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>useDeferredValue</code> hook 来将搜索词的更新推迟了 500ms。这样，在频繁输入时，只有用户停止输入一段时间后，才会执行搜索操作。</p>\n<h2 id=\"3-useMutableSource\"><a href=\"#3-useMutableSource\" class=\"headerlink\" title=\"3.  useMutableSource\"></a>3.  <code>useMutableSource</code></h2><p><code>useMutableSource</code> 允许开发者访问可变的数据源，并在多个组件之间共享状态。这对于高性能的数据订阅和共享非常有用。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport &#123; useMutableSource &#125; from &#39;react&#39;;\n\nconst myDataSource &#x3D; &#123;\n\n  get: () &#x3D;&gt; (&#123; count: 0 &#125;),\n\n  subscribe: (callback) &#x3D;&gt; &#123;\n\n    const interval &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      callback(&#123; count: Math.floor(Math.random() * 100) &#125;);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; clearInterval(interval);\n\n  &#125;\n\n&#125;;\n\nfunction MyComponent() &#123;\n\n  const [, forceUpdate] &#x3D; useState(&#123;&#125;);\n\n  const count &#x3D; useMutableSource(myDataSource, source &#x3D;&gt; source.get());\n\n  function handleRestart() &#123;\n\n    forceUpdate(&#123;&#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;handleRestart&#125;&gt;重启&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>useMutableSource</code> hook 来获取可变数据源中的值，并在计数器组件中共享该状态。</p>\n<p>这些是 React 18 中新增的一些重要 hooks。通过使用这些 hooks，开发者可以更好地管理状态、处理潜在的延迟操作，并实现高性能的数据共享。除了这些新增的 hooks，React 18 也支持其他常用的 hooks，如 <code>useState</code>、<code>useEffect</code>、<code>useCallback</code> 等。</p>\n<h1 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h1><p>React 严格模式（Strict Mode）是一个开发模式，可以帮助开发者发现一些潜在的问题，以提高应用程序的质量。启用严格模式后，React 会执行额外的检查和警告，以帮助开发者发现一些常见问题，并尽早地解决它们。</p>\n<p>启用 React 严格模式可以通过在代码中添加如下代码实现：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nReactDOM.render(\n\n  &lt;React.StrictMode&gt;\n\n    &lt;App &#x2F;&gt;\n\n  &lt;&#x2F;React.StrictMode&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);</code></pre>\n\n<p>在上述代码中，我们使用 <code>React.StrictMode</code> 组件来包裹应用程序的顶层组件 <code>&lt;App&gt;</code>。这样，React 将会在严格模式下执行应用程序，并对常见问题进行检查和提示。</p>\n<p>React 严格模式主要包含以下几个方面的检查和提示：</p>\n<ul>\n<li>  识别不安全的生命周期方法，提示开发者修改，这些方法可能会导致意外的副作用或错误。</li>\n<li>  检测意外的副作用，例如：多余的重新渲染、不符合预期的函数调用等。</li>\n<li>  检测某些过时的 API 使用，提供更好的替代方案。</li>\n<li>  检测警告信息，使其更加明显和易于发现。</li>\n</ul>\n<p>需要注意的是，React 严格模式只在开发环境下工作，不会影响生产环境下的应用程序。因此，在开发过程中启用严格模式可以帮助开发者及早发现问题，并尽可能将这些问题解决，以提高应用程序的稳定性和质量。</p>\n<p>总而言之，React 严格模式是一种非常有用的开发模式，可以帮助开发者发现常见问题并提高应用程序的质量。通过在顶层组件中添加 <code>&lt;React.StrictMode&gt;</code> 包裹，我们可以启用严格模式，并享受其带来的好处。</p>\n<h2 id=\"如何禁用严格模式\"><a href=\"#如何禁用严格模式\" class=\"headerlink\" title=\"如何禁用严格模式\"></a>如何禁用严格模式</h2><p>在 React 应用中禁用严格模式可以通过以下两种方式实现：</p>\n<h2 id=\"1-直接移除-lt-React-StrictMode-gt-组件\"><a href=\"#1-直接移除-lt-React-StrictMode-gt-组件\" class=\"headerlink\" title=\"1.  直接移除 &lt;React.StrictMode&gt; 组件\"></a>1.  直接移除 <code>&lt;React.StrictMode&gt;</code> 组件</h2><p>最简单的方法是将应用程序顶层组件中的 <code>&lt;React.StrictMode&gt;</code> 组件直接移除。这样，React 将不会启用严格模式，也不会执行额外的检查和警告。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nimport App from &#39;.&#x2F;App&#39;;\n\nReactDOM.render(\n\n  &lt;App &#x2F;&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);</code></pre>\n\n<h2 id=\"2-在应用程序启动时禁用严格模式\"><a href=\"#2-在应用程序启动时禁用严格模式\" class=\"headerlink\" title=\"2.  在应用程序启动时禁用严格模式\"></a>2.  在应用程序启动时禁用严格模式</h2><p>在一些情况下，移除 <code>&lt;React.StrictMode&gt;</code> 组件可能不太方便，例如：在大型项目中或已经存在大量的 <code>console.log</code> 调用等代码片段。此时，可以在应用程序启动时禁用严格模式。</p>\n<p>在应用程序启动文件中，我们可以使用 React 的 <code>unstable_disableDevMode()</code> 函数来禁用严格模式：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nimport App from &#39;.&#x2F;App&#39;;\n\nReact.unstable_disableDevMode();\n\nReactDOM.render(\n\n  &lt;React.StrictMode&gt;\n\n    &lt;App &#x2F;&gt;\n\n  &lt;&#x2F;React.StrictMode&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);</code></pre>\n\n<p>在上述代码中，我们在调用 <code>ReactDOM.render</code> 之前调用了 <code>React.unstable_disableDevMode()</code> 函数，以禁用严格模式。该函数并不在文档中明确提供支持，因此请谨慎使用。</p>\n<p>需要注意的是，禁用严格模式可能会导致一些潜在问题无法被及早发现，因此建议仅在必要时使用。同时，需要确保 React 版本兼容性，并遵循最佳实践和安全规则。</p>\n<h1 id=\"并发模式\"><a href=\"#并发模式\" class=\"headerlink\" title=\"并发模式\"></a>并发模式</h1><p>React 并发模式（React Concurrent Mode）是 React 的一项新功能，旨在改善在复杂应用程序中的用户体验和性能。在传统的 React 中，更新组件树时会阻塞用户界面的响应，可能导致卡顿和延迟。而并发模式通过将任务分解为多个小步骤，让 React 在执行渲染和布局时可以中断和恢复任务，从而提供更平滑和响应式的用户体验。</p>\n<p>在 React 并发模式中，引入了两个主要概念：任务调度和优先级。任务调度器负责决定哪些任务执行、何时执行以及中断和恢复任务。优先级允许 React 根据任务的紧迫性来安排任务的执行顺序，确保响应度更高的任务能够优先执行。</p>\n<p>利用并发模式，React 可以将渲染过程分解为多个小任务，并根据优先级来动态调整任务执行的顺序。这样，在浏览器空闲时间或网络请求等异步操作期间，React 可以暂停当前任务，执行其他具有更高优先级的任务，以实现更爽快的用户交互体验。</p>\n<p>总而言之，React 并发模式通过任务调度和优先级机制，提供了更好的用户体验和性能，使得 React 应用程序能够更加平滑地响应用户操作。</p>\n<p>以下是一个简单的示例代码，展示了 React Concurrent Mode 的基本用法：</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import React, &#123; useState, useEffect, unstable_ConcurrentMode as ConcurrentMode &#125; from &#39;react&#39;;\n\n\nfunction App() &#123;\n\n  const [count, setCount] &#x3D; useState(0);\n\n  useEffect(() &#x3D;&gt; &#123;\n\n    const timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      setCount((prevCount) &#x3D;&gt; prevCount + 1);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; &#123;\n\n      clearInterval(timer);\n\n    &#125;;\n\n  &#125;, []);\n\n  return (\n\n    &lt;ConcurrentMode&gt;\n\n      &lt;div&gt;\n\n        &lt;h1&gt;计数器&lt;&#x2F;h1&gt;\n\n        &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;&#x2F;div&gt;\n\n    &lt;&#x2F;ConcurrentMode&gt;\n\n  );\n\n&#125;\n\nexport default App;</code></pre>\n\n<p>在上面的示例中，我们使用了 <code>unstable_ConcurrentMode</code> 组件来包裹根元素。这表示该组件下的子组件可以享受到并发模式的好处。</p>\n<p>在 <code>App</code> 组件中，我们使用了 <code>useState</code> 来声明一个状态变量 <code>count</code>，并通过 <code>setCount</code> 来更新它的值。在 <code>useEffect</code> 中，我们使用定时器每秒钟增加 <code>count</code> 的值。注意，我们传递了空数组作为第二个参数，表示只在组件挂载时执行一次。</p>\n<p>最后，在组件的返回值中，我们使用 <code>&lt;ConcurrentMode&gt;</code> 组件包裹了整个应用程序的 UI。这样，React 将会利用并发模式来处理渲染任务，以提供更平滑和响应式的用户体验。</p>\n<h1 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h1><p>React 18 并没有专门针对服务端渲染（SSR）进行大规模的改进，但它仍然提供了一些与 SSR 相关的 API 和改进。以下是一些我们在 React 18 中可以使用的 SSR 相关功能：</p>\n<h2 id=\"1-useOpaqueIdentifier\"><a href=\"#1-useOpaqueIdentifier\" class=\"headerlink\" title=\"1.  useOpaqueIdentifier\"></a>1.  <code>useOpaqueIdentifier</code></h2><p><code>useOpaqueIdentifier</code> 允许开发者生成与数据不相关的、不透明的标识符，并在 SSR 上使用这些标识符来生成唯一的 DOM ID。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; useOpaqueIdentifier &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n  const id &#x3D; useOpaqueIdentifier();\n\n  return &lt;div id&#x3D;&#123;&#96;my-component-$&#123;id&#125;&#96;&#125;&gt;My component&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>useOpaqueIdentifier</code> hook 来生成一个不透明的标识符，并将其用于组件的 DOM ID 中。由于这个标识符与数据无关，因此在 SSR 上也可以正确地生成唯一的 ID。</p>\n<h2 id=\"2-ReactDOMServer-renderToStringAsync\"><a href=\"#2-ReactDOMServer-renderToStringAsync\" class=\"headerlink\" title=\"2.  ReactDOMServer.renderToStringAsync\"></a>2.  <code>ReactDOMServer.renderToStringAsync</code></h2><p>  <code>ReactDOMServer.renderToStringAsync</code> 允许开发者异步地渲染组件并输出 HTML。这样可以避免在 SSR 期间阻塞主线程，在数据加载和计算时保持响应性。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import ReactDOMServer from &#39;react-dom&#x2F;server&#39;;\n\nasync function renderApp(req, res) &#123;\n  const app &#x3D; &lt;MyApp &#x2F;&gt;;\n  const html &#x3D; await ReactDOMServer.renderToStringAsync(app);\n  res.send(html);\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>ReactDOMServer.renderToStringAsync</code> 方法异步地将 <code>&lt;MyApp /&gt;</code> 组件渲染为 HTML，并在 Express 中将其发送到客户端。</p>\n<h2 id=\"3-Concurrent-Mode\"><a href=\"#3-Concurrent-Mode\" class=\"headerlink\" title=\"3.  Concurrent Mode\"></a>3.  Concurrent Mode</h2><p>   Concurrent Mode 是 React 18 中引入的一个新特性，它通过异步渲染和交互优先级控制等方式提升了应用程序的响应性。在 SSR 中，Concurrent Mode 可以帮助开发者更好地处理异步数据加载和渲染等任务。</p>\n<pre class=\"line-numbers language-tsx\" data-language=\"tsx\"><code class=\"language-tsx\">import &#123; unstable_createRoot &#125; from &#39;react-dom&#39;;\n\nasync function renderApp(req, res) &#123;\n  const app &#x3D; &lt;MyApp &#x2F;&gt;;\n  const root &#x3D; unstable_createRoot(document.createDocumentFragment());\n  await new Promise(resolve &#x3D;&gt; setTimeout(resolve, 1000)); &#x2F;&#x2F; 模拟数据加载延迟\n  root.render(app);\n  const html &#x3D; ReactDOMServer.renderToString(root);\n  res.send(html);\n&#125;</code></pre>\n\n<p>在上述代码中，我们使用了 <code>unstable_createRoot</code> 方法来创建一个 Concurrent Mode 的根节点。在数据加载完成后，我们渲染了应用程序，并将其输出为 HTML。</p>\n<p>这些是 React 18 中与 SSR 相关的一些功能和改进。通过使用这些功能，开发者可以更好地处理异步数据加载和渲染，并提升应用程序的响应性。</p>\n","feature":false,"text":" 前言目前react的最新版本是18.2.0。React 团队在 2022 年 3 月 29 日正式发布了 React 的第 18 个版本 是 React 框架的最新版本，它主要着眼于解决 React 应用在性能、稳定性、开发体验等方面的问题。本文将介绍 React 18 的升级...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"reacr","slug":"reacr","count":1,"path":"api/categories/reacr.json"}],"tags":[{"name":"react","slug":"react","count":1,"path":"api/tags/react.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8D%87%E7%BA%A7\"><span class=\"toc-text\">升级</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#react18-setState%E5%BC%82%E6%AD%A5%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">react18 setState异步同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%88%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">1.  异步更新（默认行为）：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BD%BF%E7%94%A8-flushSync%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">2.  同步更新（使用 flushSync）：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React18-%E6%96%B0%E5%A2%9EAPI\"><span class=\"toc-text\">React18 新增API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-startTransition\"><span class=\"toc-text\">1.  startTransition</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-useTransition\"><span class=\"toc-text\">2.  useTransition</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-createRoot\"><span class=\"toc-text\">3.  createRoot</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-useDeferredValue\"><span class=\"toc-text\">4.  useDeferredValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-useTransition\"><span class=\"toc-text\">5.  useTransition</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-useMutableSource\"><span class=\"toc-text\">6.  useMutableSource</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%96%B0%E5%A2%9EHooks\"><span class=\"toc-text\">新增Hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-useTransition\"><span class=\"toc-text\">1.  useTransition</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-useDeferredValue\"><span class=\"toc-text\">2.  useDeferredValue</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-useMutableSource\"><span class=\"toc-text\">3.  useMutableSource</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">严格模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">如何禁用严格模式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%9B%B4%E6%8E%A5%E7%A7%BB%E9%99%A4-lt-React-StrictMode-gt-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">1.  直接移除 &lt;React.StrictMode&gt; 组件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9C%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E6%97%B6%E7%A6%81%E7%94%A8%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.  在应用程序启动时禁用严格模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">并发模式</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">服务端渲染</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-useOpaqueIdentifier\"><span class=\"toc-text\">1.  useOpaqueIdentifier</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-ReactDOMServer-renderToStringAsync\"><span class=\"toc-text\">2.  ReactDOMServer.renderToStringAsync</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Concurrent-Mode\"><span class=\"toc-text\">3.  Concurrent Mode</span></a></li></ol></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"一遍就能读懂的WebSocket协议详解","uid":"f95adddbe06f4765087659d0718f1490","slug":"js/一遍就能读懂的WebSocket协议详解","date":"2023-04-04T13:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/一遍就能读懂的WebSocket协议详解.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/0.png","text":"什么是WebSocket协议概念用一句话解释一下: WebSocket协议是一种基于TCP的网络协议，用于在客户端和服务器之间建立持久连接，实现全双工通信,它允许服务器主动向客户端推送数据，同时也允许客户端向服务器发送数据。 WebSocket协议的特点1. 较低的开销： Web...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"网络","slug":"网络","count":2,"path":"api/categories/网络.json"},{"name":"TCP/IP","slug":"网络/TCP-IP","count":2,"path":"api/categories/网络/TCP-IP.json"},{"name":"HTTP","slug":"网络/TCP-IP/HTTP","count":2,"path":"api/categories/网络/TCP-IP/HTTP.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"VUE生命周期详解","uid":"b71e680387a5f2c0fe8c8eb63677ef1b","slug":"vue/vue生命周期详解","date":"2023-03-15T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/vue/vue生命周期详解.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/35.png","text":"VUE生命周期 大家好我是迁客，一个初入行的小白！痴迷技术，对programming有着极大的兴趣和爱好。每周写一篇自己个人成长的技术博客！既是对自己的一个学习技术的一个记录，也是督促自己，坚持下去！加油Fighting！==从明天起，做一个新思维的人继承，多态，层层封装从明天起...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"vue","slug":"vue","count":2,"path":"api/categories/vue.json"}],"tags":[{"name":"vue","slug":"vue","count":2,"path":"api/tags/vue.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}