{"title":"python多线程爬虫-下载wallhaven超清壁纸","uid":"4112198ee0b9e47478edd7a567ce5aa9","slug":"python/python多线程爬虫-下载wallhaven超清壁纸","date":"2023-04-12T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/python/python多线程爬虫-下载wallhaven超清壁纸.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/42.png","content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/762e1bfaf9d04c7e8a468a2ed7f5275e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"9-wallhaven-exwgw8.png\"></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>大家好我是前端少年汪！痴迷技术，对programming有着极大的兴趣和爱好。<br>从明天起，做一个新思维的人 继承，多态，层层封装 从明天起,不再关心内存管理 让每一条数据，自动放到合适的位子上 从明天起，我将为每一个对象 取一个温暖的名字 它们用驼峰命名，优雅，大方 陌生人，我也祝福你哈 愿你不再为系统级bug烦恼 愿你在平台之间肆意游荡 愿你不再关心溢出与异常</p></blockquote>\n<p>爬取的目标网站：<a href=\"https://wallhaven.cc/\">https://wallhaven.cc/</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08efb230169c4fbfb7f218b58c099b49~tplv-k3u1fbpfcp-watermark.image\" alt=\"image.png\"></p>\n<p>使用到的库：</p>\n<ul>\n<li>  requests</li>\n<li>  Xpath</li>\n</ul>\n<h2 id=\"分析目标网站的DOM结构\"><a href=\"#分析目标网站的DOM结构\" class=\"headerlink\" title=\"分析目标网站的DOM结构\"></a>分析目标网站的DOM结构</h2><p>我们可以看到这个网站总共分为六个大的模块：<strong>Latest，Hot，Toplist，Random，Upload，Forums</strong><br>我爬取的主要是latest，hot，toplist，random这四个模块的图片.<br>这四个模块对应的url网址分别为：</p>\n<ul>\n<li>  <a href=\"https://wallhaven.cc/latest\">https://wallhaven.cc/</a>latest</li>\n<li>  <a href=\"https://wallhaven.cc/latest\">https://wallhaven.cc/</a>hot</li>\n<li>  <a href=\"https://wallhaven.cc/latest\">https://wallhaven.cc/</a>toplist</li>\n<li>  <a href=\"https://wallhaven.cc/latest\">https://wallhaven.cc/</a>random</li>\n</ul>\n<p>图片的预览页面</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8503b5d9f1a46bc9119d10d68359484~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>这里可以看到page=2的页面总共🈶️24张图片，这个只是缩略图，点击单个item项就可以进入到图片的详情页，可以看到对应的图片的详情页面的url在section&gt;ul&gt;li&gt;figure&gt;a标签的href属性中。</p>\n<p>图片的详情页</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/194cf7b7fea446dea0cfe161b4126d64~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p>可以看到真正的图片的url是存在于img标签的src属性，只要我们拿到这个图片的地址就可以下载图片到本地了。</p>\n<h2 id=\"梳理一下逻辑：\"><a href=\"#梳理一下逻辑：\" class=\"headerlink\" title=\"梳理一下逻辑：\"></a>梳理一下逻辑：</h2><ol>\n<li> 请求latest，hot，toplist，random四个模块中的任意一个页面获取到缩略图的a标签里面的url，保存到一个列表里面</li>\n<li> 遍历缩略图列表，获取详情页img标签的src图片地址</li>\n<li> 请求图片地址，下载保存到本地</li>\n</ol>\n<p>大概的逻辑就是这么简单</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"导入相关包，定义全局变量\"><a href=\"#导入相关包，定义全局变量\" class=\"headerlink\" title=\"导入相关包，定义全局变量\"></a>导入相关包，定义全局变量</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import os\nimport threading\n\nimport requests\nfrom lxml import etree\n\n&quot;&quot;&quot;\n爬取网站：https:&#x2F;&#x2F;wallhaven.cc&#x2F;\n&quot;&quot;&quot;\n# 伪装浏览器请求\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36&#39;\n&#125;\n# 存放下载图片的文件夹名称\nnew_folder &#x3D; &#39;img&#39;\n# 5个模块对应的字符串列表\ntype_list &#x3D; [&#39;hot&#39;, &#39;toplist&#39;, &#39;latest&#39;, &#39;random&#39;]\n# 线程池\nthreads &#x3D; []</code></pre>\n\n<h4 id=\"获取缩略图页面\"><a href=\"#获取缩略图页面\" class=\"headerlink\" title=\"获取缩略图页面\"></a>获取缩略图页面</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 单页下载，只下载一页24张图片\ndef get_wall_one_page(type_index: int, page_num) -&gt; None:\n    # page_num爬取的页码\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], page_num)\n    print(url)\n    # 获取当前目录\n    current_dir &#x3D; os.getcwd()\n\n    # 新文件夹的名称\n    # new_folder &#x3D; &#39;img_&#123;&#125;&#39;.format(type_list[type_index])  # 创建新文件夹\n    if not os.path.exists(new_folder):\n        os.mkdir(os.path.join(current_dir, new_folder))\n\n    res &#x3D; requests.get(url, headers&#x3D;headers).text\n    selector &#x3D; etree.HTML(res)\n    img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n    # 调用获取详情页方法\n    detail_img(img_urls)</code></pre>\n\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93134b340e41465198ec38726153e6ca~tplv-k3u1fbpfcp-watermark.image#id=iImhK&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\"></p>\n<h4 id=\"获取图片详情页面\"><a href=\"#获取图片详情页面\" class=\"headerlink\" title=\"获取图片详情页面\"></a>获取图片详情页面</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def detail_img(img_urls):\n    &quot;&quot;&quot;\n    图片详情\n    :param img_urls:获取到单个图片item的详情url\n    :return:\n    &quot;&quot;&quot;\n    i &#x3D; 0\n\n    for item in img_urls:\n        son_res &#x3D; requests.get(item, headers&#x3D;headers).text\n        selector &#x3D; etree.HTML(son_res)\n        src_arr &#x3D; selector.xpath(&#39;&#x2F;&#x2F;img[@id&#x3D;\\&#39;wallpaper\\&#39;]&#x2F;@src&#39;)\n        # 使用多线程下载图片，调用下载方法\n        t &#x3D; threading.Thread(target&#x3D;download_img, args&#x3D;(src_arr[0], i))\n        t.start()\n        threads.append(t)\n        # download_img(src_arr[0], i)\n\n        i +&#x3D; 1\n        # 等待所有线程完成\n    for t in threads:\n        t.join()\n    print(&quot;当前页所有图片下载完成&quot;)</code></pre>\n\n<h4 id=\"下载图片\"><a href=\"#下载图片\" class=\"headerlink\" title=\"下载图片\"></a>下载图片</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">def download_img(img_src, i):\n    &quot;&quot;&quot;\n    图片下载\n    :param img_src: 图片的src\n    :param i: 序号\n    :return: void\n    &quot;&quot;&quot;\n    with open(&#39;.&#x2F;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&#39;.format(new_folder, i, img_src.split(&#39;&#x2F;&#39;)[-1]), &#39;wb&#39;) as f:\n        f.write(requests.get(img_src).content)\n    print(i, img_src)</code></pre>\n\n<p>以上就是爬取单页（一页24张图片的方法），观察url可以得知，通过改变page这个参数就可以不断爬取不同页码的图片了。可以有2种不同的思路：</p>\n<ol>\n<li> 爬取所有页，从1到total。有多少就爬多少</li>\n<li> 输入指定页码范围，爬取指定多少页</li>\n</ol>\n<p>如果是第一种的话，我们还需要获取到total总页码数。因为页码是懒加载的，鼠标滑动到底部才会请求加载下一页，这个时候才能看到总页码。<br>我想到了两种思路：</p>\n<ol>\n<li> 直接请求第二页。如果存在的话，就获取到总页码，如果不存在第二页说明这个只有一页，返回1。</li>\n<li> 使用selenium库，控制鼠标滑动页码到底部，加载下一页，然后获取总页码。</li>\n</ol>\n<p>我感觉两种方法都差不多，就用简单一点的第一种方法</p>\n<h4 id=\"获取总页码\"><a href=\"#获取总页码\" class=\"headerlink\" title=\"获取总页码\"></a>获取总页码</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">\ndef get_num(type_index):\n    &quot;&quot;&quot; 获取总页码\n    :param type_index:爬取的类型索引\n    :return:当前的页码数量\n    &quot;&quot;&quot;\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;2&#39;.format(type_list[type_index])\n    selector &#x3D; etree.HTML(requests.get(url, headers&#x3D;headers).text)\n    page_num &#x3D; selector.xpath(&#39;&#x2F;&#x2F;header[@class&#x3D;\\&#39;thumb-listing-page-header\\&#39;]&#x2F;h2&#x2F;&#x2F;text()&#39;)\n    return &#39;&#39;.join(page_num).split(&#39; &#39;)[-1]</code></pre>\n\n<h4 id=\"爬取指定类型，页码范围or爬取全部页\"><a href=\"#爬取指定类型，页码范围or爬取全部页\" class=\"headerlink\" title=\"爬取指定类型，页码范围or爬取全部页\"></a>爬取指定类型，页码范围or爬取全部页</h4><p>循环起始页到最后页，无非就是在爬取单页的基础上再多一层循环。<br>如果不传入开始页码和最后页码的话，那开始页码就是第一页，总页码就是当前页面最后页码</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">\ndef get_total(type_index, start, end):\n    &quot;&quot;&quot;\n    爬取指定类型，页码范围\n    :param type_index:\n    :param start:\n    :param end:\n    :return:\n    &quot;&quot;&quot;\n    # total &#x3D; int(get_num(type_index))\n    if end is None:\n    \tend &#x3D; total\n    if start is None:\n        start &#x3D; 1\n    try:\n        for i in range(start, end):\n            url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], i)\n            print(url, &#39;开始下载第&#123;&#125;&#x2F;&#123;&#125;页&#39;.format(i, end - 1))\n            res &#x3D; requests.get(url, headers&#x3D;headers).text\n            selector &#x3D; etree.HTML(res)\n            img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n            detail_img(img_urls)\n            # threading.Thread(target&#x3D;detail_img, args&#x3D;(img_urls)).start()\n    except Exception as e:\n        print(e)\n\n</code></pre>\n\n<p>这是获取到的图片结果</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60be1f474036411a9946a99c4acd854f~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h4 id=\"最后是所有代码\"><a href=\"#最后是所有代码\" class=\"headerlink\" title=\"最后是所有代码\"></a>最后是所有代码</h4><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">import os\nimport threading\n\nimport requests\nfrom lxml import etree\n\n&quot;&quot;&quot;\n爬取网站：https:&#x2F;&#x2F;wallhaven.cc&#x2F;\n&quot;&quot;&quot;\n# 伪装浏览器请求\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36&#39;\n&#125;\n# 存放下载图片的文件夹名称\nnew_folder &#x3D; &#39;img&#39;\n# 5个模块对应的字符串列表\ntype_list &#x3D; [&#39;hot&#39;, &#39;toplist&#39;, &#39;latest&#39;, &#39;random&#39;]\n# 线程池\nthreads &#x3D; []\n\n\n# 单页下载，只下载一页24张图片\ndef get_wall_one_page(type_index: int, page_num) -&gt; None:\n    # page_num爬取的页码\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], page_num)\n    print(url)\n    # 获取当前目录\n    current_dir &#x3D; os.getcwd()\n\n    # 新文件夹的名称\n    # new_folder &#x3D; &#39;img_&#123;&#125;&#39;.format(type_list[type_index])  # 创建新文件夹\n    if not os.path.exists(new_folder):\n        os.mkdir(os.path.join(current_dir, new_folder))\n\n    res &#x3D; requests.get(url, headers&#x3D;headers).text\n    selector &#x3D; etree.HTML(res)\n    img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n    detail_img(img_urls)\n\n\ndef detail_img(img_urls):\n    &quot;&quot;&quot;\n    图片详情\n    :param img_urls:获取到单个图片item的详情url\n    :return:\n    &quot;&quot;&quot;\n    i &#x3D; 0\n\n    for item in img_urls:\n        son_res &#x3D; requests.get(item, headers&#x3D;headers).text\n        selector &#x3D; etree.HTML(son_res)\n        src_arr &#x3D; selector.xpath(&#39;&#x2F;&#x2F;img[@id&#x3D;\\&#39;wallpaper\\&#39;]&#x2F;@src&#39;)\n        # 使用多线程下载图片\n        t &#x3D; threading.Thread(target&#x3D;download_img, args&#x3D;(src_arr[0], i))\n        t.start()\n        threads.append(t)\n        # download_img(src_arr[0], i)\n\n        i +&#x3D; 1\n        # 等待所有线程完成\n    for t in threads:\n        t.join()\n    print(&quot;当前页所有图片下载完成&quot;)\n\n\ndef download_img(img_src, i):\n    &quot;&quot;&quot;\n    图片下载\n    :param img_src: 图片的src\n    :param i: 序号\n    :return: void\n    &quot;&quot;&quot;\n    with open(&#39;.&#x2F;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&#39;.format(new_folder, i, img_src.split(&#39;&#x2F;&#39;)[-1]), &#39;wb&#39;) as f:\n        f.write(requests.get(img_src).content)\n    print(i, img_src)\n\n\ndef get_num(type_index):\n    &quot;&quot;&quot; 获取总页码\n    :param type_index:爬取的类型索引\n    :return:当前的页码数量\n    &quot;&quot;&quot;\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;2&#39;.format(type_list[type_index])\n    selector &#x3D; etree.HTML(requests.get(url, headers&#x3D;headers).text)\n    page_num &#x3D; selector.xpath(&#39;&#x2F;&#x2F;header[@class&#x3D;\\&#39;thumb-listing-page-header\\&#39;]&#x2F;h2&#x2F;&#x2F;text()&#39;)\n    return &#39;&#39;.join(page_num).split(&#39; &#39;)[-1]\n\n\ndef get_total(type_index, start, end):\n    &quot;&quot;&quot;\n    爬取指定类型，页码范围\n    :param type_index:\n    :param start:\n    :param end:\n    :return:\n    &quot;&quot;&quot;\n    # total &#x3D; int(get_num(type_index))\n    if end is None:\n    \tend &#x3D; total\n    if start is None:\n        start &#x3D; 1\n    try:\n        for i in range(start, end):\n            url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], i)\n            print(url, &#39;开始下载第&#123;&#125;&#x2F;&#123;&#125;页&#39;.format(i, end - 1))\n            res &#x3D; requests.get(url, headers&#x3D;headers).text\n            selector &#x3D; etree.HTML(res)\n            img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n            detail_img(img_urls)\n            # threading.Thread(target&#x3D;detail_img, args&#x3D;(img_urls)).start()\n    except Exception as e:\n        print(e)\n\n\n# https:&#x2F;&#x2F;wallhaven.cc&#x2F;search?q&#x3D;code&amp;page&#x3D;1\n# todo 根据输入关键词，查找下载\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;\n    0:&#39;hot&#39;, 热榜\n    1:&#39;toplist&#39;, top排名\n    2:&#39;latest&#39;, 最新\n    3:&#39;random&#39; 随机\n    4:&#39;search&#39; 关键字查找\n    &quot;&quot;&quot;\n    get_wall_one_page(1,1)  # 爬取单页\n    # get_total(2, 1, 11)  # 爬取多个指定页码\n</code></pre>\n\n<p>上面代码还有优化的空间，还可以加入关键词查询爬取，还有标签爬取，条件爬取等等，欢迎评论不同意见</p>\n<p>想要壁纸的也可以私信我发你！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cbeef7d5f534edfaa27f6d7da9df22e~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a296d571f77a40d0af9c0ed5a708e6ec~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"0-wallhaven-d6w2dj.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1405797418dc481892bfee79a2c1ac11~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"6-wallhaven-7prmdv.jpg\"></p>\n<p>喜欢我的小伙伴可以点一波关注。点个赞, 欢迎评论区留言讨论,看到会回复.</p>\n","feature":false,"text":" 大家好我是前端少年汪！痴迷技术，对programming有着极大的兴趣和爱好。从明天起，做一个新思维的人 继承，多态，层层封装 从明天起,不再关心内存管理 让每一条数据，自动放到合适的位子上 从明天起，我将为每一个对象 取一个温暖的名字 它们用驼峰命名，优雅，大方 陌生人，我也...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"python","slug":"python","count":2,"path":"api/categories/python.json"}],"tags":[{"name":"爬虫","slug":"爬虫","count":2,"path":"api/tags/爬虫.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E7%9B%AE%E6%A0%87%E7%BD%91%E7%AB%99%E7%9A%84DOM%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">分析目标网站的DOM结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8B%E9%80%BB%E8%BE%91%EF%BC%9A\"><span class=\"toc-text\">梳理一下逻辑：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E7%9B%B8%E5%85%B3%E5%8C%85%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">导入相关包，定义全局变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E7%BC%A9%E7%95%A5%E5%9B%BE%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">获取缩略图页面</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87%E8%AF%A6%E6%83%85%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">获取图片详情页面</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">下载图片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%8F%96%E6%80%BB%E9%A1%B5%E7%A0%81\"><span class=\"toc-text\">获取总页码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%88%AC%E5%8F%96%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%EF%BC%8C%E9%A1%B5%E7%A0%81%E8%8C%83%E5%9B%B4or%E7%88%AC%E5%8F%96%E5%85%A8%E9%83%A8%E9%A1%B5\"><span class=\"toc-text\">爬取指定类型，页码范围or爬取全部页</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E%E6%98%AF%E6%89%80%E6%9C%89%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">最后是所有代码</span></a></li></ol></li></ol></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"vite使用入门","uid":"89c83197a75c1245116b0a9c7aba1d2b","slug":"vue/vite3使用指南,小白再也不用担心项目配置问题了","date":"2023-04-13T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/vue/vite3使用指南,小白再也不用担心项目配置问题了.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/43.png","text":"为开发提供极速响应v4.1.0 目前Vite已经更新到v4.1.0的版本了 vite的特性 💡极速的服务启动，意思就是一个字快 ⚡️轻量快速的热重载，就是说热更新也很快 🔧丰富的功能，支持的工具集比较多，开箱即用 📦优化的构建 对于生产环境的构建有更好的优化 🔩通用的插件，在开发和...","link":"","photos":[],"count_time":{"symbolsCount":"6.6k","symbolsTime":"6 mins."},"categories":[{"name":"vite","slug":"vite","count":1,"path":"api/categories/vite.json"}],"tags":[{"name":"vite","slug":"vite","count":1,"path":"api/tags/vite.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"一遍就能读懂的WebSocket协议详解","uid":"f95adddbe06f4765087659d0718f1490","slug":"js/一遍就能读懂的WebSocket协议详解","date":"2023-04-04T13:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/一遍就能读懂的WebSocket协议详解.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/0.png","text":"什么是WebSocket协议概念用一句话解释一下: WebSocket协议是一种基于TCP的网络协议，用于在客户端和服务器之间建立持久连接，实现全双工通信,它允许服务器主动向客户端推送数据，同时也允许客户端向服务器发送数据。 WebSocket协议的特点1. 较低的开销： Web...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"网络","slug":"网络","count":2,"path":"api/categories/网络.json"},{"name":"TCP/IP","slug":"网络/TCP-IP","count":2,"path":"api/categories/网络/TCP-IP.json"},{"name":"HTTP","slug":"网络/TCP-IP/HTTP","count":2,"path":"api/categories/网络/TCP-IP/HTTP.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}