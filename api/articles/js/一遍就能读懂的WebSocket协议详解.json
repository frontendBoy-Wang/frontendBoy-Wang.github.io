{"title":"一遍就能读懂的WebSocket协议详解","uid":"f95adddbe06f4765087659d0718f1490","slug":"js/一遍就能读懂的WebSocket协议详解","date":"2023-04-04T13:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/一遍就能读懂的WebSocket协议详解.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/0.png","content":"<h1 id=\"什么是WebSocket协议\"><a href=\"#什么是WebSocket协议\" class=\"headerlink\" title=\"什么是WebSocket协议\"></a>什么是WebSocket协议</h1><h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>用一句话解释一下:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>WebSocket协议是一种基于TCP的网络协议，用于在客户端和服务器之间建立持久连接，实现全双工通信,它允许服务器主动向客户端推送数据，同时也允许客户端向服务器发送数据。</p></blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea308c0eba2a41a98ade6b1b54afb709~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3840&h=3072&s=8764720&e=png&b=8d9eb7\" alt=\"wallhaven-z8dg9y_3840x3072.png\"></p>\n<h2 id=\"WebSocket协议的特点\"><a href=\"#WebSocket协议的特点\" class=\"headerlink\" title=\"WebSocket协议的特点\"></a>WebSocket协议的特点</h2><h3 id=\"1-较低的开销：\"><a href=\"#1-较低的开销：\" class=\"headerlink\" title=\"1.  较低的开销：\"></a>1.  较低的开销：</h3><p> WebSocket使用更少的头部信息和保持连接的机制，减少了数据传输的开销。</p>\n<h3 id=\"2-实时性：\"><a href=\"#2-实时性：\" class=\"headerlink\" title=\"2.  实时性：\"></a>2.  实时性：</h3><p>WebSocket提供了实时的、双向的通信机制，可以立即将数据从服务器推送到客户端，实现即时更新。</p>\n<h3 id=\"3-更好的性能：\"><a href=\"#3-更好的性能：\" class=\"headerlink\" title=\"3.  更好的性能：\"></a>3.  更好的性能：</h3><p>WebSocket通过减少每次连接的握手次数和数据包的开销，提高了通信的效率和性能。</p>\n<h3 id=\"4-跨域支持：\"><a href=\"#4-跨域支持：\" class=\"headerlink\" title=\"4.  跨域支持：\"></a>4.  跨域支持：</h3><p>WebSocket协议可以跨域使用，允许不同源的客户端与服务器进行通信。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53b82c571d1f4aba98a059efdd666990~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1080&s=186187&e=png&b=1e222a\" alt=\"image (1).png\"></p>\n<h1 id=\"WebSocket和Http协议的异同\"><a href=\"#WebSocket和Http协议的异同\" class=\"headerlink\" title=\"WebSocket和Http协议的异同\"></a>WebSocket和Http协议的异同</h1><ol>\n<li> 连接方式不同：<br>HTTP协议采用请求-响应模式，每次请求需要建立一个新的连接；而WebSocket协议通过一次握手后，建立起持久连接，可以实现双向通信。</li>\n<li> 支持的数据类型不同：<br>HTTP协议只能传输文本和二进制数据，而WebSocket协议支持传输任意类型的数据。</li>\n<li> 头部信息不同：<br>HTTP协议的头部信息较多，包含请求方法、请求头等；WebSocket协议的头部信息相对简洁，只包含必要的信息。</li>\n<li> 状态码不同：<br>HTTP协议有大量的状态码，表示服务器处理请求的结果；WebSocket协议仅有几个状态码，主要用于表示连接状态和关闭原因。</li>\n<li> 安全性不同：<br>HTTP协议的通信是明文的，容易被窃听和篡改；WebSocket协议可以使用SSL/TLS协议进行加密，提高了通信的安全性。</li>\n<li>  数据帧格式不同：<br>WebSocket协议的数据帧格式与HTTP协议的数据包格式不同。WebSocket协议的每个数据帧都包含一个头部和数据部分，头部包含标识数据类型、数据长度等信息；而HTTP协议的请求和响应数据包则包含请求行、请求头和请求体等部分。</li>\n<li> 通信方式不同：<br>HTTP协议是一种请求-响应式的协议，客户端发送请求，服务器返回响应；而WebSocket协议是一种全双工通信协议，客户端和服务器可以同时发送和接收数据。</li>\n<li> 适用场景不同：<br>HTTP协议主要用于浏览器与Web服务器之间的通信，常用于请求Web页面、图片、音频、视频等资源；而WebSocket协议主要用于实现实时通信、在线游戏、远程控制等场景。</li>\n<li> 跨域支持不同：<br>在跨域访问方面，HTTP协议需要使用JSONP、CORS等机制来进行跨域操作；而WebSocket协议可以直接跨域使用，不需要额外的跨域处理。</li>\n</ol>\n<h1 id=\"websocket是如何和服务端进行连接的\"><a href=\"#websocket是如何和服务端进行连接的\" class=\"headerlink\" title=\"websocket是如何和服务端进行连接的\"></a>websocket是如何和服务端进行连接的</h1><ol>\n<li> 客户端发送 HTTP 请求建立连接：客户端通过发送一个 HTTP 请求给服务器来建立 WebSocket 连接。请求头中包含了一些特殊的字段，如 Upgrade 和 Connection 字段，告诉服务器它希望升级到 WebSocket 连接。</li>\n<li> 服务器响应握手请求：服务器收到客户端发送的握手请求后，会进行相应的处理并返回一个 HTTP 响应。响应头中同样包含了一些特殊的字段，如 Upgrade 和 Connection 字段，以及一个 Sec-WebSocket-Accept 字段，用于验证请求的合法性。</li>\n<li> WebSocket 连接建立成功：客户端收到服务器返回的响应后，会验证响应的合法性。如果验证通过，表示 WebSocket 连接已经成功建立。</li>\n<li> 双向通信：一旦 WebSocket 连接建立成功，客户端和服务器就可以通过该连接进行双向通信了。客户端可以发送消息给服务器，服务器也可以发送消息给客户端，实现真正的双向通信。</li>\n<li> 连接关闭：当客户端或服务器决定关闭连接时，可以发送一个特殊的消息，通知对方关闭连接。双方收到关闭消息后，会相应地关闭连接。</li>\n</ol>\n<p>需要注意的是，WebSocket 是一种持久化的协议，一旦连接建立成功，它会保持长时间的连接状态，不会像传统的 HTTP 请求那样频繁地建立和关闭连接。这种长连接的特性使得 WebSocket 协议在实时通信场景下具有较好的性能优势。</p>\n<h1 id=\"WebSocket协议详解\"><a href=\"#WebSocket协议详解\" class=\"headerlink\" title=\"WebSocket协议详解\"></a>WebSocket协议详解</h1><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>我们可以使用websocket的构造函数来创建一个websocket对象<br><strong><code>WebSocket()</code></strong> 构造函器会返回一个 [<code>WebSocket</code>] 对象。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let ws &#x3D;new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;)</code></pre>\n<p>WebSocket()参数:</p>\n<ul>\n<li>url:要连接的 URL；这应该是 WebSocket 服务器将响应的 URL。</li>\n<li> <code>protocols</code> 可选: 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议（例如，你可能希望一台服务器能够根据指定的协议（<code>protocol</code>）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ba8fba53cc4b22b1138b98b252333a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1024&h=395&s=39604&e=png&b=2b2a2a\" alt=\"image.png\"></p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><table>\n<thead>\n<tr>\n<th><code>WebSocket.CONNECTING</code></th>\n<th><code>0</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>WebSocket.OPEN</code></td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td><code>WebSocket.CLOSING</code></td>\n<td><code>2</code></td>\n</tr>\n<tr>\n<td><code>WebSocket.CLOSED</code></td>\n<td><code>3</code></td>\n</tr>\n</tbody></table>\n<p>主要表示websocket生命周期的状态码</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>点击Websocket的原型展开就可以看到websocket的所有属性和方法了</p>\n<ul>\n<li>  [<code>WebSocket.binaryType</code>]  使用二进制的数据类型连接。</li>\n<li>  [<code>WebSocket.bufferedAmount</code>]  只读:未发送至服务器的字节数。</li>\n<li>[<code>WebSocket.extensions</code>]  只读:服务器选择的扩展   </li>\n<li>[<code>WebSocket.onclose</code>] 用于指定连接关闭后的回调函数。</li>\n<li>  [<code>WebSocket.onerror</code>]  用于指定连接失败后的回调函数。</li>\n<li>  [<code>WebSocket.onmessage</code>]  用于指定当从服务器接收到信息时的回调函数。</li>\n<li>  [<code>WebSocket.onopen</code>]  用于指定连接成功后的回调函数。</li>\n<li>  [<code>WebSocket.protocol</code>] 只读:服务器选择的下属协议。</li>\n<li>  [<code>WebSocket.readyState</code>] 只读:当前的链接状态。</li>\n<li>  [<code>WebSocket.url</code>]  只读:WebSocket 的绝对路径。</li>\n</ul>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>websocket主要有两个方法:</p>\n<ul>\n<li><p>close:关闭当前链接 <code>WebSocket.close();</code> </p>\n<ul>\n<li> [<code>code</code>] 可选: 一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用 1005。[<code>CloseEvent</code>] 的允许的状态码见<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CloseEvent#status_codes\">状态码列表</a> 。</li>\n<li>[<code>reason</code>] 可选:一个人类可读的字符串，它解释了连接关闭的原因。这个 UTF-8 编码的字符串不能超过 123 个字节。</li>\n</ul>\n</li>\n<li><p>send: <strong><code>WebSocket.send()</code></strong>  方法将需要通过 WebSocket 链接传输至服务器的数据排入队列，并根据所需要传输的 data bytes 的大小来增加 <code>bufferedAmount</code>的值。若数据无法传输（例如数据需要缓存而缓冲区已满）时，套接字会自行关闭。</p>\n<ul>\n<li><p>参数data:用于传输至服务器的数据。它必须是以下类型之一：</p>\n<ul>\n<li><p>[<code>USVString</code>] :文本字符串。字符串将以 UTF-8 格式添加到缓冲区，并且 <code>bufferedAmount</code> 将加上该字符串以 UTF-8 格式编码时的字节数的值。</p>\n</li>\n<li><p>[<code>ArrayBuffer</code>]   你可以使用一有类型的数组对象发送底层二进制数据；其二进制数据内存将被缓存于缓冲区，<code>bufferedAmount</code> 将加上所需字节数的值。</p>\n</li>\n<li><p>  [<code>Blob</code>]   <code>Blob</code> 类型将队列 blob 中的原始数据以二进制中传输。 <code>bufferedAmount</code> 将加上原始数据的字节数的值。</p>\n</li>\n<li><p>  [<code>ArrayBufferView</code>]  你可以以二进制帧的形式发送任何 JavaScript 类数组对象 其二进制数据内容将被队列于缓冲区中。值 <code>bufferedAmount</code> 将加上必要字节数的值。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><p>如上面所讲,websocket有一些方法在连接的过程中自动触发<br>使用 <code>addEventListener()</code> 或将一个事件监听器赋值给本接口的 <code>oneventname</code> 属性，来监听下面的事件。</p>\n<ul>\n<li><p>  [<code>close</code>] 当一个 <code>WebSocket</code> 连接被关闭时触发。 也可以通过 [<code>onclose</code>]  属性来设置。</p>\n</li>\n<li><p>  [<code>error</code>] 当一个 <code>WebSocket</code> 连接因错误而关闭时触发，例如无法发送数据时。 也可以通过 [<code>onerror</code>]  属性来设置。</p>\n</li>\n<li><p>  [<code>message</code>] 当通过 <code>WebSocket</code> 收到数据时触发。 也可以通过 [<code>onmessage</code>] 属性来设置。</p>\n</li>\n<li><p>  [<code>open</code>] 当一个 <code>WebSocket</code> 连接成功时触发。 也可以通过 [<code>onopen</code>] 属性来设置。</p>\n</li>\n</ul>\n<h1 id=\"如何使用Websocket协议\"><a href=\"#如何使用Websocket协议\" class=\"headerlink\" title=\"如何使用Websocket协议\"></a>如何使用Websocket协议</h1><ul>\n<li><p>创建websocket对象</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9090&quot;);</code></pre></li>\n<li><p>调用open方法</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">ws.onopen &#x3D; function () &#123;\n    console.log(&quot;链接成功&quot;);\n    \n&#125;;</code></pre></li>\n<li><p>调用onmessage,接收数据</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">ws.onmessage &#x3D; function (data) &#123;\n    console.log(&#39;接受服务端数据&#39;, data)\n        ws.send(&#39;hello world&#39;)\n\n&#125;;</code></pre></li>\n<li><p>调用send方法,向服务端发送数据<br><code> ws.send(&#39;hello world&#39;)</code></p>\n</li>\n<li><p>在断开连接的方法中处理错误或者重连</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">ws.onclose &#x3D; function (e) &#123;\n    console.log(&#39;连接已经关闭&#39;)\n&#125;\nws.onerror &#x3D; function (e) &#123;\n    console.log(&#39;连接发生错误&#39;)\n&#125;</code></pre></li>\n</ul>\n<h1 id=\"自己动手封装WebSocket的常用方法功能\"><a href=\"#自己动手封装WebSocket的常用方法功能\" class=\"headerlink\" title=\"自己动手封装WebSocket的常用方法功能\"></a>自己动手封装WebSocket的常用方法功能</h1><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">export default class WebSocketClient &#123;\n    &#x2F;**\n     * 创建一个WebSocket客户端对象。\n     *\n     * @param &#123;string&#125; url - WebSocket服务器的URL。\n     *&#x2F;\n    constructor(url) &#123;\n        this.url &#x3D; url; &#x2F;&#x2F; 保存WebSocket服务器的URL\n        this.websocket &#x3D; null; &#x2F;&#x2F; WebSocket连接对象\n        this.reconnectAttempts &#x3D; 0; &#x2F;&#x2F; 重连尝试次数\n        this.maxReconnectAttempts &#x3D; 10; &#x2F;&#x2F; 最大重连次数\n        this.messageHandlers &#x3D; &#123;&#125;; &#x2F;&#x2F; 消息处理器\n        this.eventHandlers &#x3D; &#123;&#125;; &#x2F;&#x2F; 事件处理器\n        this.timeoutIds &#x3D; &#123;&#125;; &#x2F;&#x2F; 超时定时器ID\n    &#125;\n\n    &#x2F;**\n     * 连接WebSocket服务器。\n     *&#x2F;\n    connect(type, data) &#123;\n        this.websocket &#x3D; new WebSocket(this.url); &#x2F;&#x2F; 创建WebSocket连接\n        this.websocket.binaryType &#x3D; &#39;arraybuffer&#39;; &#x2F;&#x2F; 设置二进制数据类型为ArrayBuffer\n        this.websocket.onopen &#x3D; () &#x3D;&gt; &#123;\n            console.log(&#39;Websocket connection established.&#39;); &#x2F;&#x2F; WebSocket连接建立成功\n            this.reconnectAttempts &#x3D; 0; &#x2F;&#x2F; 重连尝试次数重置\n            this.dispatchEvent(&#39;open&#39;, data); &#x2F;&#x2F; 分发打开事件\n        &#125;;\n        this.websocket.onmessage &#x3D; event &#x3D;&gt; &#123;\n            const message &#x3D; event.data instanceof ArrayBuffer ? event.data : JSON.parse(event.data); &#x2F;&#x2F; 解析收到的消息\n            if (message.id &amp;&amp; this.timeoutIds[message.id]) &#123; &#x2F;&#x2F; 收到响应消息时清除超时定时器\n                clearTimeout(this.timeoutIds[message.id]);\n                delete this.timeoutIds[message.id];\n            &#125;\n            if (message.type &amp;&amp; this.messageHandlers[message.type]) &#123;\n                for (let handler of this.messageHandlers[message.type]) &#123;\n                    handler(message); &#x2F;&#x2F; 处理收到的消息\n                &#125;\n            &#125;\n            this.dispatchEvent(&#39;message&#39;, message); &#x2F;&#x2F; 分发消息事件\n        &#125;;\n        this.websocket.onerror &#x3D; error &#x3D;&gt; &#123;\n            console.error(&#39;Websocket error:&#39;, error); &#x2F;&#x2F; WebSocket错误处理\n            this.dispatchEvent(&#39;error&#39;, error); &#x2F;&#x2F; 分发错误事件\n        &#125;;\n        this.websocket.onclose &#x3D; (type, data) &#x3D;&gt; &#123;\n            console.log(&#39;Websocket connection closed.&#39;); &#x2F;&#x2F; WebSocket连接关闭\n            if (this.reconnectAttempts &lt; this.maxReconnectAttempts) &#123;\n                setTimeout(() &#x3D;&gt; &#123;\n                    this.connect(); &#x2F;&#x2F; 重新连接\n                    this.reconnectAttempts++;\n                &#125;, 2000);\n            &#125; else &#123;\n                console.error(&#96;Websocket connection failed after $&#123;this.maxReconnectAttempts&#125; attempts.&#96;); &#x2F;&#x2F; 达到最大重连次数后仍未成功连接\n                this.dispatchEvent(&#39;close&#39;, data); &#x2F;&#x2F; 分发关闭事件\n            &#125;\n        &#125;;\n    &#125;\n\n    &#x2F;**\n     * 发送一个WebSocket消息。\n     *\n     * @param &#123;object|ArrayBuffer&#125; message - 要发送的消息，可以是JavaScript对象或ArrayBuffer。\n     * @param &#123;number&#125; timeout - 超时时间（毫秒），如果在指定时间内没有收到响应，则调用超时处理函数。\n     * @param &#123;function&#125; timeoutHandler - 超时处理函数，接收一个参数：要发送的消息对象。\n     *&#x2F;\n    send(message, timeout, timeoutHandler) &#123;\n        if (this.websocket.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) &#123;\n            if (message instanceof ArrayBuffer) &#123;\n                this.websocket.send(message); &#x2F;&#x2F; 发送二进制消息\n            &#125; else &#123;\n                const messageId &#x3D; Math.random().toString(36).substr(2, 8); &#x2F;&#x2F; 生成随机消息ID\n                const messageWithId &#x3D; Object.assign(&#123;&#125;, message, &#123;id: messageId&#125;); &#x2F;&#x2F; 添加消息ID字段\n                const data &#x3D; JSON.stringify(messageWithId); &#x2F;&#x2F; 将消息对象转换为JSON字符串\n                this.websocket.send(data); &#x2F;&#x2F; 发送消息\n                if (timeout) &#123;\n                    this.timeoutIds[messageId] &#x3D; setTimeout(() &#x3D;&gt; &#123;\n                        console.warn(&#96;WebSocket request $&#123;messageId&#125; timed out.&#96;); &#x2F;&#x2F; 超时警告\n                        delete this.timeoutIds[messageId]; &#x2F;&#x2F; 清除超时定时器ID\n                        timeoutHandler &amp;&amp; timeoutHandler(message); &#x2F;&#x2F; 调用超时处理函数\n                    &#125;, timeout);\n                &#125;\n            &#125;\n        &#125; else &#123;\n            console.error(&#39;Websocket connection not open, message not sent:&#39;, message); &#x2F;&#x2F; WebSocket连接未打开时无法发送消息\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 添加一个WebSocket消息处理器。\n     *\n     * @param &#123;string&#125; type - 消息类型。\n     * @param &#123;function&#125; handler - 处理函数，接收一个参数：消息对象或ArrayBuffer。\n     *&#x2F;\n    addMessageHandler(type, handler) &#123;\n        if (!this.messageHandlers[type]) &#123;\n            this.messageHandlers[type] &#x3D; []; &#x2F;&#x2F; 若不存在该类型的消息处理器，则初始化为空数组\n        &#125;\n        this.messageHandlers[type].push(handler); &#x2F;&#x2F; 添加消息处理函数\n    &#125;\n\n    &#x2F;**\n     * 移除一个WebSocket消息处理器。\n     *\n     * @param &#123;string&#125; type - 消息类型。\n     * @param &#123;function&#125; handler - 处理函数。\n     *&#x2F;\n    removeMessageHandler(type, handler) &#123;\n        if (this.messageHandlers[type]) &#123;\n            const index &#x3D; this.messageHandlers[type].indexOf(handler); &#x2F;&#x2F; 查找处理函数在数组中的索引\n            if (index !&#x3D;&#x3D; -1) &#123;\n                this.messageHandlers[type].splice(index, 1); &#x2F;&#x2F; 移除处理函数\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 添加一个WebSocket事件处理器。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;function&#125; handler - 处理函数，接收一个参数：事件数据。\n     *&#x2F;\n    addEventHandler(type, handler) &#123;\n        if (!this.eventHandlers[type]) &#123;\n            this.eventHandlers[type] &#x3D; []; &#x2F;&#x2F; 若不存在该类型的事件处理器，则初始化为空数组\n        &#125;\n        this.eventHandlers[type].push(handler); &#x2F;&#x2F; 添加事件处理函数\n    &#125;\n\n    &#x2F;**\n     * 移除一个WebSocket事件处理器。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;function&#125; handler - 处理函数。\n     *&#x2F;\n    removeEventHandler(type, handler) &#123;\n        if (this.eventHandlers[type]) &#123;\n            const index &#x3D; this.eventHandlers[type].indexOf(handler); &#x2F;&#x2F; 查找处理函数在数组中的索引\n            if (index !&#x3D;&#x3D; -1) &#123;\n                this.eventHandlers[type].splice(index, 1); &#x2F;&#x2F; 移除处理函数\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 分发 WebSocket 事件。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;any&#125; data - 事件数据。\n     *&#x2F;\n    dispatchEvent(type, data) &#123;\n        if (this.eventHandlers[type]) &#123;\n            for (let handler of this.eventHandlers[type]) &#123;\n                handler(data); &#x2F;&#x2F; 调用事件处理函数\n            &#125;\n        &#125;\n    &#125;\n    \n&#x2F;**\n * 发送心跳消息。\n *&#x2F;\nsendHeartbeat() &#123;\n    const message &#x3D; &#123; type: &#39;heartbeat&#39; &#125;; &#x2F;&#x2F; 心跳消息内容\n    const intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;\n        this.send(message,5,(e)&#x3D;&gt;&#123;\n            console.log(e)&#125;); &#x2F;&#x2F; 发送心跳消息\n    &#125;, 1000);\n    this.addEventHandler(&#39;close&#39;, () &#x3D;&gt; &#123;\n        clearInterval(intervalId); &#x2F;&#x2F; 关闭 WebSocket 连接时清除定时器\n    &#125;);\n&#125;\n \n&#125;\n </code></pre>\n<p>我封装的是一个基于原生 JavaScript 的 WebSocket 客户端类的实现。这个类提供了一些方法和事件处理器，可以用于连接 WebSocket 服务器、发送消息、处理接收到的消息和处理 WebSocket 相关的事件。</p>\n<p>在这段代码中，WebSocketClient 类有以下主要成员：</p>\n<ul>\n<li>  constructor(url)：构造函数，接收 WebSocket 服务器的 URL，并初始化一些属性，如 WebSocket 连接对象、重连尝试次数等。</li>\n<li>  connect(type, data)：连接 WebSocket 服务器的方法，内部创建 WebSocket 连接，并设置连接建立、消息接收、错误和关闭等事件的处理函数。在连接关闭后，会根据重连尝试次数进行重连。</li>\n<li>  send(message, timeout, timeoutHandler)：发送 WebSocket 消息的方法，可以发送 JavaScript 对象或 ArrayBuffer 类型的消息，并支持设置超时时间和超时处理函数。</li>\n<li>  addMessageHandler(type, handler) 和 removeMessageHandler(type, handler)：添加和移除消息处理器的方法，用于处理特定类型的消息。</li>\n<li>  addEventHandler(type, handler) 和 removeEventHandler(type, handler)：添加和移除事件处理器的方法，用于处理特定类型的事件。</li>\n<li>  dispatchEvent(type, data)：分发 WebSocket 事件的方法，用于触发相应类型的事件处理器。</li>\n</ul>\n<p> 这个类封装了 WebSocket 的连接、消息发送和事件处理的逻辑，使得使用者可以更方便地操作 WebSocket 连接，并且支持自定义消息处理和事件处理逻辑。</p>\n<h1 id=\"有哪些好用的客户端WebSocket第三方库\"><a href=\"#有哪些好用的客户端WebSocket第三方库\" class=\"headerlink\" title=\"有哪些好用的客户端WebSocket第三方库\"></a>有哪些好用的客户端WebSocket第三方库</h1><ol>\n<li> <strong>Socket.io-client</strong>：<a href=\"http://socket.io/\">Socket.io</a> 是一个流行的实时通信库，它提供了客户端 JavaScript 库，可用于在浏览器中与 <a href=\"http://socket.io/\">Socket.io</a> 服务器建立 WebSocket 连接。它支持自动重连、事件处理等功能，用于构建实时应用非常方便。</li>\n<li> <strong>ReconnectingWebSocket</strong>：ReconnectingWebSocket 是一个带有自动重连功能的 WebSocket 客户端库，可以很好地处理网络连接断开和重新连接的情况，适合用于浏览器端的 WebSocket 开发。</li>\n<li> <strong>SockJS-client</strong>：SockJS 提供了一个浏览器端的 JavaScript 客户端库，用于与 SockJS 服务器建立连接。它可以在不支持 WebSocket 的浏览器上自动降级到其他传输方式，具有良好的兼容性。</li>\n<li> <strong>RxJS WebSocketSubject</strong>：RxJS 是一个流式编程库，它提供了 WebSocketSubject 类，可以将 WebSocket 转换为可观察对象，方便进行响应式编程。</li>\n<li> <strong>autobahn.js</strong>：autobahn.js 是一个用于实现 WebSocket 和 WAMP（Web Application Messaging Protocol）的客户端库，在浏览器中可以方便地使用它来与 WAMP 路由进行通信。</li>\n</ol>\n<p>这些库都提供了良好的接口封装和功能特性，可以根据项目需求选择适合的库来进行浏览器端的 WebSocket 开发。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>WebSocket 协议是一种基于 TCP 的应用层协议，它提供了在客户端和服务器之间进行双向通信的能力。相比传统的 HTTP 协议，它具有更低的延迟和更高的实时性。</p>\n<p>WebSocket 协议通过建立一条持久化的连接来实现双向通信，从而避免了 HTTP 协议中频繁建立和断开连接的过程，减少了网络开销和服务器的负担。客户端可以发送消息给服务器，服务器也可以发送消息给客户端，实现了真正的双向通信。</p>\n<p>在使用 WebSocket 协议时，客户端和服务器会进行一次握手过程，以建立起 WebSocket 连接。握手过程中，客户端会发送一个 HTTP 请求，请求头中包含 Upgrade 和 Connection 字段，告诉服务器它希望升级到 WebSocket 连接。服务器收到请求后会返回一个 HTTP 响应，响应头中包含 Upgrade 和 Connection 字段，以及一个 Sec-WebSocket-Accept 字段，用于验证请求的合法性。握手成功后，客户端和服务器就可以开始使用 WebSocket 协议进行通信了。</p>\n<p>WebSocket 协议支持二进制数据和文本数据的传输，开发者可以根据实际需求进行选择。同时，WebSocket 还提供了心跳机制、自动重连等功能，可以提高连接的稳定性和可靠性。</p>\n<p>总之，WebSocket 协议在实时通信、游戏、在线聊天等场景中得到了广泛应用，它为 Web 应用提供了更加高效、可靠的双向通信方式。</p>\n","feature":false,"text":"什么是WebSocket协议概念用一句话解释一下: WebSocket协议是一种基于TCP的网络协议，用于在客户端和服务器之间建立持久连接，实现全双工通信,它允许服务器主动向客户端推送数据，同时也允许客户端向服务器发送数据。 WebSocket协议的特点1. 较低的开销： Web...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"网络","slug":"网络","count":2,"path":"api/categories/网络.json"},{"name":"TCP/IP","slug":"网络/TCP-IP","count":2,"path":"api/categories/网络/TCP-IP.json"},{"name":"HTTP","slug":"网络/TCP-IP/HTTP","count":2,"path":"api/categories/网络/TCP-IP/HTTP.json"}],"tags":[{"name":"网络协议","slug":"网络协议","count":2,"path":"api/tags/网络协议.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFWebSocket%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">什么是WebSocket协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WebSocket%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">WebSocket协议的特点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BE%83%E4%BD%8E%E7%9A%84%E5%BC%80%E9%94%80%EF%BC%9A\"><span class=\"toc-text\">1.  较低的开销：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E6%97%B6%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">2.  实时性：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9A\"><span class=\"toc-text\">3.  更好的性能：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E8%B7%A8%E5%9F%9F%E6%94%AF%E6%8C%81%EF%BC%9A\"><span class=\"toc-text\">4.  跨域支持：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#WebSocket%E5%92%8CHttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">WebSocket和Http协议的异同</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#websocket%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E7%9A%84\"><span class=\"toc-text\">websocket是如何和服务端进行连接的</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#WebSocket%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">WebSocket协议详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">构造函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F\"><span class=\"toc-text\">常量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">事件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Websocket%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">如何使用Websocket协议</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%B0%81%E8%A3%85WebSocket%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">自己动手封装WebSocket的常用方法功能</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AFWebSocket%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93\"><span class=\"toc-text\">有哪些好用的客户端WebSocket第三方库</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"python多线程爬虫-下载wallhaven超清壁纸","uid":"4112198ee0b9e47478edd7a567ce5aa9","slug":"python/python多线程爬虫-下载wallhaven超清壁纸","date":"2023-04-12T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/python/python多线程爬虫-下载wallhaven超清壁纸.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/42.png","text":" 大家好我是前端少年汪！痴迷技术，对programming有着极大的兴趣和爱好。从明天起，做一个新思维的人 继承，多态，层层封装 从明天起,不再关心内存管理 让每一条数据，自动放到合适的位子上 从明天起，我将为每一个对象 取一个温暖的名字 它们用驼峰命名，优雅，大方 陌生人，我也...","link":"","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[{"name":"python","slug":"python","count":2,"path":"api/categories/python.json"}],"tags":[{"name":"爬虫","slug":"爬虫","count":2,"path":"api/tags/爬虫.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"react18新特性","uid":"353ce1343760f6de753e88dbaf24c997","slug":"react/听说你还不知道React18新特性？看我给你整明白！","date":"2023-03-17T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/react/听说你还不知道React18新特性？看我给你整明白！.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/37.png","text":" 前言目前react的最新版本是18.2.0。React 团队在 2022 年 3 月 29 日正式发布了 React 的第 18 个版本 是 React 框架的最新版本，它主要着眼于解决 React 应用在性能、稳定性、开发体验等方面的问题。本文将介绍 React 18 的升级...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"reacr","slug":"reacr","count":1,"path":"api/categories/reacr.json"}],"tags":[{"name":"react","slug":"react","count":1,"path":"api/tags/react.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}