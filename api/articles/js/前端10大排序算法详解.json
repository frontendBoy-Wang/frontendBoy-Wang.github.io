{"title":"前端10大排序算法详解","uid":"85ace94f5f65156ab225562196d7492a","slug":"js/前端10大排序算法详解","date":"2023-04-16T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/前端10大排序算法详解.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/46.png","content":"<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f26fbf52e624f18a3c98493206d1cbe~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95871a3ebf9346b9a61819e3527a85f1~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h1 id=\"冒泡🫧排序\"><a href=\"#冒泡🫧排序\" class=\"headerlink\" title=\"冒泡🫧排序\"></a>冒泡🫧排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。<br>内循环： 使用相邻双指针 j , j + 1 从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换；遍历完成时，最大元素会被交换至数组最右边 。<br>外循环： 不断重复「内循环」，每轮将当前最大元素交换至 剩余未排序数组最右边 ，直至所有元素都被交换至正确位置时结束。</p></blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3adb5495e8d04ed9af55197d9e0896fd~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;**\n * 冒泡🫧\n * 每一趟找出最大的,总共比较次数为arr.length-1次,每次的比较次数为arr.length-1-i次，依次递减\n * @param &#123;*&#125; arr \n * @returns array\n *&#x2F;\nfunction bubbleSort(arr) &#123;\n    &#x2F;**\n        比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n        针对所有的元素重复以上的步骤，除了最后一个。\n        持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n        相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n        \n        原始数组： [ 99, 88, 66, 101, 90, 45 ]\n\n        第1次循环 [ 88, 66, 99, 90, 45, 101 ]\n        第2次循环 [ 66, 88, 90, 45, 99, 101 ]\n        第3次循环 [ 66, 88, 45, 90, 99, 101 ]\n        第4次循环 [ 66, 45, 88, 90, 99, 101 ]\n        第5次循环 [ 45, 66, 88, 90, 99, 101 ]\n     *&#x2F;\n    let len &#x3D; arr.length;\n    if (!len) &#123;\n        return [];\n    &#125;\n    console.log(&#39;原始数组：&#39;, arr);\n    &#x2F;&#x2F;外循环，对被排序的数组进行遍历，轮数为数组的长度\n    for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        &#x2F;&#x2F; 内循环，循环比较相邻元素\n        for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n            &#x2F;&#x2F;如果前一个元素大于后一个元素的话，就交换两个元素的位置，最后是以从大到小的顺序输出\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]; &#x2F;&#x2F;元素交换\n            &#125;\n        &#125;\n        console.log(&#96;第$&#123;i+1&#125;次循环&#96;, arr);\n    &#125;\n    return arr;\n&#125;\n</code></pre>\n<p> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8875926efd0e4f6d8f32227dab53fc10~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>普通冒泡排序的时间复杂度恒为 O(N2)，与输入数组的元素分布无关。<br>通过增加一个标志位 flag ，若在某轮「内循环」中未执行任何交换操作，则说明数组已经完成排序，直接返回结果即可。<br>优化后的冒泡排序的最差和平均时间复杂度仍为 O(N2) ;在输入数组 已排序 时，达到 最佳时间复杂度 𝜴(N)</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function bubbleSort(arr) &#123;\n  let len &#x3D; arr.length;\n  if (!len) &#123;\n    return [];\n  &#125;\n  console.log(&#39;原始数组：&#39;, arr);\n  &#x2F;&#x2F;外循环，对被排序的数组进行遍历，轮数为数组的长度\n  for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n    let flag &#x3D; false; &#x2F;&#x2F; 初始化标志位\n    &#x2F;&#x2F; 内循环，循环比较相邻元素\n    for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n      &#x2F;&#x2F;如果前一个元素大于后一个元素的话，就交换两个元素的位置，最后是以从大到小的顺序输出\n      if (arr[j] &gt; arr[j + 1]) &#123;\n        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]; &#x2F;&#x2F;元素交换\n         flag &#x3D; true;  &#x2F;&#x2F; 记录交换元素\n      &#125;\n    &#125;\n    if (!flag) break;     &#x2F;&#x2F; 内循环未交换任何元素，则跳出\n    console.log(&#96;第$&#123;i+1&#125;次循环&#96;, arr);\n  &#125;\n  return arr;\n&#125;</code></pre>\n\n<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>思路：依次找到剩余元素的最小值或者最大值，放置在末尾或者开头。</p></blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baa504a01c2641aea47a3cf73ac38626~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image.png\"></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">\n&#x2F;**\n * 选择排序\n * 依次找到剩余元素的最小值或者最大值，放置在末尾或者开头。\n * @param &#123;Array&#125; arr\n * @returns\n *&#x2F;\nfunction selectionSort(arr) &#123;\n    let len &#x3D; arr.length;\n    let minIndex;\n    for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        minIndex &#x3D; i;&#x2F;&#x2F;先假设第一个数字最小\n        for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数\n                minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存\n            &#125;\n        &#125;\n        [arr[minIndex], arr[i]] &#x3D; [arr[i], arr[minIndex]]&#x2F;&#x2F;交换两个元素\n    &#125;\n    return arr;\n&#125;\n</code></pre>\n\n\n<h1 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>思路：以第一个元素为有序数组，其后的元素通过再这个已有序的数组中找到合适的元素并插入。</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function insertSort(arr) &#123;\n  let length &#x3D; arr.length,\n    preIndex, current;\n  for (let i &#x3D; 1; i &lt; length; i++) &#123;\n    preIndex &#x3D; i - 1;\n    current &#x3D; arr[i];\n    &#x2F;&#x2F; 和已经排序好的序列进行比较，插入到合适的位置\n    while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123;\n      arr[preIndex + 1] &#x3D; arr[preIndex];\n      preIndex--;\n    &#125;\n    arr[preIndex + 1] &#x3D; current;\n    console.log(&#96;第$&#123;i&#125;次循环&#96;, arr);\n  &#125;\n  return arr;\n&#125;</code></pre>\n\n<h1 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function shellSort(arr) &#123;\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 初始步数\n  let gap &#x3D; parseInt(len &#x2F; 2);\n  &#x2F;&#x2F; 逐渐缩小步数\n  while (gap) &#123;\n    &#x2F;&#x2F; 从第gap个元素开始遍历\n    for (let i &#x3D; gap; i &lt; len; i++) &#123;\n      &#x2F;&#x2F; 逐步其和前面其他的组成员进行比较和交换\n      for (let j &#x3D; i - gap; j &gt;&#x3D; 0; j -&#x3D; gap) &#123;\n        if (arr[j] &gt; arr[j + gap]) &#123;\n          [arr[j], arr[j + gap]] &#x3D; [arr[j + gap], arr[j]];\n        &#125; else &#123;\n          break;\n        &#125;\n      &#125;\n    &#125;\n    gap &#x3D; parseInt(gap &#x2F; 2);\n  &#125;\n&#125;</code></pre>\n\n\n<h1 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>递归将数组分为两个序列，有序合并这两个序列。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>\n<ol>\n<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）。</li>\n<li>自下而上的迭代。</li>\n</ol></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function  &#x2F;**\n     * 归并排序\n     *&#x2F;\n  mergeSort(arr) &#123;\n    let len &#x3D; arr.length;\n    if (len &lt; 2) &#123;\n      return arr;\n    &#125;\n    let middle &#x3D; Math.floor(len &#x2F; 2),\n      left &#x3D; arr.slice(0, middle),\n      right &#x3D; arr.slice(middle);\n    console.log(&#96;处理过程：&#96;, arr);\n    return this.merge(this.mergeSort(left), this.mergeSort(right));\n  &#125;,\n&#x2F;**\n     * 归并排序辅助方法\n     *&#x2F;\nfunction merge(left, right) &#123;\n  let result &#x3D; [];\n  while (left.length &amp;&amp; right.length) &#123;\n    if (left[0] &lt;&#x3D; right[0]) &#123;\n      result.push(left.shift());\n    &#125; else &#123;\n      result.push(right.shift());\n    &#125;\n  &#125;\n  while (left.length) &#123;\n    result.push(left.shift());\n  &#125;\n  while (right.length)&#123;\n    result.push(right.shift());\n  &#125;\n  return result;\n&#125;</code></pre>\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>快速排序算法是一种基于分治思想的排序算法，其核心思路在于通过选取一个基准值，将待排序数组划分为左右两个子序列，其中左侧序列所有元素均小于基准值，右侧序列所有元素均大于基准值。之后对左右子序列递归进行快排操作，最终将整个序列排好序。<br>以下是使用 TypeScript 实现的快速排序算法代码：</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function quickSort(arr: number[]): number[] &#123;\n  if (arr.length &lt;&#x3D; 1) &#123;\n    return arr;\n  &#125;\n\n  const pivotIndex &#x3D; Math.floor(arr.length &#x2F; 2);\n  const pivot &#x3D; arr[pivotIndex];\n  const left &#x3D; [];\n  const right &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (i &#x3D;&#x3D;&#x3D; pivotIndex) &#123;\n      continue;\n    &#125;\n\n    const currentItem &#x3D; arr[i];\n\n    if (currentItem &lt; pivot) &#123;\n      left.push(currentItem);\n    &#125; else &#123;\n      right.push(currentItem);\n    &#125;\n  &#125;\n\n  return [...quickSort(left), pivot, ...quickSort(right)];\n&#125;\n\n</code></pre>\n\n\n<h1 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>堆排序算法是一种基于堆数据结构的排序算法，其核心思路在于将待排序数组看做二叉树，通过构建大顶堆或小顶堆来实现排序。对于大顶堆，每个节点的值均大于或等于它的子节点；对于小顶堆，每个节点的值均小于或等于它的子节点。排序时，取堆顶元素，将其存储到已排序数组中，并从堆中删除；然后重新调整剩余元素形成新的堆，重复以上操作直至所有元素排序完成。<br>以下是使用 TypeScript 实现的堆排序算法代码：</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">function heapSort(arr: number[]): number[] &#123;\n  const len &#x3D; arr.length;\n\n  &#x2F;&#x2F; 初始化大顶堆，从第一个非叶子结点开始\n  for (let i &#x3D; Math.floor(len &#x2F; 2) - 1; i &gt;&#x3D; 0; i--) &#123;\n    heapify(arr, len, i);\n  &#125;\n\n  &#x2F;&#x2F; 排序，每次将堆顶元素与未排定部分的最后一个元素交换，并重新构造大顶堆\n  for (let i &#x3D; len - 1; i &gt; 0; i--) &#123;\n    [arr[0], arr[i]] &#x3D; [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  &#125;\n\n  return arr;\n&#125;\n\n&#x2F;&#x2F; 堆化函数，将以i为根节点的子树调整为大顶堆\nfunction heapify(arr: number[], len: number, i: number) &#123;\n  let largest &#x3D; i; &#x2F;&#x2F; 最大值默认为根节点\n  const left &#x3D; 2 * i + 1; &#x2F;&#x2F; 左子节点下标\n  const right &#x3D; 2 * i + 2; &#x2F;&#x2F; 右子节点下标\n\n  &#x2F;&#x2F; 如果左子节点比当前最大值大，则更新最大值\n  if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;\n    largest &#x3D; left;\n  &#125;\n\n  &#x2F;&#x2F; 如果右子节点比当前最大值大，则更新最大值\n  if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;\n    largest &#x3D; right;\n  &#125;\n\n  &#x2F;&#x2F; 如果最大值不是根节点，则交换根节点和最大值，并继续调整以最大值为根的子树\n  if (largest !&#x3D;&#x3D; i) &#123;\n    [arr[i], arr[largest]] &#x3D; [arr[largest], arr[i]];\n    heapify(arr, len, largest);\n  &#125;\n&#125;\n</code></pre>\n<h1 id=\"记数排序\"><a href=\"#记数排序\" class=\"headerlink\" title=\"记数排序\"></a>记数排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>记数排序（Counting Sort）是一种非基于比较的排序算法，其时间复杂度为O(n+k)，其中k表示待排序数组中最大元素与最小元素之差加1。该算法的基本思想是统计每个元素在待排序数组中出现的次数，然后根据统计结果构建有序序列。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * 计数排序\n * @param arr 待排序数组\n * @returns 排序后数组\n *&#x2F;\nfunction countingSort(arr: number[]): number[] &#123;\n  const max &#x3D; Math.max(...arr);\n  const count &#x3D; new Array(max + 1).fill(0);\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    count[arr[i]]++;\n  &#125;\n\n  const res &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt;&#x3D; max; i++) &#123;\n    while (count[i]--) &#123;\n      res.push(i);\n    &#125;\n  &#125;\n\n  return res;\n&#125;\n</code></pre>\n<h1 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>桶排序（Bucket Sort）是一种线性排序算法，它利用了函数的映射关系，将要排序的数据分到有限数量的桶子里，每个桶子再分别排序。桶排序的时间复杂度取决于桶的数量和桶内使用的排序算法，通常情况下是O(n+k)。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * 桶排序\n * @param arr 待排序数组\n * @param bucketSize 桶大小\n * @returns 排序后数组\n *&#x2F;\nfunction bucketSort(arr: number[], bucketSize &#x3D; 5): number[] &#123;\n  if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return arr;\n  &#125;\n\n  &#x2F;&#x2F; 找出最大值和最小值\n  let min &#x3D; arr[0];\n  let max &#x3D; arr[0];\n\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; min) &#123;\n      min &#x3D; arr[i];\n    &#125; else if (arr[i] &gt; max) &#123;\n      max &#x3D; arr[i];\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 计算桶的数量\n  const bucketCount &#x3D; Math.floor((max - min) &#x2F; bucketSize) + 1;\n  const buckets: number[][] &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; bucketCount; i++) &#123;\n    buckets[i] &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 将元素分配到桶中\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    const index &#x3D; Math.floor((arr[i] - min) &#x2F; bucketSize);\n    buckets[index].push(arr[i]);\n  &#125;\n\n  &#x2F;&#x2F; 对每个桶进行排序，并将结果合并\n  const res &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; buckets.length; i++) &#123;\n    if (buckets[i]) &#123;\n      const sortedBucket &#x3D; countingSort(buckets[i]);\n\n      for (let j &#x3D; 0; j &lt; sortedBucket.length; j++) &#123;\n        res.push(sortedBucket[j]);\n      &#125;\n    &#125;\n  &#125;\n\n  return res;\n&#125;\n</code></pre>\n<h1 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>基数排序（Radix Sort）是一种多关键字排序算法，可用于对数字序列进行排序。基数排序先按照最低有效位（LSB）对元素进行排序，然后依次按照次低有效位、次次低有效位……最高有效位进行排序。该算法的时间复杂度为O(d*(n+k))，其中d表示数字位数，k表示每个数字可能的取值范围。</p></blockquote>\n<pre class=\"line-numbers language-typescript\" data-language=\"typescript\"><code class=\"language-typescript\">&#x2F;**\n * 基数排序\n * @param arr 待排序数组\n * @returns 排序后数组\n *&#x2F;\nfunction radixSort(arr: number[]): number[] &#123;\n  const max &#x3D; Math.max(...arr);\n  const buckets: number[][] &#x3D; [];\n\n  &#x2F;&#x2F; 初始化桶\n  for (let i &#x3D; 0; i &lt; 10; i++) &#123;\n    buckets[i] &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 计算最大数字的位数\n  let digitCount &#x3D; 0;\n\n  while (max &gt; 0) &#123;\n    max &#x3D; Math.floor(max &#x2F; 10);\n    digitCount++;\n  &#125;\n\n  &#x2F;&#x2F; 根据每一位进行排序\n  for (let i &#x3D; 0; i &lt; digitCount; i++) &#123;\n    for (let j &#x3D; 0; j &lt; arr.length; j++) &#123;\n      const num &#x3D; arr[j];\n      const digit &#x3D; Math.floor(num &#x2F; Math.pow(10, i)) % 10;\n      buckets[digit].push(num);\n    &#125;\n\n    arr &#x3D; [];\n\n    for (let k &#x3D; 0; k &lt; buckets.length; k++) &#123;\n      while (buckets[k].length) &#123;\n        arr.push(buckets[k].shift()!);\n      &#125;\n    &#125;\n  &#125;\n\n  return arr;\n&#125;\n</code></pre>","feature":false,"text":" 冒泡🫧排序 通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。内循环： 使用相邻双指针 j , j + 1 从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换；遍历完成时，最大元素会被交换至数组最右边 。外循环： 不断重复「内循环」，每...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"算法","slug":"算法","count":1,"path":"api/categories/算法.json"}],"tags":[{"name":"排序","slug":"排序","count":1,"path":"api/tags/排序.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%F0%9F%AB%A7%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡🫧排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">选择排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">堆排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%B0%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">记数排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A1%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">桶排序</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">基数排序</span></a></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"前端项目(Vue,React)性能优化","uid":"aede38527e7a3b6a941a59510b6feb5f","slug":"js/前端项目(Vue,React)性能优化","date":"2023-04-18T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/前端项目(Vue,React)性能优化.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/48.png","text":"前言前端随着node等JavaScript运行时平台的出现，逐渐向工程化方向发展。项目开发也越来越规范化，但是随着项目的体积越来越大，依赖库越来越多，项目的运行，热更新和打包发布也是越来越慢，甚至卡顿。这个时候就需要对项目进行“瘦身”（性能优化）了。本文就围绕着如何给前端项目进行...","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"性能优化","slug":"性能优化","count":1,"path":"api/categories/性能优化.json"}],"tags":[{"name":"性能优化","slug":"性能优化","count":1,"path":"api/tags/性能优化.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"使用Vite+Vue3创建Cesium项目","uid":"f47aa374ec8bb25754a7283a60088fec","slug":"vue/使用Vite+Vue3创建Cesium项目","date":"2023-04-15T02:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/vue/使用Vite+Vue3创建Cesium项目.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/45.png","text":"Vite+Vue3+Cesium项目模版 Cesium是AGI公司计算机图形开发小组与2011年研发的三维地球和地图可视化开源JavaScript库，Cesium一词来源于化学元素铯，铯是制造原子钟的关键元素，研发小组通过命名强调Cesium产品精益求精，专注时间数据可视化。Ce...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"vue3","slug":"vue3","count":1,"path":"api/categories/vue3.json"}],"tags":[{"name":"cesium","slug":"cesium","count":2,"path":"api/tags/cesium.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}