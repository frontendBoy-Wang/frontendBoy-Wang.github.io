{"title":"一文带你了解跨域的前因后果和解决方案","uid":"06bcbca25b590a41890b9b1b71d4205b","slug":"js/一文带你了解跨域的前因后果和解决方案","date":"2023-01-04T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/一文带你了解跨域的前因后果和解决方案.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/0.png","content":"<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b3ff8ebecc4c92884a28a291f3c42d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=7952&h=5304&s=6064796&e=jpg&b=b06bd3\" alt=\"img1.wallspic.com-cheng_shi-zi_se_de-tian_ji_xian-qi_fen-yu_hui-7952x5304.jpg\"></p>\n<h1 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h1><p>在了解跨域之前，我们必须要了解一下同源策略。<br>跨域问题其实就是浏览器的同源策略造成的。</p>\n<h2 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h2><p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>跨源资源共享</strong>（[CORS]，或通俗地译为跨域资源共享）是一种基于 [HTTP] 头的机制，该机制通过允许服务器标示除了它自己以外的其他[源] （域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。</p></blockquote>\n<h1 id=\"为什么会产生跨域\"><a href=\"#为什么会产生跨域\" class=\"headerlink\" title=\"为什么会产生跨域\"></a>为什么会产生跨域</h1><p>下表给出了与 URL <a href=\"http://wmq.com/dir/page.html\">http://wmq.com/dir/page.html</a> 的源进行对比的示例:</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"http://wmq.com/dir/page.html\">http://wmq.com/dir/page.html</a></td>\n<td>同源</td>\n<td>完全相同</td>\n</tr>\n<tr>\n<td><a href=\"http://wmq.com/dir/inner/another.html\">http://wmq.com/dir/inner/another.html</a></td>\n<td>同源</td>\n<td>只有路径不同</td>\n</tr>\n<tr>\n<td><a href=\"https://wmq.com/secure.html\">https://wmq.com/secure.html</a></td>\n<td>跨域</td>\n<td>协议不同</td>\n</tr>\n<tr>\n<td><a href=\"http://wmq.com:81/dir/etc.html\">http://wmq.com:81/dir/etc.html</a></td>\n<td>跨域</td>\n<td>端口不同 ( http:// 默认端口是80)</td>\n</tr>\n<tr>\n<td><a href=\"http://news.company.com/dir/other.html\">http://news.company.com/dir/other.html</a></td>\n<td>跨域</td>\n<td>主机不同</td>\n</tr>\n</tbody></table>\n<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>\n<p><strong>同源政策主要限制了三个方面：</strong></p>\n<ul>\n<li>  当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>\n<li>  当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>\n<li>  当前域下 ajax 无法发送跨域请求。</li>\n</ul>\n<p>源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>\n<h1 id=\"有哪些解决跨域的办法\"><a href=\"#有哪些解决跨域的办法\" class=\"headerlink\" title=\"有哪些解决跨域的办法\"></a>有哪些解决跨域的办法</h1><h2 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"CORS\"></a>CORS</h2><p> <strong>CORS</strong>: 通过设置服务器端的响应头来允许跨域请求。这需要在服务器端进行配置，以允许特定的来源访问资源。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);</code></pre>\n\n<h3 id=\"减少OPTIONS请求次数\"><a href=\"#减少OPTIONS请求次数\" class=\"headerlink\" title=\"减少OPTIONS请求次数\"></a>减少OPTIONS请求次数</h3><p>在跨域请求中，浏览器会自动处理一些非简单请求的预检流程，这包括”预检请求”（也被称为CORS预检请求）和”OPTIONS请求”。预检请求是发起一个HTTP OPTIONS请求到服务器，以确认目标资源是否支持跨域。这种机制是为了兼容同源策略而产生的，但有时这种额外的请求会导致性能问题。</p>\n<p>为了减少这种非必要的 OPTIONS 请求次数，可以采取以下几种方法：</p>\n<p><strong>配置服务器</strong>: 对服务器进行配置以允许来自特定来源的跨域请求。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS响应头：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);\n\n    </code></pre>\n\n<p>在这个例子中，我们添加了一个新的响应头<code>Access-Control-Allow-Methods</code>，其中包含了<code>GET, POST, PUT, DELETE</code>等简单请求方法，这样浏览器对于简单跨域请求就不会再发送预检请求了。</p>\n<h3 id=\"CORS中Cookie相关问题\"><a href=\"#CORS中Cookie相关问题\" class=\"headerlink\" title=\"CORS中Cookie相关问题\"></a>CORS中Cookie相关问题</h3><p>在CORS中，Cookie是一个重要的安全特性。如果服务器端设置了允许跨域请求的响应头，那么客户端就可以在跨域请求中携带Cookie。但是，如果服务器端没有设置允许跨域请求的响应头，那么客户端就无法在跨域请求中携带Cookie。</p>\n<p>为了解决这个问题，可以在服务器端设置允许跨域请求的响应头，以允许客户端携带Cookie。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept, Cookie&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);\n</code></pre>\n\n<p>在这个例子中，我们添加了一个新的响应头<code>Access-Control-Allow-Headers</code>，其中包含了<code>Cookie</code>。这样，客户端就可以在跨域请求中携带Cookie了。</p>\n<p>也就是说上面两个问题的解决方法是一样的，都是通过在服务端设置添加一个新的响应头<code>Access-Control-Allow-Headers</code></p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>\n<p>1）原生JS实现：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    var script &#x3D; document.createElement(&#39;script&#39;);\n    script.type &#x3D; &#39;text&#x2F;javascript&#39;;\n    &#x2F;&#x2F; 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src &#x3D; &#39;http:&#x2F;&#x2F;www.domain1.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;handleCallback&#39;;\n    document.head.appendChild(script);\n    &#x2F;&#x2F; 回调执行函数\n    function handleCallback(res) &#123;\n        alert(JSON.stringify(res));\n    &#125;\n &lt;&#x2F;script&gt;</code></pre>\n\n<p>服务端返回如下（返回时即执行全局函数）：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">handleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</code></pre>\n\n<p>2）Vue axios实现：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">this.$http &#x3D; axios;\nthis.$http.jsonp(&#39;http:&#x2F;&#x2F;www.domain2.com:8080&#x2F;login&#39;, &#123;\n    params: &#123;&#125;,\n    jsonp: &#39;handleCallback&#39;\n&#125;).then((res) &#x3D;&gt; &#123;\n    console.log(res); \n&#125;)</code></pre>\n\n<p>后端node.js代码：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var querystring &#x3D; require(&#39;querystring&#39;);\nvar http &#x3D; require(&#39;http&#39;);\nvar server &#x3D; http.createServer();\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var params &#x3D; querystring.parse(req.url.split(&#39;?&#39;)[1]);\n    var fn &#x3D; params.callback;\n    &#x2F;&#x2F; jsonp返回设置\n    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;javascript&#39; &#125;);\n    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);\n    res.end();\n&#125;);\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);</code></pre>\n\n<p><strong>JSONP的缺点：</strong></p>\n<ul>\n<li>  具有局限性， 仅支持get方法</li>\n<li>  不安全，可能会遭受XSS攻击</li>\n</ul>\n<h2 id=\"postMessage-跨域\"><a href=\"#postMessage-跨域\" class=\"headerlink\" title=\"postMessage 跨域\"></a>postMessage 跨域</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>\n<ul>\n<li>  页面和其打开的新窗口的数据传递</li>\n<li>  多窗口之间消息传递</li>\n<li>  页面与嵌套的iframe消息传递</li>\n<li>  上面三个场景的跨域数据传递</li>\n</ul>\n<p>用法：postMessage(data,origin)方法接受两个参数：</p>\n<ul>\n<li>  <strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>\n<li>  <strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>\n</ul>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;       \n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    iframe.onload &#x3D; function() &#123;\n        var data &#x3D; &#123;\n            name: &#39;aym&#39;\n        &#125;;\n        &#x2F;&#x2F; 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain2.com&#39;);\n    &#125;;\n    &#x2F;&#x2F; 接受domain2返回数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain2 ---&gt; &#39; + e.data);\n    &#125;, false);\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>2）b.html：(domain2.com/b.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;script&gt;\n    &#x2F;&#x2F; 接收domain1的数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain1 ---&gt; &#39; + e.data);\n        var data &#x3D; JSON.parse(e.data);\n        if (data) &#123;\n            data.number &#x3D; 16;\n            &#x2F;&#x2F; 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain1.com&#39;);\n        &#125;\n    &#125;, false);\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"nginx代理跨域\"><a href=\"#nginx代理跨域\" class=\"headerlink\" title=\"nginx代理跨域\"></a>nginx代理跨域</h2><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>\n<p>1）nginx配置解决iconfont跨域</p>\n<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">location &#x2F; &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;</code></pre>\n\n<p>2）nginx反向代理接口跨域</p>\n<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>\n<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>\n<p>nginx具体配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#proxy服务器\nserver &#123;\n    listen       81;\n    server_name  www.domain1.com;\n    location &#x2F; &#123;\n        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"nodejs-中间件代理跨域\"><a href=\"#nodejs-中间件代理跨域\" class=\"headerlink\" title=\"nodejs 中间件代理跨域\"></a>nodejs 中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>\n<p><strong>1）非vue框架的跨域</strong></p>\n<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>\n<ul>\n<li>  前端代码：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var xhr &#x3D; new XMLHttpRequest();\n&#x2F;&#x2F; 前端开关：浏览器是否读写cookie\nxhr.withCredentials &#x3D; true;\n&#x2F;&#x2F; 访问http-proxy-middleware代理服务器\nxhr.open(&#39;get&#39;, &#39;http:&#x2F;&#x2F;www.domain1.com:3000&#x2F;login?user&#x3D;admin&#39;, true);\nxhr.send();</code></pre>\n\n<ul>\n<li>  中间件服务器代码：</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var express &#x3D; require(&#39;express&#39;);\nvar proxy &#x3D; require(&#39;http-proxy-middleware&#39;);\nvar app &#x3D; express();\napp.use(&#39;&#x2F;&#39;, proxy(&#123;\n    &#x2F;&#x2F; 代理跨域目标接口\n    target: &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;,\n    changeOrigin: true,\n    &#x2F;&#x2F; 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) &#123;\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http:&#x2F;&#x2F;www.domain1.com&#39;);\n        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);\n    &#125;,\n    &#x2F;&#x2F; 修改响应信息中的cookie域名\n    cookieDomainRewrite: &#39;www.domain1.com&#39;  &#x2F;&#x2F; 可以为false，表示不修改\n&#125;));\napp.listen(3000);\nconsole.log(&#39;Proxy server is listen at port 3000...&#39;);</code></pre>\n\n<p><strong>2）vue框架的跨域</strong></p>\n<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>\n<p>webpack.config.js部分配置：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">module.exports &#x3D; &#123;\n    entry: &#123;&#125;,\n    module: &#123;&#125;,\n    ...\n    devServer: &#123;\n        historyApiFallback: true,\n        proxy: [&#123;\n            context: &#39;&#x2F;login&#39;,\n            target: &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;,  &#x2F;&#x2F; 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  &#x2F;&#x2F; 当代理某些https服务报错时用\n            cookieDomainRewrite: &#39;www.domain1.com&#39;  &#x2F;&#x2F; 可以为false，表示不修改\n        &#125;],\n        noInfo: true\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"document-domain-iframe跨域\"><a href=\"#document-domain-iframe跨域\" class=\"headerlink\" title=\"document.domain + iframe跨域\"></a>document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>\n<p>1）父窗口：(domain.com/a.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;child.domain.com&#x2F;b.html&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    document.domain &#x3D; &#39;domain.com&#39;;\n    var user &#x3D; &#39;admin&#39;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>1）子窗口：(child.domain.com/a.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;script&gt;\n    document.domain &#x3D; &#39;domain.com&#39;;\n    &#x2F;&#x2F; 获取父窗口中变量\n    console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.user);\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"location-hash-iframe跨域\"><a href=\"#location-hash-iframe跨域\" class=\"headerlink\" title=\"location.hash + iframe跨域\"></a>location.hash + iframe跨域</h2><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>\n<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 向b.html传hash值\n    setTimeout(function() &#123;\n        iframe.src &#x3D; iframe.src + &#39;#user&#x3D;admin&#39;;\n    &#125;, 1000);\n    \n    &#x2F;&#x2F; 开放给同域c.html的回调方法\n    function onCallback(res) &#123;\n        alert(&#39;data from c.html ---&gt; &#39; + res);\n    &#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>2）b.html：(.domain2.com/b.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain1.com&#x2F;c.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 监听a.html传来的hash值，再传给c.html\n    window.onhashchange &#x3D; function () &#123;\n        iframe.src &#x3D; iframe.src + location.hash;\n    &#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>3）c.html：(<a href=\"https://link.zhihu.com/?target=http://www.domain1.com/c.html\">http://www.domain1.com/c.html</a>)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;script&gt;\n    &#x2F;&#x2F; 监听b.html传来的hash值\n    window.onhashchange &#x3D; function () &#123;\n        &#x2F;&#x2F; 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user&#x3D;&#39;, &#39;&#39;));\n    &#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"window-name-iframe跨域\"><a href=\"#window-name-iframe跨域\" class=\"headerlink\" title=\"window.name + iframe跨域\"></a>window.name + iframe跨域</h2><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>\n<p>1）a.html：(domain1.com/a.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">var proxy &#x3D; function(url, callback) &#123;\n    var state &#x3D; 0;\n    var iframe &#x3D; document.createElement(&#39;iframe&#39;);\n    &#x2F;&#x2F; 加载跨域页面\n    iframe.src &#x3D; url;\n    &#x2F;&#x2F; onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload &#x3D; function() &#123;\n        if (state &#x3D;&#x3D;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n        &#125; else if (state &#x3D;&#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location &#x3D; &#39;http:&#x2F;&#x2F;www.domain1.com&#x2F;proxy.html&#39;;\n            state &#x3D; 1;\n        &#125;\n    &#125;;\n    document.body.appendChild(iframe);\n    &#x2F;&#x2F; 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() &#123;\n        iframe.contentWindow.document.write(&#39;&#39;);\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    &#125;\n&#125;;\n&#x2F;&#x2F; 请求跨域b页面数据\nproxy(&#39;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&#39;, function(data)&#123;\n    alert(data);\n&#125;);</code></pre>\n\n<p>2）proxy.html：(domain1.com/proxy.html)</p>\n<p>中间代理页，与a.html同域，内容为空即可。</p>\n<p>3）b.html：(domain2.com/b.html)</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;script&gt;\n    window.name &#x3D; &#39;This is domain2 data!&#39;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>\n<h2 id=\"WebSocket协议跨域\"><a href=\"#WebSocket协议跨域\" class=\"headerlink\" title=\"WebSocket协议跨域\"></a>WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>\n<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>\n<p>1）前端代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&lt;div&gt;user input：&lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;div&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;socket.io&#x2F;2.2.0&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\nvar socket &#x3D; io(&#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;);\n&#x2F;&#x2F; 连接成功处理\nsocket.on(&#39;connect&#39;, function() &#123;\n    &#x2F;&#x2F; 监听服务端消息\n    socket.on(&#39;message&#39;, function(msg) &#123;\n        console.log(&#39;data from server: ---&gt; &#39; + msg); \n    &#125;);\n    &#x2F;&#x2F; 监听服务端关闭\n    socket.on(&#39;disconnect&#39;, function() &#123; \n        console.log(&#39;Server socket has closed.&#39;); \n    &#125;);\n&#125;);\ndocument.getElementsByTagName(&#39;input&#39;)[0].onblur &#x3D; function() &#123;\n    socket.send(this.value);\n&#125;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"Nodejs-socket后台：\"><a href=\"#Nodejs-socket后台：\" class=\"headerlink\" title=\"Nodejs socket后台：\"></a>Nodejs socket后台：</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var http &#x3D; require(&#39;http&#39;);\nvar socket &#x3D; require(&#39;socket.io&#39;);\n&#x2F;&#x2F; 启http服务\nvar server &#x3D; http.createServer(function(req, res) &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-type&#39;: &#39;text&#x2F;html&#39;\n    &#125;);\n    res.end();\n&#125;);\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n&#x2F;&#x2F; 监听socket连接\nsocket.listen(server).on(&#39;connection&#39;, function(client) &#123;\n    &#x2F;&#x2F; 接收信息\n    client.on(&#39;message&#39;, function(msg) &#123;\n        client.send(&#39;hello：&#39; + msg);\n        console.log(&#39;data from client: ---&gt; &#39; + msg);\n    &#125;);\n    &#x2F;&#x2F; 断开处理\n    client.on(&#39;disconnect&#39;, function() &#123;\n        console.log(&#39;Client socket has closed.&#39;); \n    &#125;);\n&#125;);</code></pre>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>以上就是一些为什么会产生跨域和一些解决跨域的方法。</p>\n","feature":false,"text":" 什么是跨域在了解跨域之前，我们必须要了解一下同源策略。跨域问题其实就是浏览器的同源策略造成的。 同源策略同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。 跨源资源...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"跨域","slug":"跨域","count":1,"path":"api/categories/跨域.json"},{"name":"前端","slug":"跨域/前端","count":1,"path":"api/categories/跨域/前端.json"}],"tags":[{"name":"浏览器 跨域","slug":"浏览器-跨域","count":1,"path":"api/tags/浏览器-跨域.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">什么是跨域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">同源策略</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">为什么会产生跨域</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">有哪些解决跨域的办法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CORS\"><span class=\"toc-text\">CORS</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%8F%E5%B0%91OPTIONS%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">减少OPTIONS请求次数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CORS%E4%B8%ADCookie%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">CORS中Cookie相关问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JSONP\"><span class=\"toc-text\">JSONP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#postMessage-%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">postMessage 跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nginx%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">nginx代理跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#nodejs-%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">nodejs 中间件代理跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#document-domain-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">document.domain + iframe跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#location-hash-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">location.hash + iframe跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#window-name-iframe%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">window.name + iframe跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#WebSocket%E5%8D%8F%E8%AE%AE%E8%B7%A8%E5%9F%9F\"><span class=\"toc-text\">WebSocket协议跨域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nodejs-socket%E5%90%8E%E5%8F%B0%EF%BC%9A\"><span class=\"toc-text\">Nodejs socket后台：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"mapped":true,"prev_post":{"title":"深入理解Redux数据更新机制：数据流管理的核心原理","uid":"67e534ae18855eb1a7fe1ada975d8605","slug":"react/深入理解Redux数据更新机制：数据流管理的核心原理","date":"2023-01-10T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/react/深入理解Redux数据更新机制：数据流管理的核心原理.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/73.png","text":"前言在现代的前端开发中，数据管理是一个至关重要的问题。随着应用程序的复杂性不断增加，我们需要一种有效的方式来管理数据的流动和更新。Redux作为一个流行的状态管理库，提供了一种简洁而强大的数据更新机制，成为了许多开发者的首选。 本文将深入探讨Redux的数据更新机制，帮助读者更好...","link":"","photos":[],"count_time":{"symbolsCount":"5.4k","symbolsTime":"5 mins."},"categories":[{"name":"react","slug":"react","count":3,"path":"api/categories/react.json"}],"tags":[{"name":"react redux","slug":"react-redux","count":1,"path":"api/tags/react-redux.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false},"next_post":{"title":"如何实现一个WebComponent组件","uid":"83d359dd0111440bbb3e9ab60e3adbe5","slug":"js/如何实现一个WebComponent组件","date":"2022-11-04T14:46:35.000Z","updated":"2024-12-25T06:40:06.000Z","comments":true,"path":"api/articles/js/如何实现一个WebComponent组件.json","keywords":"前端少年汪,前端,后端,全栈工程师,程序员,vue,react,Golang,Java,JavaScript,Python,frontendBoy-Wang","cover":"../img/17.png","text":" 作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的 HTML（以及相关的样式和脚本），有时你不得不写代码来呈现自定义 UI 控件，并且如果你不小心的话，多次使用它们会使你的页面变得一团糟。 什么是Web Conmpon...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":5,"path":"api/categories/前端.json"},{"name":"js","slug":"前端/js","count":2,"path":"api/categories/前端/js.json"},{"name":"html","slug":"前端/js/html","count":1,"path":"api/categories/前端/js/html.json"}],"tags":[{"name":"web组件","slug":"web组件","count":1,"path":"api/tags/web组件.json"}],"author":{"name":"前端少年汪","slug":"blog-author","avatar":"https://p3-passport.byteimg.com/img/user-avatar/46cf67c329246db441271a06f6132633~100x100.awebp","link":"/","description":"一个追逐技术的全栈工程师 <br /> @ <b>公众号：前端少年汪</b>","socials":{"github":"https://github.com/frontendBoy-Wang","twitter":"","stackoverflow":"https://stackoverflow.com/users/16856904/frontendboy-wang","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/qian-ke-sao-ren-wmq","csdn":"https://blog.csdn.net/qq_44647871?spm=1010.2135.3001.5421","juejin":"https://juejin.cn/user/3570847174897447","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/392982262"}}}},"feature":false}}