[{"id":"ce7691ff8f2ef9994a806e6cb0977c21","title":"2024年终总结","content":"","slug":"年终总结/2024年终总结","date":"2024-12-25T01:56:33.000Z","categories_index":"年终总结","tags_index":"年终总结","author_index":"前端少年汪"},{"id":"529493b0860c50168557a46de0bc5502","title":"圣诞节快到了，用ThreeJS给女朋友写了一个圣诞树🎄，她很开心","content":"\n\n\n\n\n\n\n\n\n转眼间又是一年快要结束了，马上圣诞节🎄就快到了。给女朋友(没有女朋友的就自己new一个吧🙈)写一个圣诞树让她开心一下吧\n使用什么技术写一开始我准备用html+css去写，后来感觉使用html和css写就太low了，没有一点点心意。就打算用three.js写一个3d版本的。\n简单介绍一下threejsThree.js是一个基于原生WebGL封装运行的三维引擎，是最著名的3D WebGL JavaScriptThree.js是一个基于原生WebGL封装运行的三维引擎，是最著名的3D WebGL JavaScript库之一。它是一个让用户通过JavaScript入手进入搭建WebGL项目的类库。Three.js提供了许多简单易用的API，使得开发者能够更加方便地创建复杂的3D场景。\nWebGL是一个只能画点、线和三角形的非常底层的系统。而Three.js则在此基础之上进行了封装，提供了一系列的图形处理功能，如渲染器、相机、灯光、材质等，以及各种几何体、粒子系统等，极大地简化了3D图形编程的难度。这使得学习WebGL需要图形学知识的要求得以降低，因为开发者可以直接通过使用Three.js提供的JS和GLSL两种语言来构建和呈现3D图形。\n实现具体步骤首先，我们需要在HTML文件中引入Three.js库。你可以在Three.js官方网站下载最新版本的库，或者直接从CDN获取。将以下代码添加到你的HTML文件的&lt;head&gt;部分：\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdnjs.cloudflare.com&#x2F;ajax&#x2F;libs&#x2F;three.js&#x2F;r128&#x2F;three.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n接下来，我们将开始编写JavaScript代码来创建场景、相机、渲染器以及圣诞树的各个部分。首先，我们创建一个场景对象，并设置其背景颜色为深绿色：\nlet scene &#x3D; new THREE.Scene();\nscene.background &#x3D; new THREE.Color(0x002633);\n\n然后，我们创建一个透视相机，并将其位置设置为距离场景中心一定距离的位置。我们还设置了相机的视野范围和纵横比：\nlet camera &#x3D; new THREE.PerspectiveCamera(75, window.innerWidth &#x2F; window.innerHeight, 0.1, 1000);\ncamera.position.z &#x3D; 5;\n\n接下来，我们创建一个WebGL渲染器，并将其大小设置为浏览器窗口的大小。然后，我们将渲染器的DOM元素添加到页面中：\nlet renderer &#x3D; new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n现在，我们可以开始创建圣诞树的各个部分了。首先，我们创建一个树干，它是一个圆柱体：\nlet trunkGeometry &#x3D; new THREE.CylinderGeometry(0.2, 0.4, 1.6, 8);\nlet trunk &#x3D; new THREE.Mesh(trunkGeometry, brownMaterial);\nscene.add(trunk);\n\n接着，我们创建一个树叶，它是一个圆锥体：\nlet leavesGeometry &#x3D; new THREE.ConeGeometry(1.2, 2.4, 8);\nlet leaves &#x3D; new THREE.Mesh(leavesGeometry, greenMaterial);\nleaves.position.y &#x3D; 1.6;\nscene.add(leaves);\n\n然后，我们创建彩灯，它们是一些旋转的球体：\nlet lightGeometry &#x3D; new THREE.SphereGeometry(0.1, 4, 4);\nlet lights &#x3D; [];\nlet colors &#x3D; [redMaterial, yellowMaterial, new THREE.MeshBasicMaterial(&#123; color: 0x0000ff &#125;), new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;)];\nlet angles &#x3D; [0, Math.PI &#x2F; 3, 2 * Math.PI &#x2F; 3, Math.PI, 4 * Math.PI &#x2F; 3, 5 * Math.PI &#x2F; 3];\nfor (let i &#x3D; 0; i &lt; angles.length; i++) &#123;\n    let light &#x3D; new THREE.Mesh(lightGeometry, colors[i % 4]);\n    light.position.set(Math.cos(angles[i]) * 0.9, 2.2, Math.sin(angles[i]) * 0.9);\n    scene.add(light);\n    lights.push(light);\n&#125;\n\n接下来，我们创建一个星星，它是一些旋转的点：\nlet starGeometry &#x3D; new THREE.SphereGeometry(0.2, 4, 4);\nlet star &#x3D; new THREE.Mesh(starGeometry, yellowMaterial);\nstar.position.y &#x3D; 2.7;\nscene.add(star);\n\n最后，我们创建一个礼物盒，它是一个立方体：\nlet giftGeometry &#x3D; new THREE.BoxGeometry(0.5, 0.5, 0.5);\nlet giftMaterials &#x3D; [\n    new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;),\n    new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;),\n    new THREE.MeshBasicMaterial(&#123; color: 0x0000ff &#125;),\n    new THREE.MeshBasicMaterial(&#123; color: 0xffff00 &#125;),\n    new THREE.MeshBasicMaterial(&#123; color: 0xff00ff &#125;),\n    new THREE.MeshBasicMaterial(&#123; color: 0x00ffff &#125;)\n];\nlet giftMesh &#x3D; new THREE.Mesh(giftGeometry, giftMaterials);\ngiftMesh.position.set(0, -1.3, 0);\nscene.add(giftMesh);\n\n为了给圣诞树增添一些雪花效果，我们还需要创建一个雪花几何体和一个雪花材质，然后将它们组合成一个雪花网格对象，并将其添加到场景中：\nlet snowFlakeGeometry &#x3D; new THREE.BufferGeometry();\nlet positions &#x3D; [];\nfor (let i &#x3D; 0; i &lt; 1000; i++) &#123;\n    positions.push(Math.random() * 2000 - 1000);\n    positions.push(Math.random() * 2000 - 1000);\n    positions.push(Math.random() * 2000 - 1000);\n&#125;\nsnowFlakeGeometry.setAttribute(&#39;position&#39;, new THREE.Float32BufferAttribute(positions, 3));\nlet snowFlakeMaterial &#x3D; new THREE.PointsMaterial(&#123; color: 0xffffff, size: 2 &#125;);\nlet snowFlake &#x3D; new THREE.Points(snowFlakeGeometry, snowFlakeMaterial);\nscene.add(snowFlake);\n\n最后，我们需要添加一个渲染循环，以便不断地更新场景中的物体并渲染到屏幕上：\nfunction animate() &#123;\n    requestAnimationFrame(animate);\n    trunk.rotation.y +&#x3D; 0.01;\n    leaves.rotation.y +&#x3D; 0.01;\n    for (let i &#x3D; 0; i &lt; lights.length; i++) &#123;\n        lights[i].rotation.y +&#x3D; 0.02;\n    &#125;\n    snowFlake.rotation.y -&#x3D; 0.001;\n    renderer.render(scene, camera);\n&#125;\nanimate();\n\n这就是如何使用Three.js创建一个完整的圣诞树的全部过程。如果你有女朋友，可以尝试写一个哄女朋友开心一下\n最终效果：\n所有代码&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;es&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;\n    &lt;title&gt;完整的圣诞树&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        body &#123; margin: 0; &#125;\n        canvas &#123; display: block; &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;threejs.org&#x2F;build&#x2F;three.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script &gt;\n    &#x2F;&#x2F; 创建场景\n    let scene &#x3D; new THREE.Scene();\n\n    &#x2F;&#x2F; 添加背景颜色\n    scene.background &#x3D; new THREE.Color(0x002633);\n\n    &#x2F;&#x2F; 创建相机\n    let camera &#x3D; new THREE.PerspectiveCamera(75, window.innerWidth &#x2F; window.innerHeight, 0.1, 1000);\n    camera.position.z &#x3D; 5;\n\n    &#x2F;&#x2F; 创建渲染器\n    let renderer &#x3D; new THREE.WebGLRenderer();\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    &#x2F;&#x2F; 创建材质\n    let brownMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0x7f4014 &#125;);\n    let greenMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0x006400, transparent: true, opacity: 0.8 &#125;);\n    let redMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;);\n    let yellowMaterial &#x3D; new THREE.MeshBasicMaterial(&#123; color: 0xffff00 &#125;);\n\n    &#x2F;&#x2F; 创建树干\n    let trunkGeometry &#x3D; new THREE.CylinderGeometry(0.2, 0.4, 1.6, 8);\n    let trunk &#x3D; new THREE.Mesh(trunkGeometry, brownMaterial);\n    scene.add(trunk);\n\n    &#x2F;&#x2F; 创建树叶\n    let leavesGeometry &#x3D; new THREE.ConeGeometry(1.2, 2.4, 8);\n    let leaves &#x3D; new THREE.Mesh(leavesGeometry, greenMaterial);\n    leaves.position.y &#x3D; 1.6;\n    scene.add(leaves);\n\n    &#x2F;&#x2F; 创建彩灯\n    let lightGeometry &#x3D; new THREE.SphereGeometry(0.1, 4, 4);\n    let lights &#x3D; [];\n    let colors &#x3D; [redMaterial, yellowMaterial, new THREE.MeshBasicMaterial(&#123; color: 0x0000ff &#125;), new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;)];\n    let angles &#x3D; [0, Math.PI &#x2F; 3, 2 * Math.PI &#x2F; 3, Math.PI, 4 * Math.PI &#x2F; 3, 5 * Math.PI &#x2F; 3];\n    for (let i &#x3D; 0; i &lt; angles.length; i++) &#123;\n        let light &#x3D; new THREE.Mesh(lightGeometry, colors[i % 4]);\n        light.position.set(Math.cos(angles[i]) * 0.9, 2.2, Math.sin(angles[i]) * 0.9);\n        scene.add(light);\n        lights.push(light);\n    &#125;\n\n    &#x2F;&#x2F; 创建星星\n    let starGeometry &#x3D; new THREE.SphereGeometry(0.2, 4, 4);\n    let star &#x3D; new THREE.Mesh(starGeometry, yellowMaterial);\n    star.position.y &#x3D; 2.7;\n    scene.add(star);\n\n    &#x2F;&#x2F; 创建礼物盒\n    let giftGeometry &#x3D; new THREE.BoxGeometry(0.5, 0.5, 0.5);\n    let giftMaterials &#x3D; [\n        new THREE.MeshBasicMaterial(&#123; color: 0xff0000 &#125;),\n        new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;),\n        new THREE.MeshBasicMaterial(&#123; color: 0x0000ff &#125;),\n        new THREE.MeshBasicMaterial(&#123; color: 0xffff00 &#125;),\n        new THREE.MeshBasicMaterial(&#123; color: 0xff00ff &#125;),\n        new THREE.MeshBasicMaterial(&#123; color: 0x00ffff &#125;)\n    ];\n    let giftMesh &#x3D; new THREE.Mesh(giftGeometry, giftMaterials);\n    giftMesh.position.set(0, -1.3, 0);\n    scene.add(giftMesh);\n\n    &#x2F;&#x2F; 添加雪花效果\n    let snowFlakeGeometry &#x3D; new THREE.BufferGeometry();\n    let positions &#x3D; [];\n    for (let i &#x3D; 0; i &lt; 1000; i++) &#123;\n        positions.push(Math.random() * 2000 - 1000);\n        positions.push(Math.random() * 2000 - 1000);\n        positions.push(Math.random() * 2000 - 1000);\n    &#125;\n    snowFlakeGeometry.setAttribute(&#39;position&#39;, new THREE.Float32BufferAttribute(positions, 3));\n    let snowFlakeMaterial &#x3D; new THREE.PointsMaterial(&#123; color: 0xffffff, size: 2 &#125;);\n    let snowFlake &#x3D; new THREE.Points(snowFlakeGeometry, snowFlakeMaterial);\n    scene.add(snowFlake);\n    \n\n    &#x2F;&#x2F; 渲染循环\n    function animate() &#123;\n        requestAnimationFrame(animate);\n        trunk.rotation.y +&#x3D; 0.01;\n        leaves.rotation.y +&#x3D; 0.01;\n        for (let i &#x3D; 0; i &lt; lights.length; i++) &#123;\n            lights[i].rotation.y +&#x3D; 0.02;\n        &#125;\n        snowFlake.rotation.y -&#x3D; 0.001;\n        renderer.render(scene, camera);\n    &#125;\n    animate();\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;","slug":"threeJS/圣诞节快到了，用ThreeJS给女朋友写了一个圣诞树，她很开心","date":"2023-12-30T02:46:35.000Z","categories_index":"前端,Three.JS","tags_index":"前端 webGL WEB3d WebGIS","author_index":"前端少年汪"},{"id":"d139f4f2bd842ae73bfb9ae3f3922047","title":"Vue3之状态管理：Vuex和Pinia，孰强孰弱？","content":"\n什么是状态管理在介绍Vuex和Pinia之前，我们有必要先了解一下什么是状态管理。\n在前端开发中，状态管理器是一种用于管理应用程序全局状态的工具。它通常用于大型应用程序，可以帮助开发者更好地组织和管理状态，并提供一些强大的工具来简化状态的变更和使用。\n前端常用的状态管理库以下是几个常见的前端状态管理器：\n\n\n\n\n\n\n\n\n\n\nRedux：Redux 是 React 生态系统中最流行的状态管理库之一。它使用单向数据流、纯函数和不可变数据结构来管理状态。Redux 提供了一个存储所有状态的全局 store，并使用 actions 和 reducers 来修改和处理状态的变更。Redux 还具有强大的工具和插件支持，可以帮助开发者调试和优化应用程序。\n\nMobX：MobX 是一种响应式状态管理库，可以自动追踪状态的变化并触发更新。它提供了一些装饰器和 API，可以将普通的 JavaScript 对象转换为响应式对象，从而实现状态的管理和共享。与 Redux 不同，MobX 的数据流是双向的，允许直接修改状态并触发更新。\n\nVueX：VueX 是 Vue.js 官方提供的状态管理库。它基于 Flux 架构模式，提供了一个中央状态存储器来管理应用程序中的状态。VueX 可以通过 mutations、actions 和 getters 等概念来修改和处理状态的变更，同时具有强大的工具和插件支持。\n\nPinia 是 Vue 的专属状态管理库，它允许你跨组件或页面共享状态。如果你熟悉组合式 API 的话，你可能会认为可以通过一行简单的 export const state = reactive(&#123;&#125;) 来共享一个全局状态。对于单页应用来说确实可以，但如果应用在服务器端渲染，这可能会使你的应用暴露出一些安全漏洞。 而如果使用 Pinia，即使在小型单页应用中，你也可以获得如下功能：\n\nDevtools 支持\n  追踪 actions、mutations 的时间线\n  在组件中展示它们所用到的 Store\n  让调试更容易的 Time travel\n\n\n热更新\n  不必重载页面即可修改 Store\n  开发时可保持当前的 State\n\n\n  插件：可通过插件扩展 Pinia 功能\n  为 JS 开发者提供适当的 TypeScript 支持以及自动补全功能。\n  支持服务端渲染\n\n\n\n无论选择哪种状态管理器，都应该根据项目的需求和特点进行权衡。对于小型应用或组件级别的状态管理，也可以使用一些轻量级的状态管理方案，如 React Hooks 中的 useState、useReducer 等。重要的是要保持状态的一致性和可维护性，以便在应用程序不断变化和扩展时保持代码的清晰和可读性。\n而我们今天要介绍的就是vue生态系统中的Vuex和pinia这两个状态管理器的异同，优劣和应用场景\nVuexvuex这个我相信这个就不用我过多介绍了，凡是用过vue的开发者应该没有不知道这个的，vue3之前一般都是用的vuex这个库作为vue项目的状态管理。\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n目前vuex的最新版本是4.1.0,可以用于vue3的项目，vue2的项目是用vuex 3.x.x的版本。\n要想掌握vuex就必须要了解vuex的5个核心概念：State,Getter,Mutation,Action,Module\nvue的单向数据流状态管理包含以下几个部分：\n\n  状态，驱动应用的数据源；\n  视图，以声明方式将状态映射到视图；\n  操作，响应在视图上的用户输入导致的状态变化。\n\n以下是一个表示“单向数据流”理念的简单示意：简单来说就是数据驱动视图更新，这在单文件组件里面是没有问题的，但是，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏\n\n因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！\n通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。\n\n如何下载安装vuex我就不讨论了，直接去看vuex的官方文档即可。\n主要是看vuex的的用法和功能\n下面是一个简单的 Vuex 示例代码，包括了 State、Getter、Mutation 和 Action 的使用：\n&#x2F;&#x2F; store.js\nimport Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n\nVue.use(Vuex)\n\nconst store &#x3D; new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  getters: &#123;\n    doubleCount: state &#x3D;&gt; state.count * 2\n  &#125;,\n  mutations: &#123;\n    increment: state &#x3D;&gt; state.count++,\n    decrement: state &#x3D;&gt; state.count--\n  &#125;,\n  actions: &#123;\n    asyncIncrement: (&#123; commit &#125;) &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        commit(&#39;increment&#39;)\n      &#125;, 1000)\n    &#125;\n  &#125;\n&#125;)\n\nexport default store\n\n在上述代码中，我们首先引入了 Vue 和 Vuex。然后创建了一个 Store 实例，其中定义了 State、Getter、Mutation 和 Action。\nState 中包含了一个名为 count 的数据，用于统计点击次数。\nGetter 定义了一个名为 doubleCount 的 Getter，用于获取 count 的两倍。\nMutation 定义了两个 Mutation，分别用于增加和减少 count。\nAction 定义了一个名为 asyncIncrement 的 Action，用于异步增加 count。在这个 Action 中，我们通过 setTimeout 来模拟异步操作，并在 1 秒后触发 Increment Mutation。\n最后，我们将 Store 导出，可以在 Vue 组件中通过 this.$store 访问到这个 Store。\n下面是一个简单的组件示例，演示如何在组件中使用 Vuex 状态管理：\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Count: &#123;&#123; count &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;h2&gt;Double Count: &#123;&#123; doubleCount &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;increment&quot;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;decrement&quot;&gt;Decrement&lt;&#x2F;button&gt;\n    &lt;button @click&#x3D;&quot;asyncIncrement&quot;&gt;Async Increment&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  computed: &#123;\n    count() &#123;\n      return this.$store.state.count\n    &#125;,\n    doubleCount() &#123;\n      return this.$store.getters.doubleCount\n    &#125;\n  &#125;,\n  methods: &#123;\n    increment() &#123;\n      this.$store.commit(&#39;increment&#39;)\n    &#125;,\n    decrement() &#123;\n      this.$store.commit(&#39;decrement&#39;)\n    &#125;,\n    asyncIncrement() &#123;\n      this.$store.dispatch(&#39;asyncIncrement&#39;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n在上述代码中，我们通过 computed 属性来获取 State 和 Getter，并通过 methods 属性来触发 Mutation 和 Action。注意，在触发 Mutation 时使用 $store.commit，而在触发 Action 时使用 $store.dispatch。\n使用this.$store.state.count获取vuex中的状态。当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，\n\n&#x2F;&#x2F; 在单独构建的版本中辅助函数为 Vuex.mapState\nimport &#123; mapState &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; ...\n  computed: mapState(&#123;\n    &#x2F;&#x2F; 箭头函数可使代码更简练\n    count: state &#x3D;&gt; state.count,\n\n    &#x2F;&#x2F; 传字符串参数 &#39;count&#39; 等同于 &#96;state &#x3D;&gt; state.count&#96;\n    countAlias: &#39;count&#39;,\n\n    &#x2F;&#x2F; 为了能够使用 &#96;this&#96; 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) &#123;\n      return state.count + this.localCount\n    &#125;\n  &#125;)\n&#125;\n\nGetterVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\nmapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性\nimport &#123; mapGetters &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; ...\n  computed: &#123;\n  &#x2F;&#x2F; 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      &#39;doneTodosCount&#39;,\n      &#39;anotherGetter&#39;,\n      &#x2F;&#x2F; ...\n    ])\n  &#125;\n&#125;\n\nMutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler) 。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数使用mutation修改vuex中的数据有几点需要注意：\n\n使用this.$store.commit\nmutation 必须是同步函数\n\n或者使用 mapMutations辅助函数代替this.$store.commit\nimport &#123; mapMutations &#125; from &#39;vuex&#39;\n\nexport default &#123;\n  &#x2F;&#x2F; ...\n  methods: &#123;\n    ...mapMutations([\n      &#39;increment&#39;, &#x2F;&#x2F; 将 &#96;this.increment()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;\n\n      &#x2F;&#x2F; &#96;mapMutations&#96; 也支持载荷：\n      &#39;incrementBy&#39; &#x2F;&#x2F; 将 &#96;this.incrementBy(amount)&#96; 映射为 &#96;this.$store.commit(&#39;incrementBy&#39;, amount)&#96;\n    ]),\n    ...mapMutations(&#123;\n      add: &#39;increment&#39; &#x2F;&#x2F; 将 &#96;this.add()&#96; 映射为 &#96;this.$store.commit(&#39;increment&#39;)&#96;\n    &#125;)\n  &#125;\n&#125;\n\n\nActionAction 类似于 mutation，不同在于：\n\n  Action 提交的是 mutation，而不是直接变更状态。\n  Action 可以包含任意异步操作。\n\nAction 通过 store.dispatch 方法触发:\nstore.dispatch(&#39;increment&#39;)\nModulesvuex还有一个比较好用的地方就是当store里面的状态多了，就会变得臃肿，这时候就可以用modules可以分模块进行管理Vuex 允许我们将 store 分割成模块（module） 。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割\nconst moduleA &#x3D; &#123;\n  state: () &#x3D;&gt; (&#123; ... &#125;),\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;,\n  getters: &#123; ... &#125;\n&#125;\n\nconst moduleB &#x3D; &#123;\n  state: () &#x3D;&gt; (&#123; ... &#125;),\n  mutations: &#123; ... &#125;,\n  actions: &#123; ... &#125;\n&#125;\n\nconst store &#x3D; new Vuex.Store(&#123;\n  modules: &#123;\n    a: moduleA,\n    b: moduleB\n  &#125;\n&#125;)\n\nstore.state.a &#x2F;&#x2F; -&gt; moduleA 的状态\nstore.state.b &#x2F;&#x2F; -&gt; moduleB 的状态\n\n\n就是类似这种，模块里面还可以嵌套子模块。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。具体的可以去查看vuex的文档\n在 store 创建之后，你可以使用 store.registerModule 方法注册模块：\nimport Vuex from &#39;vuex&#39;\n\nconst store &#x3D; new Vuex.Store(&#123; &#x2F;* 选项 *&#x2F; &#125;)\n\n&#x2F;&#x2F; 注册模块 &#96;myModule&#96;\nstore.registerModule(&#39;myModule&#39;, &#123;\n  &#x2F;&#x2F; ...\n&#125;)\n&#x2F;&#x2F; 注册嵌套模块 &#96;nested&#x2F;myModule&#96;\nstore.registerModule([&#39;nested&#39;, &#39;myModule&#39;], &#123;\n  &#x2F;&#x2F; ...\n&#125;)\n之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。\n以上就vuex的大概内容。是不是比较简单？接下来还有更简单的，那就是Pinia   \nPinia 起始于 2019 年 11 月左右的一次实验，其目的是设计一个拥有组合式 API 的 Vue 状态管理库。\n\npinia的logo是一个菠萝，我也不知道到底是菠萝还是凤梨。我就叫它菠萝吧。\n\n\nstoreStore (如 Pinia) 是一个保存状态和业务逻辑的实体，它并不与你的组件树绑定。换句话说，它承载着全局状态。它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods。\n对比vuex，pinia只有3个核心概念：state,getter,action.是不是要更简单一点了呢。\n那就看看Pinia是怎么来管理全局状态的吧。\nStoreStore 是用 defineStore() 定义的，它的第一个参数要求是一个独一无二的名字\nimport &#123; defineStore &#125; from &#39;pinia&#39;\n\n&#x2F;&#x2F; 你可以对 &#96;defineStore()&#96; 的返回值进行任意命名，但最好使用 store 的名字，同时以 &#96;use&#96; 开头且以 &#96;Store&#96; 结尾。(比如 &#96;useUserStore&#96;，&#96;useCartStore&#96;，&#96;useProductStore&#96;)\n&#x2F;&#x2F; 第一个参数是你的应用中 Store 的唯一 ID。\nexport const useAlertsStore &#x3D; defineStore(&#39;alerts&#39;, &#123;\n  &#x2F;&#x2F; 其他配置...\n&#125;)\n\n这个名字 ，也被用作 id ，是必须传入的， Pinia 将用它来连接 store 和 devtools。为了养成习惯性的用法，将返回的函数命名为 use…  是一个符合组合式函数风格的约定。\ndefineStore() 的第二个参数可接受两类值：Setup 函数或 Option 对象。setup就是组合式API的写法，Option就是选项式API的写法，和vuex的写法差不多\nOption 对象写法export const useCounterStore &#x3D; defineStore(&#39;counter&#39;, &#123;\n  state: () &#x3D;&gt; (&#123; count: 0 &#125;),\n  getters: &#123;\n    double: (state) &#x3D;&gt; state.count * 2,\n  &#125;,\n  actions: &#123;\n    increment() &#123;\n      this.count++\n    &#125;,\n  &#125;,\n&#125;)\nsetup 写法\nexport const useCounterStore &#x3D; defineStore(&#39;counter&#39;, () &#x3D;&gt; &#123;\n  const count &#x3D; ref(0)\n  function increment() &#123;\n    count.value++\n  &#125;\n\n  return &#123; count, increment &#125;\n&#125;)\n\n两种写法都差不多，就看自己喜欢哪个了。\n如何使用store？在组件中，直接导入使用就行\n\n&lt;script setup&gt;\nimport &#123; useCounterStore &#125; from &#39;@&#x2F;stores&#x2F;counter&#39;\n&#x2F;&#x2F; 可以在组件中的任意位置访问 &#96;store&#96; 变量 ✨\nconst store &#x3D; useCounterStore()\n&lt;&#x2F;script&gt;\n为了从 store 中提取属性时保持其响应性，你需要使用 storeToRefs()\n&lt;script setup&gt;\nimport &#123; storeToRefs &#125; from &#39;pinia&#39;\nconst store &#x3D; useCounterStore()\n&#x2F;&#x2F; &#96;name&#96; 和 &#96;doubleCount&#96; 是响应式的 ref\n&#x2F;&#x2F; 同时通过插件添加的属性也会被提取为 ref\n&#x2F;&#x2F; 并且会跳过所有的 action 或非响应式 (不是 ref 或 reactive) 的属性\nconst &#123; name, doubleCount &#125; &#x3D; storeToRefs(store)\n&#x2F;&#x2F; 作为 action 的 increment 可以直接解构\nconst &#123; increment &#125; &#x3D; store\n&lt;&#x2F;script&gt;\n\n\nState对state的操作无非就是访问，重置，变更，替换，订阅\n访问const store &#x3D; useStore(); \nstore.count++;\n重置直接调用reset()方法\nconst store &#x3D; useStore()\n\nstore.$reset()\n\n修改state的值如果只改变一个属性的值，可以直接变更store.count=111\n如果是要同事变更多个值，可以使用store.$patch()方法\nstore.$patch(&#123;\n  count: store.count + 1,\n  age: 120,\n  name: &#39;DIO&#39;,\n&#125;)\n&#x2F;&#x2F;或者\nstore.$patch((state) &#x3D;&gt; &#123; state.items.push(&#123; name: &#39;shoes&#39;, quantity: 1 &#125;) state.hasChanged &#x3D; true &#125;)\n\n替换state你不能完全替换掉 store 的 state，因为那样会破坏其响应性。但是，你可以 patch 它。\n&#x2F;&#x2F; 这实际上并没有替换&#96;$state&#96;\nstore.$state &#x3D; &#123; count: 24 &#125;\n&#x2F;&#x2F; 在它内部调用 &#96;$patch()&#96;：\nstore.$patch(&#123; count: 24 &#125;)\n你也可以通过变更 pinia 实例的 state 来设置整个应用的初始 state。pinia.state.value = &#123;&#125;\n订阅state的变化类似于 Vuex 的 subscribe 方法，你可以通过 store 的 $subscribe() 方法侦听 state 及其变化。比起普通的 watch()，使用 $subscribe() 的好处是 subscriptions 在 patch 后只触发一次\ncartStore.$subscribe((mutation, state) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; import &#123; MutationType &#125; from &#39;pinia&#39;\n  mutation.type &#x2F;&#x2F; &#39;direct&#39; | &#39;patch object&#39; | &#39;patch function&#39;\n  &#x2F;&#x2F; 和 cartStore.$id 一样\n  mutation.storeId &#x2F;&#x2F; &#39;cart&#39;\n  &#x2F;&#x2F; 只有 mutation.type &#x3D;&#x3D;&#x3D; &#39;patch object&#39;的情况下才可用\n  mutation.payload &#x2F;&#x2F; 传递给 cartStore.$patch() 的补丁对象。\n\n  &#x2F;&#x2F; 每当状态发生变化时，将整个 state 持久化到本地存储。\n  localStorage.setItem(&#39;cart&#39;, JSON.stringify(state))\n&#125;)\n\nGetterGetter 完全等同于 store 的 state 的计算值。可以通过 defineStore() 中的 getters 属性来定义它们。推荐使用箭头函数，并且它将接收 state 作为第一个参数\nexport const useStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    count: 0,\n  &#125;),\n  getters: &#123;\n    doubleCount: (state) &#x3D;&gt; state.count * 2,\n  &#125;,\n&#125;)\n可以使用this访问整个store实例。this.doubleCount+1访问其他的getter\nActionAction 相当于组件中的 method。它们可以通过 defineStore() 中的 actions 属性来定义\nexport const useCounterStore &#x3D; defineStore(&#39;main&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    count: 0,\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++\n    &#125;,\n    randomizeCounter() &#123;\n      this.count &#x3D; Math.round(100 * Math.random())\n    &#125;,\n  &#125;,\n&#125;)\n类似 getter，action 也可通过 this 访问整个 store 实例，并支持完整的类型标注(以及自动补全✨) 。不同的是，action 可以是异步的，你可以在它们里面 await 调用任何 API，以及其他 action！下面是一个使用 Mande 的例子。\nimport &#123; mande &#125; from &#39;mande&#39;\n\nconst api &#x3D; mande(&#39;&#x2F;api&#x2F;users&#39;)\n\nexport const useUsers &#x3D; defineStore(&#39;users&#39;, &#123;\n  state: () &#x3D;&gt; (&#123;\n    userData: null,\n    &#x2F;&#x2F; ...\n  &#125;),\n\n  actions: &#123;\n    async registerUser(login, password) &#123;\n      try &#123;\n        this.userData &#x3D; await api.post(&#123; login, password &#125;)\n        showTooltip(&#96;Welcome back $&#123;this.userData.name&#125;!&#96;)\n      &#125; catch (error) &#123;\n        showTooltip(error)\n        &#x2F;&#x2F; 让表单组件显示错误\n        return error\n      &#125;\n    &#125;,\n  &#125;,\n&#125;)\n\n\n\n\nPinia与 Vuex 的比较Pinia 最初是为了探索 Vuex 的下一次迭代会是什么样子，结合了 Vuex 5 核心团队讨论中的许多想法。最终，我们意识到 Pinia 已经实现了我们在 Vuex 5 中想要的大部分内容，并决定实现它 取而代之的是新的建议。\n与 Vuex 相比，Pinia 提供了一个更简单的 API，具有更少的规范，提供了 Composition-API 风格的 API，最重要的是，在与 TypeScript 一起使用时具有可靠的类型推断支持。\nRFC虽然 Vuex 通过 RFC 从社区收集尽可能多的反馈，但 Pinia 没有。 我根据我开发应用程序、阅读其他人的代码、为使用 Pinia 的客户工作以及在 Discord 上回答问题的经验来测试想法。 这使我能够提供一种适用于各种情况和应用程序大小的有效解决方案。 我经常发布并在保持其核心 API 不变的同时使库不断发展。\n与 Vuex 3.x/4.x 的比较\n\n\n\n\n\n\n\n\nVuex 3.x 是 Vuex 的 Vue 2 而 Vuex 4.x 是 Vue 3\nPinia API 与 Vuex ≤4 有很大不同，即：\n\n  mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。\n  无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。\n  不再需要注入、导入函数、调用函数、享受自动完成功能！\n  无需动态添加 Store，默认情况下它们都是动态的，您甚至都不会注意到。请注意，您仍然可以随时手动使用 Store 进行注册，但因为它是自动的，您无需担心。\n  不再有 modules 的嵌套结构。您仍然可以通过在另一个 Store 中导入和 使用 来隐式嵌套 Store，但 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 您甚至可以拥有 Store 的循环依赖关系。\n  没有 命名空间模块。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的。\n\n以上就是vuex和pinia的全部介绍了。我个人觉得如果是vue2或者以前的老项目那就用vuex，如果是vue3的新项目那就用pinia，当然这也不是绝对的，更多的还是要具体情况具体分析的。我个人觉得pinia相比于vuex在使用角度来说，是要更加简洁方便一点的\n\n","slug":"vue/Vue3之状态管理：Vuex和Pinia，孰强孰弱？","date":"2023-03-14T02:46:35.000Z","categories_index":"pinia","tags_index":"pinia vuex","author_index":"前端少年汪"},{"id":"6e4714c942a17b3887506964ab896786","title":"前端常用utils工具方法小总结","content":"\n\n\n\n\n\n\n\n\n前端常用utils工具方法小总结\n\n&#x2F;&#x2F; 数组去重\nconst uniqueArray &#x3D; arr &#x3D;&gt; [...new Set(arr)];\n\n&#x2F;&#x2F; 从url获取参数，并且转换成对象\nconst getParameters &#x3D; URL &#x3D;&gt; JSON.parse(&#96;&#123;&quot;$&#123;decodeURI(URL.split(&quot;?&quot;)[1]).replace(&#x2F;&quot;&#x2F;g, &#39;\\&quot;&#39;).replace(&#x2F;&amp;&#x2F;g, &#39;&quot;,&quot;&#39;).replace(&#x2F;&#x3D;&#x2F;g, &#39;&quot;:&quot;&#39;)&#125;&quot;&#125;&#96;)\n\n&#x2F;&#x2F;检查对象是否为空\nconst isEmpty &#x3D; obj &#x3D;&gt; Reflect.ownKeys(obj).length &#x3D;&#x3D;&#x3D; 0 &amp;&amp; obj.constructor &#x3D;&#x3D;&#x3D; Object\n&#x2F;&#x2F;检查是否为对象\nconst isObject &#x3D; obj &#x3D;&gt; !(Object.keys(obj).length &#x3D;&#x3D;&#x3D; 0)\n\n&#x2F;&#x2F;字符串反转\nconst reverseString &#x3D; str &#x3D;&gt; str.split(&#39;&#39;).reverse().join(&#39;&#39;)\n\n&#x2F;&#x2F;随机生成十六进制颜色值\nconst randomHexColor &#x3D; () &#x3D;&gt; &#96;#$&#123;Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &#39;0&#39;)&#125;&#96;\n\n&#x2F;&#x2F;检查当前选项卡是否在后台\nconst isTabActive &#x3D; () &#x3D;&gt; !document.hidden;\n\n&#x2F;&#x2F;检查元素是否处于焦点\nconst eleIsInFocus &#x3D; el &#x3D;&gt; (el.document.activeElement)\n\n&#x2F;&#x2F;检查设备类型\nconst judgeDeviceType &#x3D; () &#x3D;&gt; &#x2F;Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|OperaMini&#x2F;i.test(navigator.userAgent) ? &#39;Mobile&#39; : &#39;PC&#39;;\n\n&#x2F;&#x2F;文字复制到剪切板\nconst copyText &#x3D; async text &#x3D;&gt; await navigator.clipboard.writeText(text)\n\n&#x2F;&#x2F; 返回选中的内容\nconst getSelectedText &#x3D; () &#x3D;&gt; window.getSelection().toString();\n\n&#x2F;&#x2F;查询某天是否为工作日\nconst isWeekday &#x3D; (date) &#x3D;&gt; date.getDay() % 6 !&#x3D;&#x3D; 0;\n\n&#x2F;&#x2F;两日期之间相差的天数\nconst dayDiff &#x3D; (date1, date2) &#x3D;&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) &#x2F; 86400000);\n\n&#x2F;&#x2F;检查日期是否有效\nconst isDateValid &#x3D; (...val) &#x3D;&gt; !Number.isNaN(new Date(...val).valueOf());\n\n&#x2F;&#x2F; 计算两个日期之间的间隔\nconst dayDif &#x3D; (date1, date2) &#x3D;&gt; Math.ceil(Math.abs(date1.getTime() - date2.getTime()) &#x2F; 86400000)\n\n&#x2F;&#x2F;查找日期位于一年中的第几天\nconst dayOfYear &#x3D; (date) &#x3D;&gt; Math.floor((date - new Date(date.getFullYear(), 0, 0)) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24);\n\n&#x2F;&#x2F;时间格式化\nconst timeFromDate &#x3D; date &#x3D;&gt; date.toTimeString().slice(0, 8);\n\n&#x2F;&#x2F;字符串首字母大小\nconst firstUpper &#x3D; str &#x3D;&gt; str.charAt(0).toUpperCase() + str.slice(1);\n\n&#x2F;&#x2F;随机字符串\nconst randomString &#x3D; () &#x3D;&gt; Math.random().toString(36).slice(2)\n\n&#x2F;&#x2F;去除字符串中的html\nconst striphtml &#x3D; html &#x3D;&gt; html(new DOMParser().parseFromString(html, &#39;text&#x2F;html&#39;).body.textContent || &#39;&#39;)\n\n&#x2F;&#x2F;判断数组是否为空\nconst isNotEmpty &#x3D; array &#x3D;&gt; Array.isArray(array) &amp;&amp; array.length &gt; 0\n\n&#x2F;&#x2F;合并两个数组\nconst merge &#x3D; (a, b) &#x3D;&gt; a.concat(b)\nconst mergeArr &#x3D; (a, b) &#x3D;&gt; [...a, ...b]\n\n&#x2F;&#x2F;获取一组数据的平均值\nconst average &#x3D; (...args) &#x3D;&gt; args.reduce((a, b) &#x3D;&gt; a + b) &#x2F; args.length\n\n&#x2F;&#x2F;取两个整数之间的随机值\nconst randomNumber &#x3D; (min, max) &#x3D;&gt; Math.floor(Math.random() * (max - min + 1) + min)\n\n&#x2F;&#x2F;指定位数的四舍五入\nconst roundNumber &#x3D; (n, d) &#x3D;&gt; Number(Math.round(n + &quot;e&quot; + d) + &#39;e-&#39; + d)\n\n&#x2F;&#x2F;将RGB转化为十六机制\nconst rgbaToHex &#x3D; (r, g, b, a) &#x3D;&gt; &quot;#&quot; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1)\n\n&#x2F;&#x2F;清除所以cookie\nconst clearCookies &#x3D; document.cookie.split(&#39;;&#39;).forEach(cookie &#x3D;&gt; document.cookie &#x3D; cookie.replace(&#x2F;^ +&#x2F;, &#39;&#39;).replace(&#x2F;&#x3D;.*&#x2F;, &#96;&#x3D;;expires&#x3D;$&#123;new Date(0).toUTCString()&#125;;path&#x3D;&#x2F;&#96;));\n\n&#x2F;&#x2F;检测是否是黑暗模式\nconst isDarkMode &#x3D; window.matchMedia &amp;&amp; window.matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches\n\n&#x2F;&#x2F;滚动到顶部\nconst goToTop &#x3D; () &#x3D;&gt; window.screenTop(0, 0)\n\n&#x2F;&#x2F;判断是否滚动到底部\nconst scrolledToBottom &#x3D; () &#x3D;&gt; document.documentElement.clientHeight + window.scrollY &gt;&#x3D; document.documentElement.scrollHeight;\n\n&#x2F;&#x2F;重定向到一个url\nconst redirectToUrl &#x3D; (url) &#x3D;&gt; window.location.href &#x3D; url\n\n&#x2F;&#x2F;打开浏览器的打印页面\nconst showPrintDialog &#x3D; () &#x3D;&gt; window.print()\n\n&#x2F;&#x2F;随机布尔值\nconst randomBoolean &#x3D; () &#x3D;&gt; Math.random() &gt;&#x3D; 0.5\n\n&#x2F;&#x2F;变量交换\nlet a &#x3D; 1, b &#x3D; 2;\n[a, b] &#x3D; [b, a]\n\n&#x2F;&#x2F;获取变量的类型\nconst trueTypeOf &#x3D; (obj) &#x3D;&gt; Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n\n\n\n防抖定义：n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效\n&#x2F;&#x2F;处理任务，和等待时间\nfunction debounce(fn, delay)&#123;\n     let timerId &#x3D; null\n     return function()&#123;\n         const context &#x3D; this\n         &#x2F;&#x2F;如果接到订单就再等3分钟\n         if(timerId)&#123;window.clearTimeout(timerId)&#125;\n         &#x2F;&#x2F;3分钟没有接到订单就直接配送\n         timerId &#x3D; setTimeout(()&#x3D;&gt;&#123;\n             fn.apply(context, arguments)\n             timerId &#x3D; null\n         &#125;,delay)\n     &#125;\n &#125;\n\n\n节流定义：n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时\n\n\n\n\n\n\n\n\n\n节流就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率\nexport const debouncer &#x3D; (fn, time, interval &#x3D; 200) &#x3D;&gt; &#123;\n  if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;\n    fn &amp;&amp; fn();\n    window.debounceTimestamp &#x3D; time;\n  &#125;\n&#125;\n\nfunction throttle(fn, delay)&#123;\n     &#x2F;&#x2F; 设置一个触发开关\n     let canUse &#x3D; true\n     return function()&#123;\n     &#x2F;&#x2F;如果为true，就触发技能，否则就不能触发\n         if(canUse)&#123;\n             fn.apply(this, arguments)\n             &#x2F;&#x2F;触发技能后，关闭开关\n             canUse &#x3D; false\n             &#x2F;&#x2F;在3秒后打开开关\n             setTimeout(()&#x3D;&gt;canUse &#x3D; true, delay)\n         &#125;\n     &#125;\n &#125;\n\n\ncookie工具方法设置cookie\nfunction setCookieItem(sKey, sValue, vEnd, sPath, sDomain, bSecure) &#123;\n    if (!sKey || &#x2F;^(?:expires|max-age|path|domain|secure)$&#x2F;i.test(sKey)) &#123;\n        return false;\n    &#125;\n    var sExpires &#x3D; &quot;&quot;;\n    if (vEnd) &#123;\n        switch (vEnd.constructor) &#123;\n            case Number:\n                sExpires &#x3D; vEnd &#x3D;&#x3D;&#x3D; Infinity \n                    ? &quot;; expires&#x3D;Fri, 31 Dec 9999 23:59:59 GMT&quot; \n                  : &quot;; max-age&#x3D;&quot; + vEnd;\n                break;\n            case String:\n                sExpires &#x3D; &quot;; expires&#x3D;&quot; + vEnd;\n                break;\n            case Date:\n                sExpires &#x3D; &quot;; expires&#x3D;&quot; + vEnd.toUTCString();\n                break;\n        &#125;\n    &#125;\n    document.cookie &#x3D; encodeURIComponent(sKey) \n        + &quot;&#x3D;&quot; + encodeURIComponent(sValue) \n        + sExpires \n        + (sDomain ? &quot;; domain&#x3D;&quot; + sDomain : &quot;&quot;) \n        + (sPath ? &quot;; path&#x3D;&quot; + sPath : &quot;&quot;) \n        + (bSecure ? &quot;; secure&quot; : &quot;&quot;);\n    return true;\n&#125;\n\n判断cookie是否存在\nfunction isCookieItemExisted(sKey) &#123;\n    return new RegExp(&quot;(?:^|;\\s*)&quot; + encodeURIComponent(sKey).replace(&#x2F;[-.+*]&#x2F;g, &quot;\\$&amp;&quot;) + &quot;\\s*\\&#x3D;&quot;).test(document.cookie);\n&#125;\n\n删除cookie\nfunction removeCookieItem(sKey, sPath, sDomain) &#123;\n    if (!sKey || !isCookieItemExisted(sKey)) &#123;\n        return false;\n    &#125;\n    document.cookie &#x3D; encodeURIComponent(sKey) \n        + &quot;&#x3D;; expires&#x3D;Thu, 01 Jan 1970 00:00:00 GMT&quot; \n        + (sDomain ? &quot;; domain&#x3D;&quot; + sDomain : &quot;&quot;) \n        + (sPath ? &quot;; path&#x3D;&quot; + sPath : &quot;&quot;);\n    return true;\n&#125;\n\n查找cookie\nfunction getCookieByKey(sKey) &#123;\n    return decodeURIComponent(document.cookie.replace(new RegExp(&quot;(?:(?:^|.*;)\\s*&quot; + encodeURIComponent(sKey).replace(&#x2F;[-.+*]&#x2F;g, &quot;\\$&amp;&quot;) + &quot;\\s*\\&#x3D;\\s*([^;]*).*$)|^.*$&quot;), &quot;$1&quot;)) || null;\n  &#125;,\n\nlocalhostStorage工具方法设置localStorage\nexport const setStore &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    let &#123;\n        name,\n        content,\n        type,\n    &#125; &#x3D; params;\n    name &#x3D; keyName + name\n    let obj &#x3D; &#123;\n        dataType: typeof (content),\n        content: content,\n        type: type,\n        datetime: new Date().getTime()\n    &#125;\n    if (type) window.sessionStorage.setItem(name, JSON.stringify(obj));\n    else window.localStorage.setItem(name, JSON.stringify(obj));\n&#125;\n\n获取localStorage\nexport const getStore &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    let &#123;\n        name,\n        debug\n    &#125; &#x3D; params;\n    name &#x3D; keyName + name\n    let obj &#x3D; &#123;&#125;,\n        content;\n    obj &#x3D; window.sessionStorage.getItem(name);\n    if (validatenull(obj)) obj &#x3D; window.localStorage.getItem(name);\n    if (validatenull(obj)) return;\n    try &#123;\n        obj &#x3D; JSON.parse(obj);\n    &#125; catch &#123;\n        return obj;\n    &#125;\n    if (debug) &#123;\n        return obj;\n    &#125;\n    if (obj.dataType &#x3D;&#x3D; &#39;string&#39;) &#123;\n        content &#x3D; obj.content;\n    &#125; else if (obj.dataType &#x3D;&#x3D; &#39;number&#39;) &#123;\n        content &#x3D; Number(obj.content);\n    &#125; else if (obj.dataType &#x3D;&#x3D; &#39;boolean&#39;) &#123;\n        content &#x3D; eval(obj.content);\n    &#125; else if (obj.dataType &#x3D;&#x3D; &#39;object&#39;) &#123;\n        content &#x3D; obj.content;\n    &#125;\n    return content;\n&#125;\n\n\n删除localStorage\nexport const removeStore &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    let &#123;\n        name,\n        type\n    &#125; &#x3D; params;\n    name &#x3D; keyName + name\n    if (type) &#123;\n        window.sessionStorage.removeItem(name);\n    &#125; else &#123;\n        window.localStorage.removeItem(name);\n    &#125;\n&#125;\n\n\n获取全部local Storage\nexport const getAllStore &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    let list &#x3D; [];\n    let &#123;\n        type\n    &#125; &#x3D; params;\n    if (type) &#123;\n        for (let i &#x3D; 0; i &lt;&#x3D; window.sessionStorage.length; i++) &#123;\n            list.push(&#123;\n                name: window.sessionStorage.key(i),\n                content: getStore(&#123;\n                    name: window.sessionStorage.key(i),\n                    type: &#39;session&#39;\n                &#125;)\n            &#125;)\n        &#125;\n    &#125; else &#123;\n        for (let i &#x3D; 0; i &lt;&#x3D; window.localStorage.length; i++) &#123;\n            list.push(&#123;\n                name: window.localStorage.key(i),\n                content: getStore(&#123;\n                    name: window.localStorage.key(i),\n                &#125;)\n            &#125;)\n        &#125;\n    &#125;\n    return list;\n&#125;\n\n清空全部local Storage\nexport const clearStore &#x3D; (params &#x3D; &#123;&#125;) &#x3D;&gt; &#123;\n    let &#123;\n        type\n    &#125; &#x3D; params;\n    if (type) &#123;\n        window.sessionStorage.clear();\n    &#125; else &#123;\n        window.localStorage.clear()\n    &#125;\n&#125;\n\n时间转换function getdate(date) &#123;\n    var now &#x3D; new Date(date),\n        y &#x3D; now.getFullYear(),\n        m &#x3D; now.getMonth() + 1,\n        d &#x3D; now.getDate();\n    return y + &#39;-&#39; + (m &lt; 10 ? &#39;0&#39; + m : m) + &#39;-&#39; + (d &lt; 10 ? &#39;0&#39; + d : d) + &#39; &#39; + now.toTimeString().substr(0, 8);\n&#125;","slug":"js/前端常用utils工具方法小总结","date":"2024-04-17T02:46:35.000Z","categories_index":"前端","tags_index":"工具方法","author_index":"前端少年汪"},{"id":"e7d4321320711fd3eb23409ba53d32b8","title":"Three.js深入浅出：4-three.js中的光源","content":"序言：\n\n\n\n\n\n\n\n\n在现代互联网时代，Web 技术的快速发展使得 Web 开发领域日新月异。随着互联网内容变得越来越丰富、复杂，用户对于网页和应用程序的交互性和视觉效果提出了更高的要求。在这样的背景下，基于 WebGL 的 3D 图形技术越来越受到关注和重视。\n而在众多的 3D 图形库中，Three.js 作为一款优秀的 JavaScript 3D 图形库，受到了广泛的欢迎和应用。无论是创建引人入胜的交互式 3D 场景、还是打造惊艳的虚拟现实体验，Three.js 都展现出了强大的潜力和灵活性。\n本系列文章将深入探讨 Three.js，从基础入门到高级应用，带领读者逐步掌握 Three.js 的核心概念和技术要点。我们将从搭建基本的 3D 场景开始，逐步引入光影、材质、纹理、动画等概念，让读者能够系统地掌握 Three.js 的开发技巧和实践经验。\n通过本系列文章的学习，读者将能够掌握使用 Three.js 创建精美的 3D 可视化效果，以及实现交互式的虚拟场景的能力。无论是 Web 开发工程师、还是对 3D 图形技术感兴趣的爱好者，都能够从中受益匪浅。\n让我们一起踏上 Three.js 的学习之旅，探索无限的创意可能性，开启属于自己的 3D 时代！ 欢迎各位小伙伴们多多关注，你的点赞和评论是我写作的动力！\n本篇文章将带你深入了解Three.js中的光源类型、属性和使用方法，助你在创建虚拟世界时获得更加生动逼真的效果\n1. Three.js中的光源类型\n   1.1 环境光(Ambient Light)\n   1.2 平行光(Directional Light)\n   1.3 点光源(Point Light)\n   1.4 聚光灯(Spotlight)\n   1.5 区域光(Area Light)\n\n\n\n\n\n\n\n\n\n\n当使用Three.js中的光源类型时，每种光源具有不同的属性和功能，下面对每种光源进行更详细的解释：\n1.1 环境光(Ambient Light)\n\n\n\n\n\n\n\n\n环境光是一种全局光源，它会均匀地照亮整个场景，不考虑物体的位置和方向。环境光没有明确定义的位置，也不会产生阴影效果。您可以设置环境光的颜色和强度来控制整个场景的整体亮度和色彩。\n1.2 平行光(Directional Light)\n\n\n\n\n\n\n\n\n平行光是一种具有指定方向的光源，类似于太阳光。平行光的光线是平行的，不会随距离的增加而发散。平行光可以产生明显的阴影效果，并常用于模拟室外自然光。您可以设置平行光的颜色、强度和方向来调整光照的效果。\n1.3 点光源(Point Light)\n\n\n\n\n\n\n\n\n点光源是一种向所有方向发射光线的光源，类似于灯泡。点光源的光线衰减程度随着距离的增加而减弱，即远离光源的物体会受到较少的光照。点光源可以产生明显的阴影效果，并常用于模拟人造光源，如室内灯光。您可以设置点光源的颜色、强度和位置来控制光照的效果。\n1.4 聚光灯(Spotlight)\n\n\n\n\n\n\n\n\n聚光灯是一种具有方向性的光源，可以产生锥形光照射效果。聚光灯具有发光点、方向和发散角度等属性。发光点决定了聚光灯的位置，方向控制了光线的传播方向，而发散角度决定了聚光灯的光锥大小。聚光灯可以产生明显的阴影效果，并常用于突出特定物体或区域。此外，聚光灯还可以设置光锥的衰减范围和光锥外的阴影效果。\n1.5 区域光(Area Light)\n\n\n\n\n\n\n\n\n区域光是一种基于面积的光源，可以产生柔和的阴影效果。区域光通常用于模拟大型光源，例如天窗或墙壁。区域光的形状可以是矩形或圆形，并且具有位置、法线和颜色等属性。区域光会通过面的面积和法线方向来决定光的强度和照射角度，从而产生柔和的环境光照射效果。\n通过使用这些不同类型的光源，您可以根据场景的需求模拟各种不同的光照效果，使得渲染出的场景更加真实、细腻。您可以设置光源的属性，如颜色、强度、位置、方向和角度等，以及阴影的开启和关闭，来实现所需的光照效果。\n&#x2F;&#x2F; 创建环境光\nconst ambientLight &#x3D; new THREE.AmbientLight(0xffffff, 0.5);\n\n&#x2F;&#x2F; 创建平行光\nconst directionalLight &#x3D; new THREE.DirectionalLight(0xffffff, 1);\n\n&#x2F;&#x2F; 创建点光源\nconst pointLight &#x3D; new THREE.PointLight(0xffffff, 1, 100);\n\n&#x2F;&#x2F; 创建聚光灯\nconst spotLight &#x3D; new THREE.SpotLight(0xffffff, 1);\n\n&#x2F;&#x2F; 创建区域光\nconst areaLight &#x3D; new THREE.RectAreaLight(0xffffff, 1, 4, 4);\n\n\n2. 光源属性及其影响\n   2.1 光的颜色和强度\n   2.2 光的位置和方向\n   2.3 光的衰减和阴影\n 2.4 光的投射和接收 在Three.js中，光源的属性会对场景中的物体产生不同的影响。以下是光源属性及其影响的详细解释：\n\n2.1 光的颜色和强度\n\n\n\n\n\n\n\n\n光的颜色和强度是控制光源发出的光线的两个主要属性。光的颜色决定了场景中物体受到的光线的颜色，而光的强度决定了光线的亮度。增加光的强度可以使物体更明亮，而减小光的强度则会使物体变暗。通过调整光的颜色和强度，您可以创造出不同的光照效果，如自然光或彩色灯光。\n2.2 光的位置和方向\n\n\n\n\n\n\n\n\n光的位置和方向决定了光线的传播方式。对于平行光和点光源，您可以设置它们的位置来控制光线的发射方向。通过调整光源的位置，您可以模拟光线从不同角度或位置照射到物体上的效果。聚光灯也具有方向属性，您可以将其指向特定的位置，并通过调整方向来控制光锥的投射方向。\n2.3 光的衰减和阴影\n\n\n\n\n\n\n\n\n光的衰减和阴影属性可以影响光线的传播和物体的投影效果。衰减是指光线随着距离的增加逐渐减弱的过程。您可以设置光源的衰减系数来调整光线的衰减程度，从而影响物体受到的光照强度。阴影属性可以使光源产生阴影效果，实现物体之间的遮挡关系。通过打开阴影属性，您可以在场景中模拟出真实的阴影效果，增强物体的立体感。\n2.4 光的投射和接收\n\n\n\n\n\n\n\n\n光的投射和接收属性决定了物体能否投射或接收光线。通过设置物体的投射属性，您可以使光源照射到该物体上并产生阴影效果。而设置物体的接收属性，则可以使该物体受到其他光源的照射，并影响其表面的颜色和明暗程度。通过控制物体的投射和接收属性，您可以实现物体之间的相互作用和光照效果。\n通过调整光源的属性，如颜色、强度、位置、方向、衰减和阴影等，以及物体的投射和接收属性，您可以创造出各种不同的光照效果，使得渲染出的场景更加真实、生动。\n\n&lt;script type&#x3D;&quot;module&quot;&gt;\n  &#x2F;&#x2F; 现在浏览器支持ES6语法，自然包括import方式引入js文件\n  import * as THREE from &#39;.&#x2F;node_modules&#x2F;three&#x2F;src&#x2F;Three.js&#39;;\n\n  &#x2F;&#x2F; 创建场景\n  let scene &#x3D; new THREE.Scene();\n \n\n  &#x2F;&#x2F; 创建平行光源\n  let directionalLight &#x3D; new THREE.DirectionalLight(0xffffff, 1); &#x2F;&#x2F; 颜色为白色，强度为1\n  directionalLight.position.set(1, 1, 1); &#x2F;&#x2F; 设置光源位置\n  scene.add(directionalLight);\n\n  &#x2F;&#x2F; 创建点光源\n  let pointLight &#x3D; new THREE.PointLight(0xff0000, 1, 10); &#x2F;&#x2F; 颜色为红色，强度为1，距离为10\n  pointLight.position.set(0, 3, 0); &#x2F;&#x2F; 设置光源位置\n  scene.add(pointLight);\n\n  &#x2F;&#x2F; 创建立方体并设置材质\n  let geometry &#x3D; new THREE.BoxGeometry(1, 1, 1);\n  let material &#x3D; new THREE.MeshPhongMaterial(&#123; color: 0x00ff00 &#125;); &#x2F;&#x2F; 设置立方体的颜色\n  let cube &#x3D; new THREE.Mesh(geometry, material);\n  scene.add(cube);\n\n  &#x2F;&#x2F; 创建渲染器并设置大小\n  let renderer &#x3D; new THREE.WebGLRenderer();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  document.body.appendChild(renderer.domElement);\n\n  &#x2F;&#x2F; 创建相机并设置位置\n  let camera &#x3D; new THREE.PerspectiveCamera(45, window.innerWidth &#x2F; window.innerHeight, 1, 1000);\n  camera.position.set(0, 0, 5);\n\n  &#x2F;&#x2F; 渲染场景\n  function render() &#123;\n    requestAnimationFrame(render);\n    cube.rotation.x +&#x3D; 0.01; &#x2F;&#x2F; 使立方体旋转\n    cube.rotation.y +&#x3D; 0.01;\n    renderer.render(scene, camera);\n  &#125;\n  render();\n  \n&lt;&#x2F;script&gt;\n\n\n\n3. Three.js中的光源使用方法\n   3.1 创建光源对象\n   3.2 将光源添加到场景中\n   3.3 调整光源属性和位置\n   3.4 渲染场景并观察光照效果\n\n3.1 创建光源对象：&#x2F;&#x2F; 创建平行光源\nvar directionalLight &#x3D; new THREE.DirectionalLight(0xffffff, 1); &#x2F;&#x2F; 颜色为白色，强度为1\n\n&#x2F;&#x2F; 创建点光源\nvar pointLight &#x3D; new THREE.PointLight(0xff0000, 1, 10); &#x2F;&#x2F; 颜色为红色，强度为1，距离为10\n\n3.2 将光源添加到场景中：scene.add(directionalLight); &#x2F;&#x2F; 将平行光源添加到场景中\nscene.add(pointLight); &#x2F;&#x2F; 将点光源添加到场景中\n\n3.3 调整光源属性和位置：directionalLight.position.set(1, 1, 1); &#x2F;&#x2F; 设置平行光源位置\npointLight.position.set(0, 3, 0); &#x2F;&#x2F; 设置点光源位置\n\n3.4 渲染场景并观察光照效果：&#x2F;&#x2F; 创建渲染器并设置大小\nvar renderer &#x3D; new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n\n&#x2F;&#x2F; 创建相机并设置位置\nvar camera &#x3D; new THREE.PerspectiveCamera(45, window.innerWidth &#x2F; window.innerHeight, 1, 1000);\ncamera.position.set(0, 0, 5);\n\n&#x2F;&#x2F; 渲染场景\nfunction render() &#123;\n  requestAnimationFrame(render);\n  renderer.render(scene, camera);\n&#125;\nrender();\n\n通过以上步骤，可以在Three.js中创建光源，并将其应用到场景中的物体上，然后调整光源的属性和位置，最终渲染场景并观察光照效果。\n\n4. 我的最佳实践和性能优化\n   4.1 合理选择光源类型\n   4.2 控制光源数量和强度\n   4.3 使用阴影技术增强真实感\n 4.4 考虑移动设备的性能限制\n\n4.1 合理选择光源类型：   根据场景需求合理选择光源类型，如平行光、点光源、聚光灯等。不同类型的光源会对渲染性能产生不同的影响，需根据具体情况进行选择。\n   平行光源可以模拟太阳光，适用于大范围照射场景。点光源可以模拟灯泡等局部照明，适用于小范围照射场景。聚光灯可以模拟手电筒等具有方向性的光源，适用于需要强调某个区域的场景。\n4.2 控制光源数量和强度：   控制光源的数量和强度，过多的光源会增加渲染负担，影响性能。合理使用光源并控制其强度可以提高渲染效率。\n   过多的光源会导致场景中需要渲染更多的阴影和高光，从而增加渲染成本，影响性能。因此，在使用光源时，需要权衡渲染效果和性能，并控制光源的数量和强度。\n4.3 使用阴影技术增强真实感： 当需要增强场景的真实感时，可以考虑使用阴影技术。然而，阴影技术会增加渲染开销，因此需要谨慎使用，并根据性能需求进行调整。\n   阴影技术可以让物体的投影产生更真实的效果，增强场景的真实感。但是，使用阴影技术会增加渲染开销，如果需要在性能有限的设备上运行，可能需要关闭阴影或采用简化的阴影技术。\n4.4 考虑移动设备的性能限制： 如果目标是在移动设备上运行，需要特别关注性能限制。移动设备的硬件性能通常比桌面设备低，因此需要针对移动设备进行性能优化，例如减少光源数量、简化模型细节等。\n   移动设备的硬件性能相对较低，因此需要注意性能优化。可以通过减少光源数量、简化模型细节、使用纹理压缩等方法来提高性能。此外，还需要测试和优化场景的性能，并针对移动设备进行适当的调整。\n通过遵循上述最佳实践和性能优化建议，可以有效提高Three.js应用的性能和用户体验。当然，实际应用中还需要根据具体场景和需求做出适当调整。\n\n结论通过本篇文章，已经了解了Three.js中不同类型的光源、光源属性的影响以及如何使用它们来创建逼真的光照效果。合理地设置和调整光源可以让3D场景更加生动、真实，并且在性能优化方面也有所收获。 \n","slug":"threeJS/Three.js深入浅出：4-three.js中的光源","date":"2023-12-19T14:46:35.000Z","categories_index":"three.js","tags_index":"前端 webGL three.js","author_index":"前端少年汪"},{"id":"d691526bb195b63b807c15eb0d89f9b5","title":"Scrapy爬虫初探","content":"认识ScrapyScrapy 是一个开源的、高级的、快速的 Python 网络爬虫框架，用于从网站上提取数据。它提供了一种简单而强大的方式来定义爬取规则和处理爬取的数据。其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。\n下面的架构图明确说明了 Scrapy 主要有 5 个部分。\n\n引擎(Scrapy Engine)：引擎负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。\n\n管道(Pipline)：主要提供存储服务，把需要存储的数据存储到相关数据库之中。\n\n调度器(Scheduler)：主要提供两个功能，分别是去重和队列。\n\n下载器(Downloader)：下载器负责获取页面数据并提供给引擎，而后提供给spider。\n\n爬虫(Spiders)：Spider是Scrapy用户编写用于分析response并提取item(即获取到的item)或额外跟进的URL的类。每个spider负责处理一个特定(或一些)网站。\n\n\n其实除了上述的内容外，Scrapy 还提供一些中间件，例如：下载器中间件(Downloader Middlewares)和爬虫中间件(Spider Middlewares)。\n所以，把上面完整的图可以画成如下：\n\n以下是 Scrapy 的一些主要特点和优势：\n\n快速高效：Scrapy 使用异步网络库并支持并发请求处理，使得爬取速度非常快。\n可扩展性：Scrapy 的架构设计非常灵活和可扩展，你可以根据需要编写自定义的中间件、管道和扩展。\n方便的选择器：Scrapy 内置了强大的选择器（XPath 和 CSS）来提取所需的数据，使得数据提取变得非常简便。\n自动的请求管理：Scrapy 能够自动管理请求的发送和处理，包括请求的调度、跟踪和优先级处理，以及失败重试等。\n数据流处理：Scrapy 提供了一个灵活的管道系统，可以对爬取到的数据进行处理和存储，例如存储在数据库中或输出为不同格式的文件。\n内置的调试工具：Scrapy 提供了有用的调试工具，如 Shell 和 Spider View，帮助开发者调试和测试爬虫程序。\n支持分布式爬取：Scrapy 可以与分布式消息队列（如 Redis）集成，实现分布式爬取，提高爬取效率和可扩展性。\n\n使用 Scrapy 可以轻松地创建一个完整的爬虫程序。你可以定义一个或多个爬虫文件，每个文件负责从特定的网站爬取数据，并定义数据提取规则。然后，通过运行 Scrapy 命令来启动爬虫并开始爬取。Scrapy 会自动处理请求、跟踪链接、提取数据并将其传递给管道进行处理。\n总之，Scrapy 是一个功能强大且灵活的网络爬虫框架，适用于各种规模的爬取任务。它提供了许多有用的功能和工具，帮助开发者以高效的方式从网站上抓取数据。无论是简单的数据采集还是复杂的网站抓取，Scrapy 都是一个值得考虑的选择。\n创建虚拟环境\n打开命令行或终端。\n\n使用以下命令在当前目录创建一个名为 “myenv” 的虚拟环境（你也可以将 “myenv” 替换为你喜欢的名称）：\npython -m venv myenv\n激活虚拟环境：\n\n在 Windows 上，执行以下命令：myenv\\Scripts\\activate\n在 macOS 和 Linux 上，执行以下命令：source myenv&#x2F;bin&#x2F;activate\n\n\n\n安装 Scrapy\n激活虚拟环境后，你会发现命令行提示符发生了变化，表明虚拟环境已经激活。\n在激活的虚拟环境中，使用以下命令安装 Scrapy：pip install scrapy\n\n这样就完成了在 Python 中创建虚拟环境并安装 Scrapy 的过程。现在你可以在虚拟环境中使用 Scrapy 来进行网络爬虫的开发和相关工作了。\n要创建一个 Scrapy 项目，请按照以下步骤进行操作：\n\n打开命令行或终端。\n\n进入你想要创建项目的目录。例如，如果你想在桌面上创建项目，可以执行以下命令（根据你自己的文件路径进行修改）：\ncd Desktop\n在目标目录中，使用以下命令创建 Scrapy 项目。将 “project_name” 替换为你想要的项目名称：\nscrapy startproject project_name\n创建项目后，进入项目目录：\ncd project_name\n该命令将会创建包含下列内容的 project_name 目录:\n\n\nproject_name&#x2F;\n    scrapy.cfg\n    tutorial&#x2F;\n        __init__.py\n        items.py\n        pipelines.py\n        settings.py\n        spiders&#x2F;\n            __init__.py\n            ...\n\n这些文件分别是:\n\n  scrapy.cfg: 项目的配置文件\n  project_name/: 该项目的python模块。之后您将在此加入代码。\n  project_name/items.py: 项目中的item文件.\n  project_name/pipelines.py: 项目中的pipelines文件.\n  project_name/settings.py: 项目的设置文件.\n  project_name/spiders/: 放置spider代码的目录.\n\n\n现在，你可以开始编写和配置你的 Scrapy 爬虫了。Scrapy 项目的主要部分是爬虫，可以在项目的 spiders 目录中创建爬虫文件。例如，可以执行以下命令创建一个名为 “example_spider” 的爬虫：\nscrapy genspider example_spider example.com\n\n这将在 spiders 目录中创建一个名为 “example_spider.py” 的文件，并使用 “example.com” 作为起始网址。\n\n\n定义item类import scrapy\n\n\nclass TutorialItem(scrapy.Item):\n    # define the fields for your item here like:\n    # name &#x3D; scrapy.Field()\n    title &#x3D; scrapy.Field()\n    link &#x3D; scrapy.Field()\n    desc &#x3D; scrapy.Field()\n\n\n这段代码是一个使用 Scrapy 框架编写的爬虫项目中的 Item 类定义。\n\n首先，导入了 scrapy 模块，这是 Scrapy 框架的核心模块。\n\n接下来，定义了一个名为 TutorialItem 的类，该类继承自 Scrapy 框架提供的 Item 类。\n\n在 TutorialItem 类中，定义了三个字段（Field）：\n\ntitle：用于存储抓取到的网页标题信息。\nlink：用于存储抓取到的网页链接地址。\ndesc：用于存储抓取到的网页描述信息。\n\n\n\n这段代码的作用是定义了一个 Item 类，用于存储爬取到的数据。在 Scrapy 中，Item 类似于数据模型，用于定义要抓取的数据结构。当爬虫解析网页并提取出需要的数据时，可以实例化该 Item 类并将数据存储到对应的字段中，以便后续处理和持久化。\n在实际编写爬虫时，你通常需要根据具体的需求自定义 Item 类，并根据需要添加更多的字段来存储抓取到的\n创建爬虫import scrapy\n\n\nclass ExampleSpiderSpider(scrapy.Spider):\n    name &#x3D; &quot;example_spider&quot;\n    allowed_domains &#x3D; [&quot;example.com&quot;]\n    start_urls &#x3D; [&quot;https:&#x2F;&#x2F;example.com&quot;]\n\n    def parse(self, response):\n        print(response,&#39;wmq&#39;)\n\n\n这段代码是一个使用 Scrapy 框架编写的简单的爬虫（Spider）。\n\n  首先，导入了 scrapy 模块，这是 Scrapy 框架的核心模块。\n\n  接下来，定义了一个名为 ExampleSpiderSpider 的 Spider 类，该类继承自 Scrapy 框架提供的 Spider 类。\n\n在 ExampleSpiderSpider 类中，定义了以下几个属性：\n\n  name：指定爬虫的名称为 “example_spider”。\n  allowed_domains：指定允许爬取的域名为 “example.com“。这意味着爬虫只会爬取该域名下的网页。\n  start_urls：指定起始的 URL 列表为 [“https://example.com“]。这是爬虫开始爬取的起点。\n\n\n  最后，定义了一个名为 parse 的方法，这是 Scrapy 框架中用于解析网页响应的默认方法。在这个方法中，通过打印输出了响应对象 response 和字符串 “wmq”。\n\n\n这段代码的作用是创建一个爬虫，从 “https://example.com“ 这个网页开始抓取数据，并在解析网页响应时打印输出相应的信息。\nimport scrapy\n\nclass QuotesSpider(scrapy.Spider):\n    name &#x3D; &quot;wall&quot;  # 定义爬虫的名称\n\n    def start_requests(self):\n        # 定义起始的 URL 列表\n        urls &#x3D; [\n            &#39;https:&#x2F;&#x2F;quotes.toscrape.com&#x2F;page&#x2F;1&#x2F;&#39;,\n            &#39;https:&#x2F;&#x2F;quotes.toscrape.com&#x2F;page&#x2F;2&#x2F;&#39;,\n            &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#39;,\n        ]\n        for url in urls:\n            # 对于每个 URL，创建一个 Scrapy 请求，并指定回调函数为 self.parse\n            yield scrapy.Request(url&#x3D;url, callback&#x3D;self.parse)\n\n    def parse(self, response):\n        # 解析页面内容的回调函数\n        page &#x3D; response.url.split(&quot;&#x2F;&quot;)[-2]  # 从 URL 中提取页面编号\n        filename &#x3D; f&#39;quotes-&#123;page&#125;.html&#39;  # 根据页面编号构造文件名\n        with open(filename, &#39;wb&#39;) as f:  # 以二进制写入模式打开文件\n            f.write(response.body)  # 将页面内容写入文件\n        self.log(f&#39;Saved file &#123;filename&#125;&#39;)  # 记录日志，表示文件保存成功\n\n\n运行爬虫：\nscrapy  crawl wall\nwall 为爬虫中定义的name name = &quot;wall&quot;  # 定义爬虫的名称\n\n\n以上就是运行爬虫之后输出的内容了我这里保存为两个html文件了\n\n拿到了html网页下面就可以根据自己的需要去解析和清洗数据或者保存到数据库了。本篇就到此为止，下一篇介绍如何使用xpath和bs4来获取自己想要的数据\n","slug":"python/Scrapy爬虫初探","date":"2023-12-04T14:46:35.000Z","categories_index":"技术,爬虫,Scrapy","tags_index":"python 爬虫","author_index":"前端少年汪"},{"id":"27b92f13741f11c774ff04ddfacad943","title":"一文了解TCP,IP协议和一个超好用的IP代理","content":"前言在当今互联网时代，TCP/IP协议无疑是计算机网络中最为重要和广泛应用的协议之一。作为网络通信的基石，TCP/IP协议的设计与实现对于理解网络通信、构建网络应用具有至关重要的意义。本文将深入探讨TCP/IP协议的原理、架构和功能，并探索其在实际应用中的重要性。\nIP代理\n\n\n\n\n\n\n\n\nIP代理（Proxy）是一种网络服务，允许用户通过代理服务器进行网络通信。代理服务器作为中间人，接收用户发出的请求，并代表用户与目标服务器进行通信。在这个过程中，代理服务器会隐藏用户的真实IP地址，使得用户的身份和位置信息得以保护。\nIP代理的主要功能包括以下几个方面：\n\n 隐藏真实IP地址：使用IP代理可以隐藏用户的真实IP地址，代理服务器会替用户向目标服务器发送请求，从而保护用户的隐私和匿名性。\n 改变地理位置：IP代理可以模拟不同地理位置的IP地址，使得用户可以访问被地理限制的内容或服务。例如，某些网站可能根据用户的IP地址限制访问，使用IP代理可以绕过这些限制。\n 加速访问速度：有些IP代理服务器提供缓存功能，可以存储常用的网页内容，当多个用户请求同一网页时，代理服务器可以直接返回缓存中的内容，提高访问速度。\n 突破网络封锁：在一些国家或地区，政府可能对特定网站或服务进行封锁，使用IP代理可以绕过这些封锁，访问被屏蔽的内容。\n\n\n\n\n\n\n\n\n\n\n值得注意的是，使用IP代理也存在一些潜在的风险和问题。恶意的代理服务器可能会窃取用户的个人信息，或者用于进行网络攻击。此外，某些网站或服务可能会检测和封禁使用代理服务器的用户。因此，在选择和使用IP代理时，用户需要谨慎选择可信的代理服务提供商，并确保使用合法和安全的目的。\n总之，IP代理是一种通过代理服务器进行网络通信的方式，可以隐藏用户的真实IP地址，改变地理位置，并提供一些其他功能。它在一定程度上增加了网络使用的灵活性和隐私保护性。\n下面我要介绍的是一个很好用的ip代理：\n一连代理\n一连代理官网：https://yilian.top/\n\n\n\n\n\n\n\n\n\n一连代理为爬虫和大数据等相关领域的企业和个人客户，提供超高性价比的代理IP服务，助力业务降本增效。最近他们刚上线，新人可以获得【3天不限量+1万IP不限时】使用机会，反正不吃亏，刚好可以试试产品弹性。\n从拨号VPS到代理IP一连代理的前身是成都云立方。立足西部，十余年来，云立方网从传统IDC业务到深耕拨号VPS产品，服务于爬虫和大数据相关领域的客户，客户包括阿里，腾讯，百度，携程，58，去哪儿，中科院等诸多头部企事业单位，在业界积累广泛的良好口碑。\n时间步入2022年，随着疫情的结束，行业步入恢复期，团队收集到客户们的广泛需求，决定启动代理IP项目，将产品和服务更贴近于一线，基于拨号VPS的能力，直接为客户提供品质卓越、价格实惠的代理IP服务，帮助客户更便捷的接入业务，免去繁琐部署成本。\n22年底，团队完成了项目立项，组建了全新的产研团队，引入包括腾讯、阿里、和中国电信等相关履历的优秀人才加入。从线路部署到底层调度内核，从传输协议到操作控制台，历经一年潜心研发，我们于今日正式上线了全新的代理IP业务品牌及官网 :一连代理。\n品质至上，用优异的产品连接客户作为企业级代理IP供应商，要提供高品质的产品，为客户增效降本，必须解决如下4个问题：更快速的访问、更纯净的IP、更稳定的服务、更实惠的价格。为此，团队日夜奋战，提供了包含如下10大特性的产品能力：\nIP纯净\n基于独有的的家宽动态拨号VPS线路资源，IP纯净度极高，远非市面上第三方采购所比；\n快速传输\n业内唯一独家同时支持UDP和TCP协议，实现远超普通代理的访问效率及流媒体传输能力；\n价格实惠\n得益于大规模的自营IT线路部署，带来极致成本优势，支撑一连代理提供具有竞争力的定价\n多协议支持\n支持主流的http/https/socks5协议, 灵活匹配您的业务需求\n高速响应\n使用API快速拉取IP，自研内核级IP调度、达到50-300ms响应时间\n高可用性\n自研IP可用性自检机制,99.99%的IP可用性, 远超业界平均的95%-99%\n高带宽\n默认单IP峰值带宽4Mbps，远超业界常见的2M带宽\n多种接入方式\n支持直连和隧道2种接入方式，根据您的业务需求，按需选择\n多鉴权方式\n同时支持账号密码&amp;白名单两种鉴权方式，白名单IP数量支持多达256个\n不限终端设备数\n单IP不限终端设备数, 且不限每日提取数, 部先终端数, 无忧承载高海量业务 \n可以通过一组数据，更加直观的感受一连代理的产品的优势\n\n使用感受\n 隐私保护：使用一连代理可以隐藏您的真实IP地址，从而保护您的在线隐私。这对于那些担心个人信息泄露的用户来说是非常有用的。\n 绕过地理限制：许多网站和服务都有地理限制，这意味着它们可能在某些国家或地区无法访问。使用IP代理可以让您绕过这些限制，访问受限制的内容。\n 提高访问速度：有时，由于网络拥堵或其他原因，访问某些网站可能会变慢。使用IP代理可以提高访问速度，因为代理服务器通常会缓存热门内容，从而加快加载速度。\n 匿名性：使用IP代理可以让您在网络上保持匿名，这对于那些希望保护自己身份的用户来说是非常有用的。\n 安全性：虽然大多数IP代理都是安全的，但仍然有一些不安全的代理服务器存在。因此，在使用IP代理时，确保选择一个可靠和安全的服务提供商是非常重要的。一连代理就非常可靠\n 稳定性：使用IP代理可能会导致网络连接不稳定，因为您需要通过代理服务器来访问网站。这可能会导致连接中断或速度变慢。\n 价格：许多IP代理服务是收费的，而且价格因提供商而异。在选择IP代理服务时，需要考虑其价格和性价比。\n兼容性：并非所有网站和服务都支持IP代理。在使用IP代理时，可能需要进行一些额外的配置才能使其正常工作。以上的问题使用一连代理都不存在。\n\nTCP/IP协议简介TCP/IP协议是一种分层的、面向连接的网络通信协议。它由传输控制协议（TCP）和因特网协议（IP）两部分组成，分别负责数据传输的可靠性和路由选择。TCP/IP协议将网络通信划分为四个层次：应用层、传输层、网络层和数据链路层，每一层都有特定的功能和任务。\nTCP/IP协议的核心功能\n  可靠的数据传输：TCP协议提供了可靠的数据传输服务，通过数据包的序号、确认和重传机制，确保数据的完整性和正确性。\n  无连接的数据传输：IP协议以数据包为单位进行传输，不需要在发送前建立连接，从而提高了数据传输的效率。\n  网络路由选择：IP协议负责确定数据包的传输路径，通过路由选择算法找到最佳的传输路径。\n  网络控制：TCP/IP协议支持网络控制功能，包括错误检测、流量控制和拥塞控制等，以确保网络通信的稳定性和可靠性。\n\n\n\n\n\n\n\n\n\n\nTCP/IP 协议是计算机网络中最常用的一种协议。它是一个分层协议，包括多个层次：应用层、传输层、网络层和数据链路层。\nTCP/IP 协议的主要特点\n 统一的网络架构：TCP/IP 协议提供了一种统一的网络架构，使得不同类型的计算机和设备可以通过相同的协议进行通信。\n 分层结构：TCP/IP 协议采用分层结构，每一层都有自己的功能和任务，从而使得协议更加灵活和可扩展。\n 可靠性：TCP 协议提供可靠的传输服务，确保数据完整性和正确性；而 IP 协议则提供了无连接的数据传输服务，能够快速地将数据包发送到目标地址。\n 网络控制：TCP/IP 协议支持网络控制，包括路由选择、错误检测和流量控制等。\n 开放性：TCP/IP 协议是开放的标准，任何人都可以使用和开发它。\n\nTCP/IP 协议的分层结构包括以下四个层次：\n\n 应用层：应用层负责处理用户应用程序和网络之间的交互，比如 HTTP、FTP、SMTP 等。\n 传输层：传输层负责将数据传输到目标计算机，包括 TCP 和 UDP 两种协议。\n 网络层：网络层负责将数据从源计算机发送到目标计算机，包括 IP、ICMP 和 ARP 等协议。\n 数据链路层：数据链路层负责将数据转换为物理信号并通过网络传输，包括以太网、Wi-Fi 等协议。\n\nTCP/IP 协议是网络通信领域最基本的协议之一，它的出现和发展，使得计算机之间的通信更加稳定、可靠和高效。\nTCP/IP协议的实际应用TCP/IP协议在各种网络应用中广泛应用，比如Web服务、电子邮件、文件传输等。HTTP、FTP、SMTP等应用层协议都是基于TCP/IP协议栈实现的，它们通过TCP或UDP传输数据，并借助IP协议进行路由选择和数据包传输。\nTCP/IP协议的发展趋势随着云计算、物联网和5G技术的发展，TCP/IP协议也在不断演进和优化。新的协议标准如IPv6的推出，以及网络功能虚拟化（NFV）和软件定义网络（SDN）等技术的应用，都在推动TCP/IP协议的发展，以满足更高效、安全、智能的网络通信需求。\n总结TCP/IP协议作为计算机网络通信的基础，其重要性不言而喻。通过本文的介绍，我们对TCP/IP协议的原理、功能和应用有了更深入的理解。在未来的网络技术发展中，TCP/IP协议仍将扮演着至关重要的角色，为构建高效、可靠的网络通信系统提供坚实的基础。\n希望本文能够帮助读者更好地理解TCP/IP协议，对网络通信领域有所启发和帮助。\n","slug":"http/一文了解TCP,IP协议和一个超好用的IP代理","date":"2023-11-04T14:46:35.000Z","categories_index":"网络,TCP/IP,HTTP","tags_index":"网络协议","author_index":"前端少年汪"},{"id":"46b02835844d99665ebb5686f07868c8","title":"Three.js深入浅出：3-三维空间","content":"序言：\n\n\n\n\n\n\n\n\n在现代互联网时代，Web 技术的快速发展使得 Web 开发领域日新月异。随着互联网内容变得越来越丰富、复杂，用户对于网页和应用程序的交互性和视觉效果提出了更高的要求。在这样的背景下，基于 WebGL 的 3D 图形技术越来越受到关注和重视。\n而在众多的 3D 图形库中，Three.js 作为一款优秀的 JavaScript 3D 图形库，受到了广泛的欢迎和应用。无论是创建引人入胜的交互式 3D 场景、还是打造惊艳的虚拟现实体验，Three.js 都展现出了强大的潜力和灵活性。\n本系列文章将深入探讨 Three.js，从基础入门到高级应用，带领读者逐步掌握 Three.js 的核心概念和技术要点。我们将从搭建基本的 3D 场景开始，逐步引入光影、材质、纹理、动画等概念，让读者能够系统地掌握 Three.js 的开发技巧和实践经验。\n通过本系列文章的学习，读者将能够掌握使用 Three.js 创建精美的 3D 可视化效果，以及实现交互式的虚拟场景的能力。无论是 Web 开发工程师、还是对 3D 图形技术感兴趣的爱好者，都能够从中受益匪浅。\n让我们一起踏上 Three.js 的学习之旅，探索无限的创意可能性，开启属于自己的 3D 时代！ 欢迎各位小伙伴们多多关注，你的点赞和评论是我写作的动力！\n什么是三维空间\n在Three.js中，三维空间指的是具有三个独立轴的空间，通常称为X、Y和Z轴。这种空间用于描述和定位3D对象的位置、旋转和缩放。\n\n位置（Position）：在三维空间中，每个对象都有一个位置，可以通过它在X、Y和Z坐标轴上的位置来确定。例如，一个立方体可能被放置在(x, y, z) = (0, 0, 0)，表示它位于三维空间的原点。\n\n旋转（Rotation）：除了位置之外，物体还可以围绕三维空间中的任意轴进行旋转。在Three.js中，通常使用欧拉角（Euler angles）或四元数（quaternions）来表示旋转。\n\n缩放（Scale）：每个对象都可以沿着X、Y和Z轴进行缩放，这决定了物体的大小。通过在不同轴上应用不同的缩放因子，可以实现各种形状和比例的变化。\n\n\n通过使用这些三维空间的概念，你可以在Three.js中创建具有真实感的3D场景，包括摄影机、灯光、材质和几何体等元素，并对它们进行精确的定位、旋转和缩放，从而呈现出生动的三维世界。\n总的来说，三维空间是Three.js中非常重要的概念，它提供了一个框架来描述和操作3D对象在虚拟世界中的位置、方向和大小，为构建交互式的3D场景提供了基础。\n辅助观察坐标系THREE.AxesHelper()的参数表示坐标系坐标轴线段尺寸大小，你可以根据需要改变尺寸。\n&#x2F;&#x2F; AxesHelper：辅助观察的坐标系\nconst axesHelper &#x3D; new THREE.AxesHelper(150);\nscene.add(axesHelper);\n\n材质半透明设置设置材质半透明,这样可以看到坐标系的坐标原点。\nconst material &#x3D; new THREE.MeshBasicMaterial(&#123;\n    color: 0x0000ff, &#x2F;&#x2F;设置材质颜色\n    transparent:true,&#x2F;&#x2F;开启透明\n    opacity:0.5,&#x2F;&#x2F;设置透明度\n&#125;);\n\nAxesHelper的xyz轴three.js坐标轴颜色红R、绿G、蓝B分别对应坐标系的x、y、z轴，对于three.js的3D坐标系默认y轴朝上。\n设置模型在坐标系中的位置或尺寸通过模型的位置、尺寸设置，加深3D坐标系的概念。\n测试：设置长方体xyz不同方向尺寸\n&#x2F;&#x2F; 设置几何体长宽高，也就是x、y、z三个方向的尺寸\n&#x2F;&#x2F;对比三个参数分别对应xyz轴哪个方向\nnew THREE.BoxGeometry(100, 60, 20);\n\n测试：改变位置\n&#x2F;&#x2F; 设置模型mesh的xyz坐标\nmesh.position.set(100,0,0);\n\n参数——预览新的渲染效果你可以尝试源码中改变相机的参数，看看场景中的物体渲染效果怎么变化。\n相机放在x轴负半轴，目标观察点是坐标原点，这样相当于相机的视线是沿着x轴正方向，只能看到长方体的一个矩形平面。\ncamera.position.set(-1000, 0, 0);\ncamera.lookAt(0, 0, 0);\n\n&#x2F;&#x2F; 相机视线沿着x轴负半轴，mesh位于相机后面，自然看不到\ncamera.position.set(-1000, 0, 0);\ncamera.lookAt(-2000, 0, 0);\n\n相机far偏小，mesh位于far之外，物体不会显示在画布上。\n&#x2F;&#x2F; const camera &#x3D; new THREE.PerspectiveCamera(30, width &#x2F; height, 1, 3000);\n&#x2F;&#x2F; 你可以进行下面测试，改变相机参数，把mesh放在视锥体之外，看看是否显示\n&#x2F;&#x2F; 3000改为300，使mesh位于far之外，mesh不在视锥体内，被剪裁掉\nconst camera &#x3D; new THREE.PerspectiveCamera(30, width &#x2F; height, 1, 300);\n\n\n","slug":"threeJS/Three.js深入浅出：3-三维空间","date":"2023-10-12T14:46:35.000Z","categories_index":"Three","tags_index":"threr.js","author_index":"前端少年汪"},{"id":"99813f5b526e93cf8eb8d3f2ce7c5c5f","title":"Three.js深入浅出：2-创建三维场景和物体","content":"序言：\n\n\n\n\n\n\n\n\n在现代互联网时代，Web 技术的快速发展使得 Web 开发领域日新月异。随着互联网内容变得越来越丰富、复杂，用户对于网页和应用程序的交互性和视觉效果提出了更高的要求。在这样的背景下，基于 WebGL 的 3D 图形技术越来越受到关注和重视。\n而在众多的 3D 图形库中，Three.js 作为一款优秀的 JavaScript 3D 图形库，受到了广泛的欢迎和应用。无论是创建引人入胜的交互式 3D 场景、还是打造惊艳的虚拟现实体验，Three.js 都展现出了强大的潜力和灵活性。\n本系列文章将深入探讨 Three.js，从基础入门到高级应用，带领读者逐步掌握 Three.js 的核心概念和技术要点。我们将从搭建基本的 3D 场景开始，逐步引入光影、材质、纹理、动画等概念，让读者能够系统地掌握 Three.js 的开发技巧和实践经验。\n通过本系列文章的学习，读者将能够掌握使用 Three.js 创建精美的 3D 可视化效果，以及实现交互式的虚拟场景的能力。无论是 Web 开发工程师、还是对 3D 图形技术感兴趣的爱好者，都能够从中受益匪浅。\n让我们一起踏上 Three.js 的学习之旅，探索无限的创意可能性，开启属于自己的 3D 时代！ 欢迎各位小伙伴们多多关注，你的点赞和评论是我写作的动力！\n核心概念下面我将详细解释 Three.js 的核心概念：\n\n 场景 (Scene) ：场景是 Three.js 中的核心概念，它充当着所有 3D 对象的容器。通过创建场景对象，可以将所有的物体、灯光和相机放置在同一个坐标空间中进行渲染。\n 相机 (Camera) ：相机定义了用户在场景中所看到的部分。Three.js 提供了多种类型的相机，包括透视相机（PerspectiveCamera）和正交相机（OrthographicCamera），它们分别用于创建透视投影和正交投影效果。\n 渲染器 (Renderer) ：渲染器负责将场景和相机中的内容渲染成 2D 图像，并显示在浏览器中。Three.js 提供了 WebGLRenderer 和 CanvasRenderer 两种渲染器，其中 WebGLRenderer 利用 WebGL 技术实现硬件加速渲染，性能更好。\n 光源 (Light) ：光源用于模拟场景中的光照效果。Three.js 支持多种类型的光源，包括环境光、点光源、聚光灯和方向光等，通过调整光源的参数可以控制阴影、反射等效果。\n 材质 (Material) ：材质定义了物体表面的外观和特性，如颜色、纹理、光照反射等。Three.js 提供了各种内置的材质类型，也支持自定义的着色器材质。\n 几何体 (Geometry) ：几何体是 3D 物体的基本结构，描述了物体的形状和结构。在 Three.js 中可以创建各种几何体，如立方体、球体、圆柱体等，也支持自定义几何体的创建。\n 网格 (Mesh) ：网格是由几何体和材质组合而成的对象，它是 Three.js 中最常见的 3D 对象类型。网格可以被添加到场景中，通过变换、旋转、缩放等操作来实现动画效果。\n 纹理 (Texture) ：纹理用于给几何体表面贴图，赋予物体更加生动和细致的外观。Three.js 支持加载各种图片文件作为纹理，也支持动态生成纹理。\n 动画 (Animation) ：Three.js 提供了丰富的动画支持，可以实现物体的平移、旋转、缩放等动画效果。动画系统可以与时间、鼠标、键盘等事件进行交互，实现复杂的交互式动画效果。当然，除了上面提到的核心概念外，Three.js 还涵盖了一些其他重要的概念，这些概念对于理解和使用 Three.js 都非常关键：\n控制器 (Controller) ：控制器用于管理用户与场景之间的交互，包括鼠标、触摸屏、键盘等输入设备的响应。Three.js 提供了 OrbitControls、FlyControls、TrackballControls 等多种控制器，可以方便地实现用户对相机视角的控制。\n粒子系统 (Particle System) ：粒子系统是用于模拟大量小颗粒的效果，比如烟雾、火焰、雨滴等。Three.js 提供了ParticleSystem类，可以创建和管理粒子系统，通过调整粒子的位置、速度、大小等参数来实现各种粒子效果。\n后期处理 (Post-processing) ：后期处理是指在渲染图像后对其进行额外的处理，比如添加景深效果、光照效果、色彩调整等。Three.js 提供了EffectComposer类和多个着色器（Shader）来实现各种后期处理效果。\n阴影 (Shadow) ：阴影效果可以使场景中的物体产生逼真的阴影，增强了 3D 场景的真实感。Three.js 支持通过设置光源的属性和材质的属性来实现阴影效果。\n加载器 (Loader) ：加载器用于加载外部资源，比如模型文件、纹理图片、音频文件等。Three.js 提供了多种加载器，如OBJLoader、MTLLoader、TextureLoader 等，可以方便地将外部资源加载到场景中使用。\n性能优化 (Performance Optimization) ：在开发 3D 应用时，性能优化非常重要。Three.js 提供了诸如几何体合并、LOD（细节层次）技术、GPU 粒子等性能优化手段，来提高应用的运行效率和流畅度。\n\n创建一个正方体创建场景，相机，渲染器const scene &#x3D; new THREE.Scene();\nconst camera &#x3D; new THREE.PerspectiveCamera( 75, window.innerWidth &#x2F; window.innerHeight, 0.1, 1000 ); \nconst renderer &#x3D; new THREE.WebGLRenderer();\n\n const scene = new THREE.Scene(); 这一行代码创建了一个新的场景对象。在 Three.js 中，场景（Scene）是用来存放和管理所有 3D 对象（比如模型、灯光、相机等）的容器。通过创建一个场景对象，我们可以将所有的 3D 元素都添加到这个场景中，并在之后对它们进行操作和渲染。\n const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); 这一行代码创建了一个透视相机（Perspective Camera）。相机是观察场景的视角，决定了最终渲染出来的图像是怎样的。在这里，使用 PerspectiveCamera 类创建了一个透视相机，参数分别为视野角度（fov）、屏幕纵横比（aspect ratio）、近裁剪面（near clipping plane）和远裁剪面（far clipping plane）。视野角度决定了观察者能够看到的范围，而近裁剪面和远裁剪面则定义了相机能够渲染的物体范围，超出这个范围的物体将不会被渲染。\n const renderer = new THREE.WebGLRenderer(); 这一行代码创建了一个 WebGL 渲染器（WebGL Renderer）。渲染器负责将 3D 场景渲染成 2D 图像并显示在浏览器中。Three.js 使用 WebGL 技术来进行硬件加速的 3D 渲染，而 WebGLRenderer 类就是用于创建并配置这个渲染器的。渲染器会将最终的 3D 场景渲染到画布（canvas）上，并通过渲染器的 DOM 元素添加到页面中来显示最终的渲染结果。\n\n设置渲染器大小参数renderer.setSize(windowWidth, windowHeight);&#x2F;&#x2F; 设置渲染器的大小\ndocument.body.appendChild( renderer.domElement );&#x2F;&#x2F; 将渲染器添加到页面中\n\n renderer.setSize(windowWidth, windowHeight); 这行代码的作用是设置渲染器的大小，其中 windowWidth 和 windowHeight 分别代表了浏览器窗口的宽度和高度。通过调用 setSize 方法，我们告诉渲染器应该将输出的 3D 场景渲染成多大尺寸的图像。通常情况下，我们会将渲染器的大小设置为与浏览器窗口相同的尺寸，以保证 3D 场景能够填满整个浏览器窗口。\n document.body.appendChild( renderer.domElement ); 这行代码的作用是将渲染器的 DOM 元素添加到页面中，以便在浏览器中显示 3D 场景。在 Three.js 中，每个渲染器都有一个对应的 DOM 元素（通常是一个 canvas 元素），它用于显示渲染后的 3D 图像。通过调用 appendChild 方法，我们将这个 DOM 元素添加到页面的 body 元素中，这样就能在页面上看到经过渲染的 3D 场景了。\n\n\n创建立方体物体const geometry &#x3D; new THREE.BoxGeometry(1, 1, 1);&#x2F;&#x2F; 立方体几何体\nconst material &#x3D; new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;);&#x2F;&#x2F; 材质\nconst cube &#x3D; new THREE.Mesh(geometry, material);&#x2F;&#x2F; 立方体\n\n const geometry = new THREE.BoxGeometry(1, 1, 1); 这一行代码创建了一个立方体的几何体（geometry）。在 Three.js 中，几何体用来定义 3D 模型的形状，比如立方体、球体、圆柱体等。BoxGeometry 类表示一个立方体的几何形状，参数 (1, 1, 1) 分别表示立方体在 x、y、z 轴上的尺寸。因此，这行代码创建了一个边长为 1 的立方体几何体。\n const material = new THREE.MeshBasicMaterial({color: 0x00ff00}); 这一行代码创建了一个基本网格材质（MeshBasicMaterial）。材质定义了模型表面的外观特性，比如颜色、光照效果等。在这里，使用 MeshBasicMaterial 类创建了一个具有固定颜色的材质，颜色值 0x00ff00 表示绿色。这意味着我们将创建一个绿色的立方体模型。\n const cube = new THREE.Mesh(geometry, material); 这一行代码创建了一个网格对象（Mesh），并将之前创建的立方体几何体和材质应用到这个网格对象上。Mesh 类表示一个由几何体和材质组合而成的 3D 模型。通过将立方体几何体和材质传递给 Mesh 构造函数，我们实际上创建了一个拥有指定形状和外观的立方体模型。\n\n渲染场景和动画scene.add(cube);&#x2F;&#x2F; 将立方体添加到场景中\n\ncamera.position.z &#x3D; 5;&#x2F;&#x2F; 移动摄像机\n\n&#x2F;&#x2F; 渲染循环\nfunction animate() &#123;\n    requestAnimationFrame(animate);&#x2F;&#x2F; 请求动画帧\n    cube.rotation.x +&#x3D; 0.01;&#x2F;&#x2F; 旋转立方体\n    cube.rotation.y +&#x3D; 0.01;&#x2F;&#x2F; 旋转立方体\n    renderer.render(scene, camera);&#x2F;&#x2F; 渲染场景\n&#125;\n\nwindow.onload &#x3D; animate&#x2F;&#x2F; 页面加载完毕后执行动画函数\n\n\n scene.add(cube); 这一行代码将之前创建的立方体模型 cube 添加到场景中。在 Three.js 中，使用 add 方法可以将 3D 对象添加到场景中，使其成为场景的一部分，从而在渲染时被显示出来。\n\n camera.position.z = 5; 这一行代码将摄像机的位置沿着 z 轴移动到距离原点 5 个单位的位置。在 3D 场景中，摄像机决定了观察者的视角和展示效果，通过调整摄像机的位置，可以改变观察到的场景效果。\n\nfunction animate() { … } 这是一个名为 animate 的函数，用于执行渲染循环。在这个函数中：\n\n  requestAnimationFrame(animate);  这一行代码请求浏览器在下次重绘之前更新动画，并指定下一次重绘时调用的回调函数为 animate，这样可以实现流畅的动画效果。\n  cube.rotation.x += 0.01;  和 cube.rotation.y += 0.01;  这两行代码分别对立方体模型进行 x 轴和 y 轴方向上的旋转操作。通过不断改变立方体模型的旋转角度，可以实现旋转的动画效果。\n  renderer.render(scene, camera);  这一行代码使用渲染器来对场景进行渲染，以当前的摄像机视角生成最终的图像。\n\n\n window.onload = animate 这一行代码指定在页面加载完成后执行 animate 函数，启动动画渲染循环。\n\n\n完整代码\n&lt;!--\n * @Date: 2023-11-11 14:14:21\n * @LastEditors: 前端少年汪  \n * @LastEditTime: 2023-11-11 15:50:17\n * @FilePath: &#x2F;webGIS&#x2F;1-three.html\n * @Description: \n--&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        h1 &#123;\n            text-align: center;\n        &#125;\n\n        #webgl &#123;\n            width: 1200px;\n            height: 700px;\n            margin: 0 auto;\n        &#125;\n\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;three.js入门教程&lt;&#x2F;h1&gt;\n&lt;div id&#x3D;&quot;webgl&quot;&gt;&lt;&#x2F;div&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    &#x2F;&#x2F; 现在浏览器支持ES6语法，自然包括import方式引入js文件\n    import * as THREE from &#39;.&#x2F;node_modules&#x2F;three&#x2F;src&#x2F;Three.js&#39;;\n\n    let windowWidth &#x3D; 1200;&#x2F;&#x2F; 窗口宽度\n    let windowHeight &#x3D; 700;&#x2F;&#x2F; 窗口高度\n\n    const scene &#x3D; new THREE.Scene();&#x2F;&#x2F; 场景\n    const camera &#x3D; new THREE.PerspectiveCamera(75, windowWidth &#x2F; windowHeight, 0.1, 1000);&#x2F;&#x2F; 摄像机\n    const renderer &#x3D; new THREE.WebGLRenderer();&#x2F;&#x2F; 渲染器\n\n    renderer.setSize(windowWidth, windowHeight);&#x2F;&#x2F; 设置渲染器的大小\n\n    document.getElementById(&#39;webgl&#39;).appendChild(renderer.domElement);&#x2F;&#x2F; 将渲染器添加到页面中\n    &#x2F;&#x2F; document.body.appendChild( renderer.domElement );\n\n    const geometry &#x3D; new THREE.BoxGeometry(1, 1, 1);&#x2F;&#x2F; 立方体几何体\n    const material &#x3D; new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;);&#x2F;&#x2F; 材质\n    const cube &#x3D; new THREE.Mesh(geometry, material);&#x2F;&#x2F; 立方体\n    scene.add(cube);&#x2F;&#x2F; 将立方体添加到场景中\n\n    camera.position.z &#x3D; 5;&#x2F;&#x2F; 移动摄像机\n\n    &#x2F;&#x2F; 渲染循环\n    function animate() &#123;\n        requestAnimationFrame(animate);&#x2F;&#x2F; 请求动画帧\n        cube.rotation.x +&#x3D; 0.01;&#x2F;&#x2F; 旋转立方体\n        cube.rotation.y +&#x3D; 0.01;&#x2F;&#x2F; 旋转立方体\n        renderer.render(scene, camera);&#x2F;&#x2F; 渲染场景\n    &#125;\n\n    window.onload &#x3D; animate&#x2F;&#x2F; 页面加载完毕后执行动画函数\n\n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n总结以上demo总结来说，使用了 Three.js 库创建了一个简单的绿色立方体模型，并实现了旋转动画效果。 总结一下它的步骤：\n\n创建立方体模型：\n\n使用 BoxGeometry 类创建了一个边长为 1 的立方体几何体。\n使用 MeshBasicMaterial 类创建了一个绿色的基本网格材质。\n将几何体和材质传递给 Mesh 类创建了一个立方体网格对象。\n\n\n将立方体添加到场景中：\n\n使用 scene.add(cube) 将立方体模型添加到场景中，使其成为场景的一部分。\n\n\n设置摄像机位置：\n\n将摄像机沿着 z 轴移动到距离原点 5 个单位的位置，以确定观察者的视角和展示效果。\n\n\n创建渲染循环：\n\n定义了一个名为 animate 的函数，用于执行渲染循环。\n在 animate 函数中，使用 requestAnimationFrame 请求浏览器在下次重绘之前更新动画，然后对立方体模型进行 x 和 y 轴方向上的旋转操作，最后通过渲染器对场景进行渲染。\n\n\n启动动画渲染循环：\n\n指定在页面加载完成后执行 animate 函数，从而启动动画渲染循环。\n\n\n\n通过以上步骤，我们成功创建了一个具有旋转动画效果的绿色立方体模型，并将其显示在网页中。这个简单的示例展示了如何使用 Three.js 创建基本的 3D 模型并实现动画效果。\n","slug":"threeJS/Three.js深入浅出：2-创建三维场景和物体","date":"2023-10-10T14:46:35.000Z","categories_index":"Three","tags_index":"threr.js","author_index":"前端少年汪"},{"id":"28100a05c0122f653152ea41cfe72159","title":"Three.js深入浅出：1-搭建Three.js开发环境","content":"序言：\n\n\n\n\n\n\n\n\n在现代互联网时代，Web 技术的快速发展使得 Web 开发领域日新月异。随着互联网内容变得越来越丰富、复杂，用户对于网页和应用程序的交互性和视觉效果提出了更高的要求。在这样的背景下，基于 WebGL 的 3D 图形技术越来越受到关注和重视。\n而在众多的 3D 图形库中，Three.js 作为一款优秀的 JavaScript 3D 图形库，受到了广泛的欢迎和应用。无论是创建引人入胜的交互式 3D 场景、还是打造惊艳的虚拟现实体验，Three.js 都展现出了强大的潜力和灵活性。\n本系列文章将深入探讨 Three.js，从基础入门到高级应用，带领读者逐步掌握 Three.js 的核心概念和技术要点。我们将从搭建基本的 3D 场景开始，逐步引入光影、材质、纹理、动画等概念，让读者能够系统地掌握 Three.js 的开发技巧和实践经验。\n通过本系列文章的学习，读者将能够掌握使用 Three.js 创建精美的 3D 可视化效果，以及实现交互式的虚拟场景的能力。无论是 Web 开发工程师、还是对 3D 图形技术感兴趣的爱好者，都能够从中受益匪浅。\n让我们一起踏上 Three.js 的学习之旅，探索无限的创意可能性，开启属于自己的 3D 时代！欢迎各位小伙伴们多多关注，你的点赞和评论是我写作的动力！👏🚀\n引入three.js的方式这里主要分为两种情况\n\n开发环境：项目开发引入threejs，比如vue或react脚手架引入threejs。\n学习环境：入门学习threejs阶段，html文件中直接引入threejs\n\n开发环境下npm安装引入如果你使用的是Vue + threejs或React + threejs技术栈，那么threejs就是一个js库，直接通过npm命令行安装就行。\nnpm安装特定版本three.js(注意使用哪个版本，查文档就查对应版本)\nnpm i three@版本号 --save\n\nyarn add three\n\n\n使用npm安装之后在vue或者react组件里面直接使用es6的方式引入即可\n&#x2F;&#x2F; 引入three.js\nimport * as THREE from &#39;three&#39;;\n\n\n引入three扩展库除了three.js核心库以外，在threejs文件包中examples/jsm目录下，还可以看到各种不同功能的扩展库。\n项目用到那个扩展库，就引入那个，用不到就不需要引入比如：\n&#x2F;&#x2F; 引入扩展库OrbitControls.js\nimport &#123; OrbitControls &#125; from &#39;three&#x2F;addons&#x2F;controls&#x2F;OrbitControls.js&#39;;\n&#x2F;&#x2F; 引入扩展库GLTFLoader.js\nimport &#123; GLTFLoader &#125; from &#39;three&#x2F;addons&#x2F;loaders&#x2F;GLTFLoader.js&#39;;\n\n\n学习环境下如果不是正式开发Web3D项目，只是学习threejs功能，完全没必要用webpack或vite搭建一个开发环境。\n学习使用的环境，只要创建一个.html文件，编写threejs代码，最后通过本地静态服务打开.html文件就行。\nscript标签引入你可以像平时开发web前端项目一样，通过script标签把three.js当做一个js库引入你的项目。\nthree.js库可以在threejs官方文件包下面的build目录获取到。\n&lt;script src&#x3D;&quot;.&#x2F;build&#x2F;three.js&quot;&gt;&lt;&#x2F;script&gt;\n\n&#x2F;&#x2F;随便输入一个API，测试下是否已经正常引入three.js\nconsole.log(THREE.Scene); \n\nES6 import方式引入给script标签设置type=&quot;module&quot;,也可以在.html文件中使用import方式引入three.js。\n&lt;script type&#x3D;&quot;module&quot;&gt;\n&#x2F;&#x2F; 现在浏览器支持ES6语法，自然包括import方式引入js文件\nimport * as THREE from &#39;.&#x2F;build&#x2F;three.module.js&#39;;\n&lt;&#x2F;script&gt;\n\ntype=”importmap”配置路径学习环境中，.html文件引入three.js，最好的方式就是参考threejs官方案例，通过配置&lt;script type=&quot;importmap&quot;&gt;,实现学习环境.html文件和vue或reaact脚手架开发环境一样的写法。这样你实际项目的开发环境复制课程源码，不用改变threejs引入代码。\n下面配置的type=&quot;importmap&quot;代码具体写法不用掌握记忆，复制粘贴后，能修改目录就行，你可以去电子书课件或者课件源码中复制。\n&lt;!-- 具体路径配置，你根据自己文件目录设置，我的是课件中源码形式 --&gt;\n&lt;script type&#x3D;&quot;importmap&quot;&gt;\n    &#123;\n\t\t&quot;imports&quot;: &#123;\n\t\t\t&quot;three&quot;: &quot;..&#x2F;..&#x2F;..&#x2F;three.js&#x2F;build&#x2F;three.module.js&quot;\n\t\t&#125;\n\t&#125;\n&lt;&#x2F;script&gt;\n\n&lt;!-- 配置type&#x3D;&quot;importmap&quot;,.html文件也能和项目开发环境一样方式引入threejs --&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    import * as THREE from &#39;three&#39;;\n    &#x2F;&#x2F; 浏览器控制台测试，是否引入成功\n    console.log(THREE.Scene);\n&lt;&#x2F;script&gt;\n\n\nCDN引入通过将文件上传到你自己的服务器，或是使用一个已存在的CDN，three.js 便可以不借助任何构建系统来进行使用。由于 three.js 依赖于ES module，因此任何引用它的script标签必须使用type=”module” 。如下所示：\n&lt;script type&#x3D;&quot;importmap&quot;&gt;\n    &#123;\n    &quot;imports&quot;: \n        &#123; &quot;three&quot;:&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;three@&lt;version&gt;&#x2F;build&#x2F;three.module.js&quot; &#125;\n    &#125; \n&lt;&#x2F;script&gt;\n&lt;script type&#x3D;&quot;module&quot;&gt;\n    import * as THREE from &#39;three&#39;; \n    const scene &#x3D; new THREE.Scene();\n&lt;&#x2F;script&gt;\n\n兼容性CommonJS 导入虽然现代的 JavaScript 打包器已经默认支持ES module，然而也有一些较旧的构建工具并不支持。对于这些情况，你或许可以对这些打包器进行配置，让它们能够理解 ES module 。例如，Browserify 仅需 babelify 插件。\nImport maps和从静态主机或CDN来进行安装的方式相比，从npm安装时，导入的路径有所不同。我们意识到，对于使用两种不同方式的用户群体来说，这是一个人体工程学问题。使用构建工具与打包器的开发者更喜欢仅使用单独的包说明符（如’three’）而非相对路径，而examples/ 目录中的文件使用相对于 three.module.js 的引用并不符合这一期望。对于不使用构建工具的人（用于快速原型、学习或个人参考）来说，或许也会很反感这些相对导入。这些相对导入需要确定目录结构，并且比全局 THREE.*  命名空间更不宽容。\n我们希望在 import maps 广泛可用时，能够移除这些相对路径，将它们替换为单独的包说明符，’three’。这更加符合构建工具对npm包的期望，且使得两种用户群体在导入文件时能够编写完全相同的代码。对于更偏向于避免使用构建工具的用户来说，一个简单的 JSON 映射即可将所有的导入都定向到一个 CDN 或是静态文件夹。通过实验，目前你可以通过一个 import map 的 polyfill，来尝试更简洁的导入，如 import map example 示例中所示。\nNode.js由于 three.js 是为 Web 构建的, 因此它依赖于浏览器和 DOM 的 API ，但这些 API 在 Node.js 里不一定存在。这些问题中有的可以使用 headless-gl 等 shims 来解决，或者用自定义的替代方案来替换像 TextureLoader 这样的组件。其他 DOM API 可能与使用它们的代码强相关，因此将更难以解决。我们欢迎简单且易于维护的 pull request 来改进对 Node.js 的支持，但建议先打开问题来讨论您的改进。\n确保在您的 package.json 文件中添加 { “type”: “module” }，以在您的 Node.js 项目中启用 ES6 模块。\n","slug":"threeJS/Three.js深入浅出：1-搭建Three.js开发环境","date":"2023-10-04T14:46:35.000Z","categories_index":"Three","tags_index":"threr.js","author_index":"前端少年汪"},{"id":"9d169bb0c28cbff70a428eb8d736c659","title":"一文带你了解call、apply、bind的区别及源码实现","content":"前言call、apply和bind都是JavaScript中Function对象的原型方法，它们的作用主要是改变函数的执行上下文（即this的值）以及传递参数。\n什么是js上下文在讲解这三个方法之前，我先需要了解一下什么是js的上下文。\n执行上下文是JavaScript中的一个重要概念，它是一段代码被执行时的环境。它包含了当前执行环境中的所有信息，如变量、函数声明、参数（arguments）、作用域链，以及this等信息。\n在JavaScript中，执行上下文主要有两种类型：全局执行上下文和函数执行上下文。还有一个## eval函数执行上下文\n全局执行上下文全局执行上下文是为运行存在于函数之外的任何代码而创建的，即整个JavaScript程序的执行环境就是一个全局执行上下文。每当一个函数被调用时，就会创建一个新的函数执行上下文，这个函数执行上下文包含了这个函数自身的局部变量、参数等执行环境信息。此外，使用 eval() 函数也会创建一个新的执行上下文。\n函数执行上下文。函数执行上下文是指在调用一个函数时，函数内部的变量和参数的取值范围。当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n在JavaScript中，函数执行上下文通常包括以下内容：\n\n函数内部声明的变量（局部变量）：这些变量只在函数内部有效，函数外部无法访问。\n函数参数：当调用函数时传递的实参，它们会被赋值给形参。\n全局变量：在函数外部声明的变量，可以在函数内部直接访问。\n内置对象：如Math、Array等，它们提供了一些内置的方法和属性。\n其他执行上下文相关的信息，如调用栈、作用域链等。\n\n以下是一个示例代码，展示了函数执行上下文的相关内容：\n&#x2F;&#x2F; 定义全局变量\nvar globalVar &#x3D; &quot;I am a global variable&quot;;\n\nfunction exampleFunction(param1, param2) &#123;\n  &#x2F;&#x2F; 定义局部变量\n  var localVar &#x3D; &quot;I am a local variable&quot;;\n\n  console.log(globalVar); &#x2F;&#x2F; 输出全局变量的值\n  console.log(localVar); &#x2F;&#x2F; 输出局部变量的值\n  console.log(param1); &#x2F;&#x2F; 输出第一个参数的值\n  console.log(param2); &#x2F;&#x2F; 输出第二个参数的值\n&#125;\n\nexampleFunction(&quot;Hello&quot;, &quot;World&quot;);\n\n在上面的示例中，exampleFunction是一个函数，它接受两个参数param1和param2。在函数内部，我们声明了一个局部变量localVar，并使用console.log()打印了全局变量globalVar、局部变量localVar以及传入的参数值。当我们调用exampleFunction(&quot;Hello&quot;, &quot;World&quot;)时，函数执行上下文中的变量和参数值将被正确地传递给函数内部的代码块。\neval函数执行上下文执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，\n在JavaScript中，eval()函数用于执行一个字符串表达式，并返回表达式的值。它的执行上下文通常是当前的全局和局部变量。\n以下是一个示例代码，展示了如何使用eval()函数：\n&#x2F;&#x2F; 定义全局变量\nvar globalVar &#x3D; 10;\n\n&#x2F;&#x2F; 定义局部变量\nvar localVar &#x3D; 5;\n\n&#x2F;&#x2F; 使用eval()函数执行字符串表达式\nvar result &#x3D; eval(&quot;globalVar + localVar&quot;);\n\nconsole.log(result); &#x2F;&#x2F; 输出结果为15\n\n在上面的示例中，我们首先定义了两个变量globalVar和localVar，分别表示全局变量和局部变量。然后，我们使用eval()函数执行了一个字符串表达式&quot;globalVar + localVar&quot;，该表达式将返回全局变量和局部变量的和。最后，我们将结果打印出来，输出为15。\n2. 执行上下文栈\n  JavaScript引擎使用执行上下文栈来管理执行上下文\n  当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nlet a &#x3D; &#39;Hello World!&#39;;\nfunction first() &#123;\n  console.log(&#39;Inside first function&#39;);\n  second();\n  console.log(&#39;Again inside first function&#39;);\n&#125;\nfunction second() &#123;\n  console.log(&#39;Inside second function&#39;);\n&#125;\nfirst();\n&#x2F;&#x2F;执行顺序\n&#x2F;&#x2F;先执行second(),在执行first()\n\n3. 创建执行上下文创建执行上下文有两个阶段：创建阶段和执行阶段\n1）创建阶段\n（1）this绑定\n\n  在全局执行上下文中，this指向全局对象（window对象）\n  在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n  词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n  词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域\n\n（3）创建变量环境组件\n\n  变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n2）执行阶段\n此阶段会完成对变量的分配，最后执行完代码。\n简单来说执行上下文就是指：\n在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。\n\n  全局上下文：变量定义，函数声明\n  函数上下文：变量定义，函数声明，this，arguments\n\nthis/call/apply/bindthis 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n  第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n  第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n  第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n  第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\ncall、apply、bind的区别在JavaScript中，call()、apply()和bind()都是用于改变函数执行上下文的方法。它们的主要区别在于传递参数的方式和返回值。\n\ncall()方法：\n\n语法：function.call(thisArg, arg1, arg2, ...)\n作用：调用一个函数，并设置函数内部的this值为指定的值，同时传递一系列参数给函数。\n返回值：返回被调用函数的返回值。\n示例代码：function greet() &#123;\n  console.log(&#96;Hello, $&#123;this.name&#125;!&#96;);\n&#125;\n\nvar person &#x3D; &#123; name: &#39;Alice&#39; &#125;;\ngreet.call(person); &#x2F;&#x2F; 输出 &quot;Hello, Alice!&quot;\n\n\napply()方法：\n\n语法：function.apply(thisArg, [argsArray])\n作用：调用一个函数，并设置函数内部的this值为指定的值，同时传递一个数组作为参数列表给函数。\n返回值：返回被调用函数的返回值。\n示例代码：function greet() &#123;\n  console.log(&#96;Hello, $&#123;this.name&#125;!&#96;);\n&#125;\n\nvar person &#x3D; &#123; name: &#39;Alice&#39; &#125;;\ngreet.apply(person); &#x2F;&#x2F; 输出 &quot;Hello, Alice!&quot;\n\n\nbind()方法：\n\n语法：function.bind(thisArg, arg1, arg2, ...)\n作用：创建一个新的函数，并将原函数内部的this值设置为指定的值，同时将一系列参数绑定到新函数上。新函数可以单独调用，但不会改变原函数的执行上下文。\n返回值：返回一个新函数。\n示例代码：function greet() &#123;\n  console.log(&#96;Hello, $&#123;this.name&#125;!&#96;);\n&#125;\n\nvar person &#x3D; &#123; name: &#39;Alice&#39; &#125;;\nvar greetPerson &#x3D; greet.bind(person); &#x2F;&#x2F; 创建新函数 greetPerson\ngreetPerson(); &#x2F;&#x2F; 输出 &quot;Hello, Alice!&quot;\n\n\n\n总结来说，call()和apply()方法都可以用来改变函数执行上下文，并且可以传递多个参数给函数。而bind()方法则创建了一个新的函数，并将原函数的执行上下文绑定到新函数上，但只接受第一个参数作为上下文对象，后续的参数会作为新函数的参数。\ncall、apply、bind的源码实现（1）call 函数的实现步骤：\n  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n  处理传入的参数，截取第一个参数后的所有参数。\n  将函数作为上下文对象的一个属性。\n  使用上下文对象来调用这个方法，并保存返回结果。\n  删除刚才新增的属性。\n  返回结果。\n\nFunction.prototype.myCall &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    console.error(&quot;type error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  let args &#x3D; [...arguments].slice(1),\n    result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否传入，如果未传入则设置为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将调用函数设为对象的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 调用函数\n  result &#x3D; context.fn(...args);\n  &#x2F;&#x2F; 将属性删除\n  delete context.fn;\n  return result;\n&#125;;\n\n（2）apply 函数的实现步骤：\n  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n  判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n  将函数作为上下文对象的一个属性。\n  判断参数值是否传入\n  使用上下文对象来调用这个方法，并保存返回结果。\n  删除刚才新增的属性\n  返回结果\n\nFunction.prototype.myApply &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new TypeError(&quot;Error&quot;);\n  &#125;\n  let result &#x3D; null;\n  &#x2F;&#x2F; 判断 context 是否存在，如果未传入则为 window\n  context &#x3D; context || window;\n  &#x2F;&#x2F; 将函数设为对象的方法\n  context.fn &#x3D; this;\n  &#x2F;&#x2F; 调用方法\n  if (arguments[1]) &#123;\n    result &#x3D; context.fn(...arguments[1]);\n  &#125; else &#123;\n    result &#x3D; context.fn();\n  &#125;\n  &#x2F;&#x2F; 将属性删除\n  delete context.fn;\n  return result;\n&#125;;\n\n（3）bind 函数的实现步骤：\n  判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n  保存当前函数的引用，获取其余传入参数值。\n  创建一个函数返回\n  函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\nFunction.prototype.myBind &#x3D; function(context) &#123;\n  &#x2F;&#x2F; 判断调用对象是否为函数\n  if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;\n    throw new TypeError(&quot;Error&quot;);\n  &#125;\n  &#x2F;&#x2F; 获取参数\n  var args &#x3D; [...arguments].slice(1),\n    fn &#x3D; this;\n  return function Fn() &#123;\n    &#x2F;&#x2F; 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    );\n  &#125;;\n&#125;;","slug":"js/一文带你了解call、apply、bind的区别及源码实现","date":"2023-10-03T18:46:35.000Z","categories_index":"前端,js","tags_index":"js","author_index":"前端少年汪"},{"id":"07d7c4a503d2608a4847b4cb839388ec","title":"程序猿的专属成语,你get√了嘛","content":"我们知道当前经济环境下，就业困难。特别是关于就业和失业衍生出来的一系列新词汇。比如：\n\n灵活就业，\n慢就业，\n摩擦就业，\n适应性就业，\n阶段性就业，\n非连续性就业，\n公益性就业，\n自主就业，\n定向委托培养就业   \n\n\n除了以上哪些新词汇，当然还有我们程序猿对当下环境的感慨，对职场的吐槽，对自身的自嘲所衍生出来的“成语”\n真的感慨成语简直是中华文化底蕴一大精华，当我们程序员和成语联系上了，就有了下面这些火的不行的新兴成语。\n左右逢猿释义\n\n\n\n\n\n\n\n\n\n指需求评审会时，前后左右都是程序猿，舌战群猿，以一敢多的场面。\n我感觉也可以叫舌战群猿了，想必这种场景，大家应该都经历过。需求评审时，为了给自己多争取一点开发时间，又或者拒绝不合理的需求的时候，是免不了一场口舌之争的。所以说左右逢猿和舌战群猿也不为过。\n破竞难猿释义\n\n\n\n\n\n\n\n\n\n指拿着竞品为难程序猿，责问：“为什么别人能做，我们微不了”时的场景。\n这个我觉得也有个近义词那就是 强猿所难😣，也不看看我们这群程序猿的技术水平，能满足产品经理的天马行空的想法？真的是强猿所难和破竞难猿了\n阴晴猿缺释义：\n\n\n\n\n\n\n\n\n\n指因甲方的需求阴晴不定，导致程序猿吐血而亡造成的猿力短缺。\n俗话说：人有悲欢离合，月有阴晴圆缺，此事古难全，但愿人长久，千里共婵娟我们程序猿也有阴晴猿缺，这种情况多是在被甲方飘忽不定的需求折磨所致，就仿佛女生的脾气一样阴晴不定，最终导致程序猿吐血而亡造成的猿力短缺。\n心火燎猿释义：\n\n\n\n\n\n\n\n\n\n指程序猿内心愤怒，却因口才有限，一时间无法反驳的场景。\n这个也正常，咱们程序猿，一心埋头代码，两耳不闻窗外事。没有那么多的小心思，不善交际，自然也不善口舌之争，所以在口才和和扯皮撕*方面就略输一筹。在这种场面只能受委屈，哑巴吃黄连，有苦说不出\n花好约猿释义：\n\n\n\n\n\n\n\n\n\n指花儿开得正好，周末无比美妙，为了增长技术,却约程序猿一起到公司加班。\n这种程序猿一看就没男朋友/女朋友，都知道程序员大多996，好不容易有个周末，居然还去主动加班，这种大概就是传说中的卷王吧\n开猿节流释义：\n\n\n\n\n\n\n\n\n\n指项目稳定后，公司利润不在增长，只能通过开除程序猿节省用人成本。\n这不就是卸磨杀驴(猿)嘛，不过当前环境下，也属实无奈呀，老猿泪纵横了，猿猿自危\n三朝猿老释义：\n\n\n\n\n\n\n\n\n\n指需求频繁变更超过三次后，程序猿的脸色以肉眼可见的速度开始衰老。\n这个我就比较有发言权了，我相信应该没有程序猿是不讨厌需求频繁变更的。不过这个时候又有什么办法呢，代码💩上继续改。衰老的不仅仅是我们的脸色，还有秀发👨🏻‍🦲\n功成猿满释义：\n\n\n\n\n\n\n\n\n\n指项目大获成功，老板开始觉得程序猿人数太多，工作不够饱和。\n达到圆满境，下一步就该飞升了。\n自猿其说释义\n\n\n\n\n\n\n\n\n\n指程序猿有一套自己的语言规范，和程序猿沟通时，必须按照其语言规范来说话。\n那肯定，我们首先要用自己的技术为公司赋能，没有用心沉淀，共创生态，导致无法落地，拉通两端需求，打法日趋落后，点线面打不出组合拳，高中低层无法合理，发力也做不到精细化，对小商企没有资源倾斜，聚焦他们痛点，跟进布局，达不到快速响应，因此玩法被动，而上半场只顾去中心化，下半场认知乏力，最终形成不了降维打击，双十一之后再无引爆点，串联不起各自流量，链路断裂，赛道落后，落盘做不到闭环，也不愿抽离，再不加速感知度，打磨用户画像，洞察商业模式，实现渠道下沉，颠覆现存，推进迭代导流，那么粘性尽失，头部腰部做不到精准布局，拥抱变化，最后战略踩空，因此把控力尽失将到，为此我再次怀着改变世界的价值观，倒逼体系变化，重组布局，复盘中台，摸索并联动输出，加速载体因子裂变，拆解组织，梳理脉路，建立新的生命周期，强化整体认知，增加结果导向，重新闭环。\n如果底层逻辑打不通信息屏障，行业生态赋能不足，差异化和颗粒度磨平，导致垂直领域打法单一，归因分析又做不到抓手协同，此次吴泳铭（东邪）出山，相信矩阵重布，响应市场需求，以方法论论事，在维度，颗粒度更加扩展，完善逻辑，ALL IN。终华山之巅再领风骚。\n你还知道哪些关于程序猿的成语，欢迎留言评论分享。🐵🙈🙉🙊\n\n","slug":"面试/程序猿的专属成语,你get√了嘛","date":"2023-10-03T02:46:35.000Z","categories_index":"其他","tags_index":"其他","author_index":"前端少年汪"},{"id":"e50c25fa9f1096a4e3c98adde2f89a84","title":"Flutter开发环境的搭建","content":"\n文章目录\n  flutter SDK\n  Android Studio\n最简单的创建流程\n  常用命令\n  在真机安装联调\n\n\n\nflutter SDK\n 官网下载最新的SDK https://flutter.cn/docs/get-started/install/windows\n 解压到你需要安装的目录，解压就是安装了\n\n\n\n\n配置环境变量（很重要）\n\n\n\n你自己的路径\\flutter\\bin\nexport PUB_HOSTED_URL = https://pub.flutter-io.cn\n export FLUTTER_STORAGE_BASE_URL = https://storage.flutter-io.cn\n 配置ANDROID_HOME的环境变量\n\n\n  你自己选择的路径\\androidSDK\n\n\n\n6. dart SDK在 flutter/bin/cache/dart-sdk\n检测环境搭建是否成功终端运行flutter doctor\n\nAndroid Studio\n 官网下载 https://developer.android.google.cn/studio\n 按照安装向导提示安装即可，代理设置自动选择，也可以手动选择\n\n\n\n\n \n 安装完成后，安装对应的flutter和dart插件\n\n\n\n\n 创建flutter应用，创建虚拟设备，也可以连接手机真机调试\n\n\n最简单的创建流程\n  按照官网去装环境\n  flutter create\n\n\n\n\n  flutter run\n  然后会自动打开一个chrome页面 显示界面了\n\n常用命令\n\n\n命令\n作用\n\n\n\nflutter\n列出所有命令\n\n\nflutter help\n获取帮助信息\n\n\nflutter –version\n查看当前flutter和dart版本\n\n\nflutter upgrade\n升级flutter\n\n\nflutter doctor [-v]\n检查开发环境状态\n\n\n—\n—\n\n\nflutter create project_name\n新建一个flutter项目\n\n\nflutter pub/packages get\n安装依赖\n\n\nflutter packages upgrade\n升级依赖\n\n\nflutter run [-d 设备名称]\n运行到指定设备\n\n\nflutter clean\n清空build目录\n\n\n—\n—\n\n\nflutter emulators\n列出可用的模拟器\n\n\nflutter devices\n列出可用的设备\n\n\nopen -a Simulator\n打开一个模拟器\n\n\nflutter emulators –launch apple_ios_simulator\n打开一个模拟器\n\n\n—\n—\n\n\nflutter build apk [–release –target-platform android-arm64]\n生成指定架构的apk包\n\n\nflutter build ios\niOS打包 这一步并不能生成ipa文件，需要使用Xcode 打包\n\n\nflutter install\n安装app到设备\n\n\nflutter run –release\n发布版本测试需要连接真机方能调试。\n\n\n在真机安装联调其他 国内需要设置镜像，否则更新下载失败，参考\nFlutter中文网\nDart中文网\n\n\n\n\n\n\n\n\n\n如果有问题欢迎评论区留言或者关注我的微信公众号：前端少年汪如果本文对您有帮助，欢迎一键三连，谢谢\n","slug":"跨平台/Flutter开发环境的搭建","date":"2023-09-04T14:46:35.000Z","categories_index":"技术,环境搭建,Flutter","tags_index":"Flutter 跨平台 dart 环境搭建","author_index":"前端少年汪"},{"id":"3784c434b9d2280c614786da4cbc7955","title":"deno入门教程","content":"下一代JavaScript Runtime\nDeno 是一个由 Node.js 的创始人 Ryan Dahl 开发的现代化 JavaScript/TypeScript 运行时环境。它旨在提供安全、简单和高性能的方式来构建 JavaScript 和 TypeScript 应用程序。\n以下是 Deno 的一些主要特点：\n\n 安全性：与 Node.js 不同，Deno 默认情况下对文件系统、网络和环境变量等访问权限进行了严格的限制。在运行脚本时，用户必须显式地授予这些权限，以确保更高的安全性。\n 支持 TypeScript：Deno 内置对 TypeScript 的原生支持，无需额外的配置或插件。这意味着您可以直接编写 TypeScript 代码，而无需先进行转换或编译。\n 单一可执行文件：Deno 可以作为一个单一可执行文件进行分发，无需依赖于外部的运行时环境或包管理器。这使得安装和部署变得非常简单。\n 内置工具：Deno 包含一些内置的实用工具，如便捷的标准库、调试器和测试运行器，这些使得开发过程更加高效。\n 支持 ECMAScript 模块：Deno 使用标准的 ECMAScript 模块（ESM）语法进行模块化，无需像在 Node.js 中那样使用 CommonJS 或其他转换工具。\n 自包含性：Deno 鼓励开发者编写自包含的应用程序，即将所有依赖项打包到一个单独的可执行文件中，从而简化部署和分发过程。\n\n总体来说，Deno 的设计目标是提供一个安全、现代化和易用的 JavaScript/TypeScript 运行时环境，使得开发者能够更轻松地构建高质量的应用程序。\n\nSecure by default \nNative support for TypeScript and JSX\nTesting, linting, formatting, and more out of the box\nHigh performance async I/O with Rust and Tokio\nBackwards compatible with Node.js and npm\n\n以上就是Deno的五大特性：\n\n默认情况下安全。\n本机支持TypeScrip和JSX。\n测试、布线、格式化以及更多开箱即用功能。\n使用Rust和Tokio的高性能异步I/O。\n向后兼容Node.js和NPM。\n\n文档传送门：deno官网  \n安装终端执行：MacOS: curl -fsSL https://deno.land/x/install/install.sh | shWindow: irm https://deno.land/install.ps1 | iexLinux: curl -fsSL https://deno.land/x/install/install.sh | sh\n# Shell (Mac, Linux):\n$ curl -fsSL https:&#x2F;&#x2F;deno.land&#x2F;install.sh | sh\n\n# PowerShell (Windows):\n$ iwr https:&#x2F;&#x2F;deno.land&#x2F;install.ps1 -useb | iex\n\n# Homebrew (Mac):\n$ brew install deno\n\n# Chocolatey (Windows):\n$ choco install deno\n\n# Scoop (Windows):\n$ scoop install deno\n\n# Build and install from source using Cargo:\n$ cargo install deno --locked\n\n设置环境变量mac/linux\nexport DENO_INSTALL&#x3D;&quot;&#x2F;Users&#x2F;wmq&#x2F;.deno&quot; \nexport PATH&#x3D;&quot;$DENO_INSTALL&#x2F;bin:$PATH&quot;\nwindow我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量设置，上面用户变量和系统变量都可以配置。\n那就需要设置在path的环境变量里添加一条\n另一个环境变量就是 DENO_INSTALL了，与Linux一样，通常是$HOME/.deno，比如我的是C:\\Users\\Administrator.deno，把它的bin目录添加到path中。\n验证一下安装是否成功deno -V\n\nHello World运行deno不仅仅可以运行javascript，还支持直接运行ts文件\n\nexport function add(a: number, b: number): number &#123;\n    return a + b;\n&#125;\n\n&#x2F;&#x2F; Learn more at https:&#x2F;&#x2F;deno.land&#x2F;manual&#x2F;examples&#x2F;module_metadata#concepts\nif (import.meta.main) &#123;\n    console.log(&quot;Add 2 + 3 &#x3D;&quot;, add(2, 3));\n&#125;\n\nconsole.log(&#39;hello world&#39;)\n\n\n\n\n\ndeno常用运行命令和node一样，要查看帮助说明，敲一下demo -h就会出现\n\nUsage: deno [OPTIONS] [COMMAND]\n\nCommands:\n  run          Run a JavaScript or TypeScript program\n  bench        Run benchmarks\n  bundle       Bundle module and dependencies into single file\n  cache        Cache the dependencies\n  check        Type-check the dependencies\n  compile      Compile the script into a self contained executable\n  completions  Generate shell completions\n  coverage     Print coverage reports\n  doc          Show documentation for a module\n  eval         Eval script\n  fmt          Format source files\n  init         Initialize a new project\n  info         Show info about cache or info related to source file\n  install      Install script as an executable\n  jupyter      Deno kernel for Jupyter notebooks\n  uninstall    Uninstall a script previously installed with deno install\n  lsp          Start the language server\n  lint         Lint source files\n  repl         Read Eval Print Loop\n  task         Run a task defined in the configuration file\n  test         Run tests\n  types        Print runtime TypeScript declarations\n  upgrade      Upgrade deno executable to given version\n  vendor       Vendor remote modules into a local directory\n  help         Print this message or the help of the given subcommand(s)\n\nOptions:\n      --unstable\n          Enable unstable features and APIs\n      --unstable-bare-node-builtins\n          Enable unstable bare node builtins feature [env:\n          DENO_UNSTABLE_BARE_NODE_BUILTINS&#x3D;]\n      --unstable-byonm\n          Enable unstable &#39;bring your own node_modules&#39; feature [env:\n          DENO_UNSTABLE_BYONM&#x3D;]\n      --unstable-broadcast-channel\n          Enable unstable &#96;BroadcastChannel&#96; API\n      --unstable-ffi\n          Enable unstable FFI APIs\n      --unstable-fs\n          Enable unstable file system APIs\n      --unstable-kv\n          Enable unstable Key-Value store APIs\n      --unstable-net\n          Enable unstable net APIs\n      --unstable-http\n          Enable unstable HTTP APIs\n      --unstable-worker-options\n          Enable unstable Web Worker APIs\n      --unstable-cron\n          Enable unstable Deno.cron API\n  -q, --quiet\n          Suppress diagnostic output\n  -h, --help\n          Print help (see more with &#39;--help&#39;)\n  -V, --version\n          Print version\n\nENVIRONMENT VARIABLES:\n    DENO_AUTH_TOKENS     A semi-colon separated list of bearer tokens and\n                         hostnames to use when fetching remote modules from\n                         private repositories\n                         (e.g. &quot;abcde12345@deno.land;54321edcba@github.com&quot;)\n    DENO_TLS_CA_STORE    Comma-separated list of order dependent certificate\n                         stores. Possible values: &quot;system&quot;, &quot;mozilla&quot;.\n                         Defaults to &quot;mozilla&quot;.\n    DENO_CERT            Load certificate authority from PEM encoded file\n    DENO_DIR             Set the cache directory\n    DENO_INSTALL_ROOT    Set deno install&#39;s output directory\n                         (defaults to $HOME&#x2F;.deno&#x2F;bin)\n    DENO_REPL_HISTORY    Set REPL history file path\n                         History file is disabled when the value is empty\n                         (defaults to $DENO_DIR&#x2F;deno_history.txt)\n    DENO_NO_PACKAGE_JSON Disables auto-resolution of package.json\n    DENO_NO_PROMPT       Set to disable permission prompts on access\n                         (alternative to passing --no-prompt on invocation)\n    DENO_NO_UPDATE_CHECK Set to disable checking if a newer Deno version is\n                         available\n    DENO_V8_FLAGS        Set V8 command line options\n    DENO_JOBS            Number of parallel workers used for the --parallel\n                         flag with the test subcommand. Defaults to number\n                         of available CPUs.\n    HTTP_PROXY           Proxy address for HTTP requests\n                         (module downloads, fetch)\n    HTTPS_PROXY          Proxy address for HTTPS requests\n                         (module downloads, fetch)\n    NPM_CONFIG_REGISTRY  URL to use for the npm registry.\n    NO_COLOR             Set to disable color\n    NO_PROXY             Comma-separated list of hosts which do not use a proxy\n                         (module downloads, fetch)\n使用方法大大概是和node差不多的，没有什么上手的难度和负担。\ndeno权限默认情况下，Deno是安全的。因此 Deno 模块没有文件、网络或环境的访问权限，除非您为它授权。在命令行参数中为 deno 进程授权后才能访问安全敏感的功能。 在以下示例中，mod.ts 只被授予文件系统的只读权限。它无法对其进行写入，或执行任何其他对安全性敏感的操作。 deno run –allow-read mod.ts\n权限列表以下权限是可用的： \n\n-A, –allow-all 允许所有权限，这将禁用所有安全限制。\n–allow-env 允许环境访问，例如读取和设置环境变量。 \n–allow-hrtime 允许高精度时间测量，高精度时间能够在计时攻击和特征识别中使用。\n--allow-net=&lt;allow-net&gt; 允许网络访问。您可以指定一系列用逗号分隔的域名，来提供域名白名单。 \n–allow-plugin 允许加载插件。请注意：这是一个不稳定功能。 \n--allow-read=&lt;allow-read&gt; 允许读取文件系统。您可以指定一系列用逗号分隔的目录或文件，来提供文件系统白名单。    \n–allow-run 允许运行子进程。请注意，子进程不在沙箱中运行，因此没有与 deno 进程相同的安全限制，请谨慎使用。 \n--allow-write=&lt;allow-write&gt; 允许写入文件系统。您可以指定一系列用逗号分隔的目录或文件，来提供文件系统白名单。\n\n权限白名单Deno 还允许您使用白名单控制权限的粒度。 这是一个用白名单限制文件系统访问权限的示例，仅允许访问 /usr 目录，但它会在尝试访问 /etc 目录时失败。\n$ deno run --allow-read&#x3D;&#x2F;usr https:&#x2F;&#x2F;deno.land&#x2F;std&#x2F;examples&#x2F;cat.ts &#x2F;etc&#x2F;passwderror: Uncaught PermissionDenied: read access to &quot;&#x2F;etc&#x2F;passwd&quot;, run again with the --allow-read flag► $deno$&#x2F;dispatch_json.ts:40:11    at DenoError ($deno$&#x2F;errors.ts:20:5)    ...\n\n改为 /etc目录，赋予正确的权限，再试一次： deno run --allow-read=/etc https://deno.land/std/examples/cat.ts /etc/passwd --allow-write也一样，代表写入权限。\n网络访问fetch.ts:const result &#x3D; await fetch(&quot;https:&#x2F;&#x2F;deno.land&#x2F;&quot;);\n\n这是一个设置 host 或 url 白名单的示例：\ndeno run --allow-net&#x3D;github.com,deno.land fetch.ts\n\n如果 fetch.ts 尝试与其他域名建立网络连接，那么这个进程将会失败。 允许访问任意地址：\ndeno run --allow-net fetch.ts\n\n\n创建deno项目使用 Deno 开始一个新项目一直非常简单：你只需要一个单独的文件就可以开始了。无需任何配置文件、依赖清单或者构建脚本。\n来自其他生态系统的用户通常不习惯这种简单性——他们经常寻找一个工具来生成一个基本的项目结构，并使他们在正确的方向上开始。deno init 子命令创建了一个基本的 Deno 项目脚手架。\n$ deno init\n✅ 项目已初始化\n运行以下命令来开始\n\n  &#x2F;&#x2F; 运行程序\n  deno run main.ts\n\n  &#x2F;&#x2F; 运行程序并监视文件更改\n  deno task dev\n\n  &#x2F;&#x2F; 运行测试\n  deno test\n\n  &#x2F;&#x2F; 运行基准测试\n  deno bench\n\n$ deno run main.ts\nAdd 2 + 3 &#x3D; 5\n\n$ deno test\n检查文件:&#x2F;&#x2F;&#x2F;dev&#x2F;main_test.ts\nmain_test.ts 执行 1 个测试\naddTest ... ok (6ms)\n\nok | 1 passed | 0 failed (29ms)\n这个子命令会创建两个文件(main.ts和 main_test.ts)。这些文件提供了一个编写 Deno 程序和编写测试的基本示例。main.ts 文件导出一个 add 函数，它将两个数字相加，而 main_test.ts 文件包含此函数的一个测试。\n你也可以给 deno init 指定一个参数来在特定目录中初始化一个项目：\n$ deno init my_deno_project\n✅ 项目已初始化\n\n运行以下命令来开始\n\n  cd my_deno_project\n\n  &#x2F;&#x2F; 运行程序\n  deno run main.ts\n\n  &#x2F;&#x2F; 运行程序并监视文件更改\n  deno task dev\n\n  &#x2F;&#x2F; 运行测试\n  deno test\n\n  &#x2F;&#x2F; 运行基准测试\n  deno bench\n\n在创建项目之后会有一个main.ts文件里面有一些示例代码\n\nexport function add(a: number, b: number): number &#123;\n  return a + b;\n&#125;\n\n&#x2F;&#x2F; Learn more at https:&#x2F;&#x2F;deno.land&#x2F;manual&#x2F;examples&#x2F;module_metadata#concepts\nif (import.meta.main) &#123;\n  console.log(&quot;Add 2 + 3 &#x3D;&quot;, add(2, 3));\n&#125;\n\n在 Deno 中，import.meta 对象包含了与模块加载相关的元数据信息。其中，import.meta.main 是一个布尔值，用于指示模块是否被直接执行（即作为入口模块）。如果一个模块被直接执行，则 import.meta.main 的值为 true，否则为 false。\n导入导出模块在 Deno 中，导入和导出模块的语法与 Node.js 有一些不同之处。 \n导入模块在 Deno 中，要导入其他模块，可以使用类似于 ES 模块的 import 语法。例如：\nimport &#123; someFunction &#125; from &#39;.&#x2F;someModule.ts&#39;;\n\n与 Node.js 不同的是，Deno 默认支持 ES 模块，因此不需要像在 Node.js 中那样使用 require 函数。此外，Deno 支持在代码中直接引用 URL 进行远程模块的导入，这是 Node.js 所不具备的特性。\n导出模块在 Deno 中，模块的导出方式也与 Node.js 有所不同。在 Deno 中，默认情况下所有声明都是私有的，如果要将某些内容导出，需要使用 export 关键字进行显式导出。例如：\n&#x2F;&#x2F; someModule.ts\nexport function someFunction() &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\n在 Node.js 中，可以使用 module.exports 或 exports 导出模块内容，而在 Deno 中，使用 export 关键字则可以明确指定要导出的内容。\n另外，Deno 也支持使用默认导出（default export）的方式，与 Node.js 中的 module.exports = ... 以及 export default ... 语法类似，但具体的语法细节和使用方式可能会有所不同。\n Deno 中的模块导入导出语法更加符合标准的 ES 模块规范，并且对远程模块的支持更为友好，这是与 Node.js 最主要的区别之一。\n第三方模块导入在 Deno 中，您可以使用 ES 模块语法导入第三方依赖。以下是一些常见的导入第三方依赖的方式：\n\n从 URL 导入：您可以直接从公共 URL 导入依赖项。例如：\nimport &#123; serve &#125; from &quot;https:&#x2F;&#x2F;deno.land&#x2F;std&#x2F;http&#x2F;server.ts&quot;;\n从本地文件系统导入：您可以将第三方库下载到本地，并使用相对或绝对路径进行导入。例如：\nimport &#123; serve &#125; from &quot;.&#x2F;path&#x2F;to&#x2F;library.ts&quot;;\n请确保您已将第三方库下载到正确的位置并提供正确的路径。\n\n使用 URL 和版本号导入：如果您希望使用特定版本的依赖项，可以在 URL 后添加版本号。例如：\nimport &#123; serve &#125; from &quot;https:&#x2F;&#x2F;deno.land&#x2F;std@0.100.0&#x2F;http&#x2F;server.ts&quot;;\n这将导入 std 库的 0.100.0 版本中的 serve 函数。\n\n使用 import maps 导入：您还可以在 Deno 的 import map 中设置别名来导入第三方依赖项。首先，在项目根目录创建一个名为 import_map.json 的文件，然后添加依赖项的别名和 URL。例如：\n&#123;\n  &quot;imports&quot;: &#123;\n    &quot;lodash&quot;: &quot;https:&#x2F;&#x2F;cdn.skypack.dev&#x2F;lodash&quot;\n  &#125;\n&#125;\n然后，您可以在代码中使用别名导入依赖项：\nimport _ from &quot;lodash&quot;;\n这会将 lodash 库导入为 _。\n\n\n请确保网络连接正常，以便 Deno 能够从指定的 URL 导入依赖项。此外，还要注意您导入的第三方库是否与 Deno 兼容。\ndeno.json在 Deno 中，deno.json 是一个用于配置项目的文件，类似于其他项目中常见的 package.json 或 tsconfig.json。它用于指定 Deno 项目的依赖项、脚本入口点等信息。以下是 deno.json 文件可能包含的一些常见配置选项：\n\n&quot;name&quot;：指定项目的名称。\n\n&quot;main&quot;：指定项目的主入口文件。\n\n&quot;scripts&quot;：定义一组脚本命令，以便在项目中运行特定的任务或操作。\n\n&quot;dependencies&quot;：列出项目所依赖的第三方模块及其版本信息。\n\n&quot;importmap&quot;：指定 import map 的路径，用于配置模块的别名或重定向。\n\n&quot;permissions&quot;：指定项目所需的权限，例如文件系统访问、网络访问等。\n\n\n一个简单的 deno.json 文件可能如下所示：\n&#123;\n  &quot;name&quot;: &quot;my-deno-project&quot;,\n  &quot;main&quot;: &quot;main.ts&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;start&quot;: &quot;deno run main.ts&quot;\n  &#125;,\n  &quot;dependencies&quot;: &#123;\n    &quot;lodash&quot;: &quot;4.17.21&quot;\n  &#125;,\n  &quot;importmap&quot;: &quot;import_map.json&quot;,\n  &quot;permissions&quot;: &#123;\n    &quot;net&quot;: true,\n    &quot;read&quot;: true\n  &#125;\n&#125;\n\n deno.json 的具体结构和支持的配置选项可能会根据 Deno 版本的更新而有所变化，因此建议查阅官方文档以获取最新的信息和用法说明。\nDeno和Node的区别 Deno 和 Node.js 的区别，主要有以下几点：\n\n语言支持：\n\nNode.js 最初是专注于 JavaScript，后来添加了对 TypeScript 的支持。而 Deno 则内置支持 TypeScript，无需额外配置即可直接运行 TypeScript 代码。\n\n\n包管理：\n\n在 Node.js 中，使用 npm 或 yarn 等包管理器来安装和管理依赖。而在 Deno 中，模块的导入直接使用 URL，不需要像 Node.js 那样依赖于包管理器。\n\n\n安全性：\n\nDeno 默认情况下运行在沙盒环境中，只能访问明确授权的文件和网络资源，提供了更强大的安全性保障。而 Node.js 的安全性主要依赖于操作系统权限和开发者的注意。\n\n\n标准库：\n\nDeno 内置了许多常见的功能，如文件操作、HTTP 服务器等，因此在一定程度上减少了对外部库的依赖。而 Node.js 的核心功能相对较少，需要依赖第三方模块来实现更复杂的功能。\n\n\nAPI 设计：\n\nDeno 设计上更加现代化，采用了 Promise 风格的 API，并且避免了回调地狱（Callback Hell）的问题。而 Node.js 在早期主要采用回调函数的方式处理异步操作，后来引入了 Promise 和 async/await。\n\n\n工具支持：\n\nDeno 内置了一些实用工具，如代码格式化工具（deno fmt）、代码检测工具（deno lint）等，减少了对第三方工具的依赖。而 Node.js 需要依赖外部工具和插件来实现类似的功能。\n\n\n生态系统：\n\nNode.js 有着庞大的生态系统和成熟的社区支持，拥有丰富的第三方模块和工具。而 Deno 相对来说还比较年轻，生态系统尚在发展阶段，虽然也有一些优秀的模块，但整体规模不及 Node.js。\n\n\n\n这些是 Deno 和 Node.js 的一些主要区别，每个运行时环境都有其自身的优势和适用场景。选择使用哪个取决于具体的项目需求、团队技能和偏好等因素。\n","slug":"node/deno入门教程","date":"2023-08-03T16:46:35.000Z","categories_index":"Deno","tags_index":"deno runtime","author_index":"前端少年汪"},{"id":"8aa850786bf761363cb2e372eeaddd10","title":"Vue3中使用TailwindCSS","content":"前言当谈到前端开发框架时，Tailwind CSS 是一个备受瞩目的选择。它是一款功能强大且灵活的CSS框架，提供了大量的实用工具类，帮助开发者快速构建现代化的用户界面。在本篇技术博客中，我们将深入了解 Tailwind CSS 的主题和使用。\n\nTailwind CSS 是一种流行的现代化 CSS 框架，它提供了一套原子类（Atomic Classes）来构建网页界面，相较于传统的 CSS 框架，如Bootstrap或Foundation，Tailwind CSS 强调基于原子类的方式来构建界面，使得开发者可以更加灵活地组合和定制样式，而无需编写自定义的 CSS。\n以下是 Tailwind CSS 的一些重要特点和概念：\n\n原子类：Tailwind CSS 的核心理念是原子类，它提供了大量的类名，每个类名对应一个特定的样式属性。通过组合这些原子类，开发者可以快速地构建出所需的样式，例如 bg-red-500 代表设置背景色为红色，text-xl 代表设置文本大小为大号等。\n\n工具类：除了常见的样式属性外，Tailwind CSS 还提供了丰富的实用工具类，如布局、间距、边框等，这些工具类可以帮助开发者快速地实现响应式设计和布局。\n\n定制化：Tailwind CSS 提供了丰富的配置选项，允许开发者根据项目需求定制自己的样式，包括颜色、字体、间距等，从而使得每个项目的样式都可以高度定制。\n\n响应式设计：Tailwind CSS 内置了响应式设计的工具类，使得开发者可以轻松地编写出适配不同屏幕尺寸的样式。\n\n插件系统：Tailwind CSS 具有强大的插件系统，允许开发者编写定制的插件来扩展框架的功能，例如添加新的样式类或工具类。\n\n\n总的来说，Tailwind CSS 提供了一种非常灵活的方式来构建网页界面，它与传统的 CSS 框架在思维方式上有很大的区别，更加强调原子化的样式组合和定制化。许多开发者认为使用 Tailwind CSS 可以显著提高开发效率，并且使得样式更加可维护和可预测。\n安装和配置要开始使用 Tailwind CSS，首先需要通过 npm 或 yarn 安装它：\n# 使用 npm 安装\nnpm install tailwindcss\n\n# 使用 yarn 安装\nyarn add tailwindcss\n\n安装完成后，可以通过运行以下命令来生成默认的配置文件和样式表：\nnpx tailwindcss init\n\n生成的默认配置文件名为 tailwind.config.js，我们可以在其中对颜色、字体、间距等属性进行自定义配置。接下来，需要创建一个 CSS 文件，并导入 Tailwind CSS 的样式：\n&#x2F;* styles.css *&#x2F;\n@import &#39;tailwindcss&#x2F;base&#39;;\n@import &#39;tailwindcss&#x2F;components&#39;;\n@import &#39;tailwindcss&#x2F;utilities&#39;;\n\n使用实用工具类Tailwind CSS 提供了丰富的实用工具类，涵盖了各种样式属性。让我们通过一个简单的示例来演示如何使用这些工具类。假设我们要创建一个带有蓝色背景和居中文本的按钮，可以这样写：\n&lt;button class&#x3D;&quot;bg-blue-500 text-white font-bold py-2 px-4 rounded&quot;&gt;\n  Click me\n&lt;&#x2F;button&gt;\n\n在这个例子中，我们使用了 bg-blue-500 类来设置按钮的背景颜色为蓝色，text-white 类来设置文本颜色为白色，font-bold 类来设置文本加粗，py-2 和 px-4 类来设置垂直和水平方向上的内边距，rounded 类来设置圆角边框。\n自定义配置除了使用默认的实用工具类之外，Tailwind CSS 还支持自定义配置。例如，可以修改默认的颜色、字体、间距等属性。让我们在 tailwind.config.js 中添加一些自定义配置：\n&#x2F;** @type &#123;import(&#39;tailwindcss&#39;).Config&#125; *&#x2F;\nexport default &#123;\n  content: [\n    &quot;.&#x2F;index.html&quot;,\n    &quot;.&#x2F;src&#x2F;**&#x2F;*.&#123;vue,js,ts,jsx,tsx&#125;&quot;,\n  ],\n  theme: &#123;\n    extend: &#123;&#125;,\n  &#125;,\n  plugins: [],\n&#125;\n\n在这个例子中，我们扩展了颜色配置，添加了一个名为 primary 的自定义颜色；同时扩展了字体配置，添加了一个名为 sans 的自定义字体。\n示例\n\n&lt;script setup&gt;\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;div class&#x3D;&quot;bg-white dark:bg-slate-800 rounded-lg px-6 py-8 ring-1 ring-slate-900&#x2F;5 shadow-xl&quot;&gt;\n      &lt;div&gt;\n    &lt;span class&#x3D;&quot;inline-flex items-center justify-center p-2 bg-indigo-500 rounded-md shadow-lg&quot;&gt;\n      &lt;svg class&#x3D;&quot;h-6 w-6 text-white&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; fill&#x3D;&quot;none&quot; viewBox&#x3D;&quot;0 0 24 24&quot; stroke&#x3D;&quot;currentColor&quot; aria-hidden&#x3D;&quot;true&quot;&gt;&lt;&#x2F;svg&gt;\n    &lt;&#x2F;span&gt;\n      &lt;&#x2F;div&gt;\n      &lt;h3 class&#x3D;&quot;text-slate-900 dark:text-white mt-5 text-base font-medium tracking-tight&quot;&gt;Writes Upside-Down&lt;&#x2F;h3&gt;\n      &lt;p class&#x3D;&quot;text-slate-500 dark:text-slate-400 mt-2 text-sm&quot;&gt;\n        The Zero Gravity Pen can be used to write in any orientation, including upside-down. It even works in outer space.\n      &lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;style scoped&gt;\n\n&lt;&#x2F;style&gt;\n\n结语总结一下，Tailwind CSS 是一个强大而灵活的前端开发框架，通过提供丰富的实用工具类，帮助开发者快速构建现代化的用户界面。它的无样式预设和可定制配置使得开发者能够更好地控制样式，并与其他前端工具和框架无缝集成。如果你正在寻找一种新的方式来开发 Web 应用程序，不妨尝试一下 Tailwind CSS。\n通过以上介绍，相信你已经对 Tailwind CSS 有了初步的了解。希望这篇技术博客能够帮助你更好地掌握和应用 Tailwind CSS，为你的下一个项目带来便利和高效！\n","slug":"css/Vue3中使用TailwindCSS","date":"2023-07-10T14:46:35.000Z","categories_index":"TailwindCSS","tags_index":"css","author_index":"前端少年汪"},{"id":"644c16caca9a76ed91ed819723a4678a","title":"一文带你了解最新的CSS原生嵌套语法！","content":"\n前言\n\n\n\n\n\n\n\n\nCSS nesting provides the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of the parent rule. Similar behavior previously required a CSS pre-processor.   \n\n\n\n\n\n\n\n\n\nCSS嵌套提供了将一个样式规则嵌套在另一个样式中的能力，子规则的选择器相对于父规则的选择器。类似的行为以前需要CSS预处理器。\n\n在Web开发中，CSS是一种关键的技术，用于样式化HTML元素。而为了更好地组织和管理样式代码，CSS原生嵌套语法应运而生。本文将带你深入了解CSS原生嵌套语法，探索其用法、特性和优势。\n\n什么是CSS原生嵌套语法？CSS原生嵌套语法是一种CSS预处理器中常见的语法，它允许我们在样式表中使用嵌套的规则和选择器来组织样式代码。通过嵌套语法，我们可以更清晰地表示元素之间的层级关系，提高代码的可读性和维护性。\n\n基本语法规则\n\n\n\n选择器嵌套：在嵌套语法中，我们可以使用父元素的选择器作为子元素的前缀，以表示它们之间的层级关系。例如，ul li选择器表示选中所有父元素为ul的子元素为li的元素。\n属性嵌套：除了选择器嵌套外，我们还可以在嵌套语法中使用属性嵌套。例如，使用font属性时，我们可以使用font-size、font-weight等相关属性来设置字体的样式。这样可以更好地组织和管理属性相关的代码。\n伪元素嵌套：CSS原生嵌套语法还支持伪元素的嵌套。例如，我们可以使用::after伪元素来添加内容，并在其中定义样式。\n\n\n继承与覆盖CSS原生嵌套语法具有继承和覆盖的特性。当子元素嵌套在父元素内部时，它会继承父元素的样式属性，从而减少代码的重复性。同时，如果需要覆盖父元素的样式，只需在子元素中重新定义该属性即可。\n\n嵌套选择器的应用嵌套选择器是CSS原生嵌套语法的一大亮点，它能够帮助我们编写更具可读性和维护性的选择器。通过嵌套选择器，我们可以更准确地选择特定的元素，并避免使用过于具体的选择器。这使得我们的样式表更加简洁和可扩展。\n\n注意事项在使用CSS原生嵌套语法时，需要注意以下几点：\n\n\n\n避免过度嵌套：过多的嵌套可能会导致代码难以阅读和理解，应尽量保持嵌套层级的简洁性。\n选择器优先级：在嵌套语法中，选择器的优先级可能会增加。因此，在编写样式时，需要注意选择器的权重，以避免产生意外的结果。\n\n让我们来看看 CSS 嵌套语法是如何使用的！从上面的浏览器版本支持来看（我使用的是谷歌浏览器）\n其中淡紫色是部分支持，绿色是完全支持。所以要先查看一下自己的浏览器的版本。\nvar browserVersion &#x3D; navigator.userAgent;\nconsole.log(browserVersion);\n\nMozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;118.0.0.0 Safari&#x2F;537.36\n我的浏览器是118.0.0.0,支持部分特性。\n嵌套，就是将一个 CSS 规则放在另一个（嵌套规则）中，子规则的选择器将相对于父规则的选择器。这有利于代码的模块化和可维护性。原来只能在 CSS 预处理器中使用的嵌套功能，现在在原生 CSS 中也可以使用。对比一下原生css嵌套和sass嵌套\nmain .colortable td &#123;  \n  text-align:center;  \n&#125;  \n  \nmain .colortable td.c &#123;  \n  text-transform:uppercase;  \n&#125;  \n  \nmain.colortable td:first-child, table.colortable td:first-child+td &#123;  \n  border:1px solid black;  \n&#125;  \n  \nmain.colortable th &#123;  \n  text-align:center;  \n  background:black;  \n  color:white;  \n&#125;\n\n如果使用 CSS 嵌套时，就是这样的：\nmain.colortable &#123;  \n  &amp; td &#123;  \n    text-align:center;  \n    &amp;.c &#123; text-transform:uppercase &#125;  \n    &amp;:first-child, &amp;:first-child + td &#123; border:1px solid black &#125;  \n  &#125;  \n  &amp; th &#123;  \n    text-align:center;  \n    background:black;  \n    color:white;  \n  &#125;  \n&#125;\n使用嵌套不仅消除重复，相关规则的分组还提高了生成的 CSS 的可读性和可维护性。是不是好看多了\n嵌套的规则嵌套的规则可以使用嵌套选择器(&amp;)直接引用父规则的匹配元素，或者用相对选择器语法指定后代以外的关系\n.a &#123;  \n  color: red;  \n  \n  &amp;:hover &#123;  \n    color: blue;  \n  &#125;  \n&#125;  \n  \n&#x2F;* 相当于: *&#x2F;  \n  \n.a &#123; color: red; &#125;  \n.a:hover &#123; color: blue; &#125;\n\n.a &#123;  \n  color: red;  \n  \n  + .b &#123;  \n    color: blue;  \n  &#125;  \n&#125;  \n  \n&#x2F;* 相当于: *&#x2F;  \n  \n.a &#123; color: red; &#125;  \n.a + .b &#123; color: blue; &#125;\n嵌套选择器在使用嵌套规则时，必须能够引用父规则匹配的元素。为此，规范中定义了一个新的选择器，即嵌套选择器，写为 &amp; 。\n当在嵌套样式规则的选择器中使用时，嵌套选择器表示与父规则匹配的元素。当在任何其他上下文中使用时，它表示与该上下文中的 :scope 相同的元素。\n嵌套选择器可以通过 :is() 选择器将其替换为父样式规则的选择器。例如：\na, b &#123;  \n  &amp; c &#123; color: blue; &#125;  \n&#125;\n这就相当于\n:is(a, b) c &#123; color: blue; &#125;\n\n总结CSS原生嵌套语法是一种用于组织和管理样式代码的强大工具。通过选择器嵌套、属性嵌套和伪元素嵌套等基本语法规则，我们可以更好地表达元素之间的层级关系和样式属性。继承与覆盖的特性使得代码更具灵活性和可维护性。同时，嵌套选择器的应用能够提高选择器的可读性和可扩展性。然而，在使用CSS原生嵌套语法时，需要避免过度嵌套和注意选择器的优先级。通过合理地运用这些技巧，我们能够更高效地编写和维护CSS样式表，提升Web开发的效率。\n","slug":"css/一文带你了解最新的CSS原生嵌套语法！","date":"2023-06-10T14:46:35.000Z","categories_index":"css","tags_index":"css","author_index":"前端少年汪"},{"id":"063f99f939e2a1e1a5f4f8ebf1d3e74e","title":"一文带你搞懂浏览器的事件循环机制！","content":"什么是事件循环Event Loop 也叫做“事件循环”，它其实与 JavaScript 的运行机制有关，乍一看云里雾里，不用着急，读完本文你便会知晓它的含义，这一切都要从 JavaScript 的初始设计说起。  \n并发模型JavaScript 的并发模型是基于事件循环机制的，这个机制被称为 Event Loop。它是一种单线程的执行模型，但是它可以通过异步编程来支持并发操作，从而实现高效的非阻塞 IO 操作。\n在 JavaScript 中，所有的代码都是在同一个线程中执行的，这个线程被称为主线程或 UI 线程。当我们执行一段耗时较长的代码时，如果不采用异步编程的方式，那么这段代码将会阻塞主线程，导致整个应用程序变得不可响应。\n为了避免这种情况，JavaScript 引入了异步编程的概念。异步编程使用回调函数、Promise、async/await 等方式来实现，它允许我们在主线程上同时处理多个任务，而不必等待任务完成。\n在 JavaScript 中，异步任务通常被分为两类：宏任务和微任务宏任务包括:\n\nsetTimeout\nsetInterval\nI/O 操作等，\n\n微任务则包括:\n\nPromise\nMutationObserver 等。\n\n当主线程执行完当前的宏任务后，就会检查是否有微任务需要执行，如果有，则先执行微任务，然后再执行下一个宏任务。\nJavaScript 的并发模型基于事件循环机制，它通过异步编程来实现高效的非阻塞 IO 操作。在 JavaScript 中，异步任务被分为宏任务和微任务，它们的执行顺序是由事件循环机制控制的。通过合理地使用异步编程，我们可以在单线程的 JavaScript 中实现高效的并发操作。\n\n\n\n单线程进程和线程是操作系统中的概念，在操作系统中，一个任务就是一个进程，比如你在电脑上打开了一个浏览器来观看视频，便是打开了一个浏览器进程，此时又想记录视频中的重要信息，于是你打开了备忘录，这便是一个备忘录进程，系统会为每个进程分配它所需要的地址空间，数据，代码等系统资源。如果把一个进程看做一个小的车间，车间里有很多工人，有的负责操作机器，有的负责搬运材料，每个工人可以看做一个线程，线程可以共享进程的资源。可以说，线程是进程的最小单位，一个进程可以包含多个线程。  \nJavaScript 在设计之初便是单线程，程序运行时，只有一个线程存在，在特定的时候只能有特定的代码被执行。这和 JavaScript 的用途有关，它是一门浏览器脚本语言，通常是用来操作 DOM 的，如果是多线程，一个线程进行了删除 DOM 操作，另一个添加 DOM，此时该如何处理？所以 JavaScript 在设计之初便是单线程的。  \n虽然 HTML5 增加了 Web Work可用来另开一个线程，但是该线程仍受主线程的控制，所以 JavaScript 的本质依然是单线程。  \n执行栈和任务队列单线程的 JavaScript 一段一段地执行，前面的执行完了，再执行后面的，试想一个，如果前一个任务需要执行很久，比如接口请求、I/O 操作，此时后面的任务只能干巴巴地等待么？干等不仅浪费了资源，而且页面的交互程度也很差。JavaScript 意识到了这个问题，他们将任务分成了同步任务和异步任务，对于二者有不同的处理。  \n栈 Stack函数调用形成了一个由若干帧组成的栈。\nfunction foo(b) &#123;\n  let a &#x3D; 10;\n  return a + b + 11;\n&#125;\n\nfunction bar(x) &#123;\n  let y &#x3D; 3;\n  return foo(x * y);\n&#125;\n\nconsole.log(bar(7)); &#x2F;&#x2F; 返回 42\n\n当调用 bar 时，第一个帧被创建并压入栈中，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧被创建并被压入栈中，放在第一个帧之上，帧中包含 foo 的参数和局部变量。当 foo 执行完毕然后返回时，第二个帧就被弹出栈（剩下 bar 函数的调用帧）。当 bar 也执行完毕然后返回时，第一个帧也被弹出，栈就被清空了\n堆 Heap\n\n\n\n\n\n\n\n\n对象被分配在堆中，堆是一个用来表示一大块（通常是非结构化的）内存区域的计算机术语。\n在计算机科学中，堆（Heap）是一种常见的数据结构。它是一个特殊的完全二叉树（或者可以看作是一个数组），其中每个节点都满足堆属性。\n堆通常用于实现优先队列（Priority Queue）和动态的、可高效地找到最大或最小元素的数据结构。\n根据堆属性的不同，堆分为两种类型：\n\n最大堆（Max Heap）：在最大堆中，每个节点的值都大于或等于其子节点的值。这意味着堆的根节点具有最大的值。\n\n最小堆（Min Heap）：在最小堆中，每个节点的值都小于或等于其子节点的值。这意味着堆的根节点具有最小的值。\n\n\n堆的主要操作包括插入和删除操作：\n\n插入操作：将一个新元素插入堆中时，需要保持堆属性。具体操作是将元素添加到堆的末尾，然后通过与父节点比较并交换位置的方式向上调整堆，直到满足堆属性。\n\n删除操作：删除堆顶元素时，也需要保持堆属性。具体操作是将堆顶元素与堆的最后一个元素交换位置，然后删除堆的最后一个元素。接着，通过与子节点比较并交换位置的方式向下调整堆，直到满足堆属性。\n\n\n堆的插入和删除操作的时间复杂度都是 O(log n)，其中 n 是堆中元素的数量。这使得堆非常适合用于需要频繁地插入和删除元素的场景。\n值得注意的是，堆不是按照某种特定的排序顺序来排列元素的，而是确保根节点具有最大或最小的值。因此，除了找到最大或最小元素外，堆中的其他元素之间并没有特定的顺序关系。\n总结起来，堆是一种用于实现优先队列和高效查找最大或最小元素的数据结构。它具有快速的插入和删除操作，并且可以根据需要实现最大堆或最小堆。\n队列 Queue一个 JavaScript 运行时包含了一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。\n在 事件循环期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。\n函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。\nJavaScript 运行时JavaScript 在运行时会将变量存放在堆（heap）和栈（stack）中，堆中通常存放着一些对象，而变量及对象的指针则存放在栈中。JavaScript 在执行时，同步任务会排好队，在主线程上按照顺序执行，前面的执行完了再执行后面的，排队的地方叫执行栈（execution context stack）。JavaScript 对异步任务不会停下来等待，而是将其挂起，继续执行执行栈中的同步任务，当异步任务有返回结果时，异步任务会加入与执行栈不一样的队列，即任务队列（task queue），所以任务队列中存放的是异步任务执行完成后的结果，通常是回调函数。  \n当执行栈的同步任务已经执行完成，此时主线程闲下来，它便会去查看任务队列是否有任务，如果有，主线程会将最先进入任务队列的任务加入到执行栈中执行，执行栈中的任务执行完了之后，主线程便又去任务队列中查看是否有任务可执行。主线程去任务队列读取任务到执行栈中去执行，这个过程是循环往复的，这便是 Event Loop，事件循环。  \n网上有张流传甚广的图对这一过程进行了总结，在图中我们可以看到，JavaScript 在运行时产生了堆和栈，ajax、setTimeout 等异步任务被挂起，异步任务的返回结果加入任务队列，主线程会循环往复地读取任务队列中的任务，加入执行栈中执行。  \n\n为了更好的理解 JavaScript 的执行机制，我们来看个小例子。    console.log(1)\n\nsetTimeout(function() &#123;\n\nconsole.log(2)\n\n&#125;, 300)\n\nconsole.log(3)\n输出的结果是 1，3，2。setTimeout 是一个定时器，延迟 300 毫秒执行，所以 300 毫秒后，打印 2 的回调函数才会进入任务队列，等到执行栈中的代码执行完成后，也就是打印出 1 和 3 后，打印出 2 的回调函数才进入执行栈执行。  \n如果将 setTimeout 的第二个参数设置为 0，它表示主线程空闲之后尽早执行它的回调，HTML5 规定 setTimeout 的第二个参数不得小于 4 毫秒。  \n    setTimeout(function() &#123;\n\nconsole.log(1)\n\n&#125;, 0)\n\nconsole.log(2)\n\n\n&#x2F;&#x2F; 2,1\n对于 setTimeout 还有一个需要注意的是，它的延迟时间并不是等待多少毫秒后就一定会执行，始终是要等待主线程已经空闲了才会去读取它，如果执行栈中的任务需要很长时间才能执行完，那任务队列中的任务只能等待。我们可以通过一个例子来体验一下。    var enterTime &#x3D; Date.now()\n\n  \n\n\nfunction sleep(time) &#123;\n\nfor(var temp &#x3D; Date.now(); Date.now() - temp &lt;&#x3D; time;);\n\n&#125;\n\n  \n\n\nsetTimeout(function() &#123;\n\nvar exeTime &#x3D; Date.now()\n\nconsole.log(exeTime - enterTime)\n\n&#125;, 300)\n\n  \n\n\nsleep(1000) &#x2F;&#x2F; 睡眠 1 秒\n  \n我们定义了一个 sleep 函数，设置了 1 秒的执行时间，所以 setTimeout 要等待的时间肯定大于 1 秒，而不是 300 毫秒后就执行了。上述代码的执行结果是 1000 左右，值不固定，可以复制代码到控制台执行看看。  \n宏任务与微任务异步任务有更深一层的划分，它们是宏任务（macro task）和微任务（micro task），二者的执行顺序也有差别。在上面我们讲到异步任务的结果会进入任务队列中，对于不同的事件类型，宏任务会加入宏任务队列，微任务会加入微任务队列。  \n常见的宏任务有 script（整体代码），setTimeout，setInterval；常见的微任务有 new Promise、process.nextTick（node.js 环境）。  \n在执行栈空的时候，主线程会从任务队列中取任务来执行，其过程如下：1.选择最先进入队列的宏任务执行（最开始是 script 整体代码）2.检查是否存在微任务，如果存在，执行微任务队列中得所以任务，直至清空微任务队列3.重复以上步骤  \n我们来通过代码体验一下宏任务与微任务的执行顺序。    console.log(1)\n\nsetTimeout(function() &#123;\n\nconsole.log(2)\n\nnew Promise(function(resolve) &#123;\n\nconsole.log(3)\n\nresolve(4)\n\n&#125;).then(function(num) &#123;\n\nconsole.log(num)\n\n&#125;)\n\n&#125;, 300)\n\n\nnew Promise(function(resolve) &#123;\n\nconsole.log(5)\n\nresolve(6)\n\n&#125;).then(function(num) &#123;\n\nconsole.log(num)\n\n&#125;)\n\nsetTimeout(function() &#123;\n\nconsole.log(7)\n\n&#125;, 400)\n我们一步步来分析上面的执行顺序，这段代码作为宏任务进入主线程开始执行，首先打印出 1，然后遇到了 setTimeout，主程序将它挂起，300 毫秒后它的回调函数进入宏任务队列，我们记做 setTimeout1。随后遇到了 new Promise，resolve 部分是同步执行的，所以会打印出 5，then 中的回调函数进入微任务队列，我们暂时记做 promise1。最后是 setTimeout，同理在 400 毫秒后加入了宏任务队列，我们记做 setTimeout2。此时任务队列的情况如下：  \n\n\n\n宏任务\n微任务\n\n\n\nsetTimeout1\npromise1\n\n\nsetTimeout2\n\n\n\n此时已经执行完一个宏任务（script 整体代码），接着主线程查看微任务队列，发现存在微任务，于是把 promise1 执行了，打印出 6。此时微任务队列已经空了，任务队列的情况如下：  \n\n\n\n宏任务\n微任务\n\n\n\nsetTimeout1\n\n\n\nsetTimeout2\n\n\n\n以上便是一次循环。  \n接着主线程又开始查看宏任务队列，将 setTimeout1 的回调函数加入任务栈开始执行，于是首先打印出 2，之后是 3，再将 then 中的回调函数加入微任务队列，我们记做 promise2。此时任务队列的情况如下：  \n\n\n\n宏任务\n微任务\n\n\n\nsetTimeout2\npromise2\n\n\n此时执行栈也空了，于是将微任务 promise2 加入执行栈，打印出 4。此时微任务已经执行完，这便完成了第二次循环。然后再查看宏任务队列，于是执行 setTimeout2，打印出 7。所以代码中的输出顺序是 1，5，6，2，3，4，7。需要注意的是，主线程对微任务的读取是逐个读取，直到微任务队列为空。对宏任务队列的读取在一次循环中只读取一个。  \n小结在本节中，我们了解了 JavaScript 的运行机制，它是单线程的。JavaScript 中的任务可分为同步任务和异步任务，同步任务总是先进入执行栈中执行，异步任务会被挂起，直到有结果返回时，异步任务会进入任务队列中等待主线程读取执行。当执行栈为空时，主线程便会循环往复地读取任务队列中的事件，进入执行栈执行，这个过程叫 Event Loop。主线程对任务队列的读取也有先后之分，首先会读取宏任务，最开始是 script 整体代码，执行完一个宏任务后，会去查找微任务，将微任务队列的事件都执行完，这个过程也是循环往复的。所以本篇我主要讲了：  \n\nJavaScript 是单线程的本质；  \n执行栈和任务队列是什么；  \n什么是 Event Loop；  \n宏任务和微任务的区别。\n\n","slug":"js/一文带你搞懂浏览器的事件循环机制！","date":"2023-06-10T14:46:35.000Z","categories_index":"js","tags_index":"js 事件循环","author_index":"前端少年汪"},{"id":"5a931d7f77125b67fdf3d08adcd64c28","title":"不会使用springboot写CRUD的前端不是好前端！","content":"前言\n\n\n\n\n\n\n\n\n在开发Web应用程序时，CRUD（Create、Read、Update、Delete）是最基本的操作。为了简化开发过程并提高效率，我们可以使用一些成熟的框架和工具来实现CRUD操作。Spring Boot作为一个快速开发框架，而MyBatis-Plus则是一个高效的持久层框架，两者的结合可以帮助我们快速实现数据库操作。本文将详细介绍如何在Spring Boot项目中整合MyBatis-Plus，以便快速实现CRUD操作。\nSpring boot项目整合MyBatis-Plus快速CRUD\n\n概述\n环境准备\n创建Spring Boot项目\n引入MyBatis-Plus依赖\n配置数据库连接\n创建包目录和添加注解\n创建实体类和Mapper接口\n实现CRUD操作   \n最后再创建路由控制器controller\n总结\n\n1. 概述MyBatis-Plus是一个基于MyBatis的增强工具，提供了许多便捷的功能和方法，使得CRUD操作更加简单和高效。它能够自动生成基本的SQL语句，减少了手动编写SQL的工作量。结合Spring Boot，我们可以更方便地进行开发和管理。  \n2. 环境准备在开始之前，确保你已经安装了以下环境：\n\n  JDK 1.8或以上版本\n  Maven（用于构建项目）\n  MySQL数据库\n\n3. 创建Spring Boot项目 使用Spring Initializr创建一个新的Spring Boot项目。选择所需的项目元数据和依赖项，例如Web和MySQL驱动程序。点击生成项目，下载并导入到你的IDE中。\n记得修改成自己需要的包路径，点击下一步\n\n选择和自己jdk匹配的spring boot版本 不然项目会报错选择常用的一些插件，然后点击完成，等待maven下载依赖即可\n4.  引入MyBatis-Plus依赖在项目的pom.xml文件中添加MyBatis-Plus的依赖项：\nxmlCopy Code\n&lt;dependency&gt;\n    &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;最新版本&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n我用的mybatis plus版本是3.5.3.1。记住jdk的版本和mybatis plus的版本要匹配不然也会出现问题。本人就踩过坑 ，这个版本要求自己查看官网文档即可    \n这里给出我的pom.xml文件  \n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 https:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;3.0.12&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n    &lt;groupId&gt;com&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;backendVol&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;backend&lt;&#x2F;name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;&#x2F;java.version&gt;\n    &lt;&#x2F;properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.baomidou&#x2F;mybatis-plus-boot-starter --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.baomidou&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.5.3.1&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mysql&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;mysql-connector-j&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;optional&gt;true&lt;&#x2F;optional&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n\n\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;excludes&gt;\n                        &lt;exclude&gt;\n                            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n                            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n                        &lt;&#x2F;exclude&gt;\n                    &lt;&#x2F;excludes&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n\n&lt;&#x2F;project&gt;\n5. 配置数据库连接在application.properties或application.yml文件中配置数据库连接信息，包括数据库URL、用户名和密码等。\n#端口号9090\nserver:\n  port: 9999\n\n#数据库名：mysql，用户名root，密码123456\nspring:\n  datasource:\n    username: root\n    password: 1111111\n    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;数据库名称?useUnicode&#x3D;true&amp;amp\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n\n# mybatis-plus配置\nmybatis-plus:\n  # xml文件位置\n  mapper-locations: classpath:mybatis&#x2F;**&#x2F;*Mapper.xml\n  # 开启驼峰命名\n  configuration:\n    map-underscore-to-camel-case: true\n    # 开启sql显示\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n\n6. 创建包目录和添加注解我们在启动类里面添加@SpringBootApplication,@MapperScan(&quot;com.backendvol.mapper&quot;)这两个注解\n7.  创建实体类和Mapper接口创建一个Java类表示数据库表的实体，使用@Table注解指定表名和主键字段。然后创建一个继承自BaseMapper的Mapper接口，用于定义CRUD操作的方法。在entity包里面创建User实体类\npackage com.backendvol.entity;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableField;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport lombok.Data;\n\n@TableName(value &#x3D; &quot;user&quot;)\n@Data\npublic class UserEntity &#123;\n    @TableId(value &#x3D; &quot;userId&quot;,type &#x3D; IdType.AUTO)\n    private Integer userId;\n\n    @TableField(&quot;userName&quot;)\n    private String userName;\n\n    @TableField(&quot;userRole&quot;)\n    private Integer userRole;\n\n    @TableField(&quot;userPwd&quot;)\n    private String userPwd;\n\n    @TableField(&quot;userPic&quot;)\n    private String userPic;\n\n    @TableField(&quot;userTel&quot;)\n    private String userTel;\n\n    @TableField(&quot;userHobby&quot;)\n    private String userHobby;\n\n    @TableField(&quot;userVolDesc&quot;)\n    private String userVolDesc;\n\n    @TableField(&quot;userAge&quot;)\n    private int userAge;\n&#125;\n\n这里使用的是mybatis plus的注解@TableName(value = &quot;user&quot;) 和@TableField,以及插件lombok的@Data注解\n在mapper包创建Mapper接口\npackage com.backendvol.mapper;\n\nimport com.backendvol.entity.UserEntity;\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Param;\nimport org.apache.ibatis.annotations.Select;\n\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;UserEntity&gt; &#123;\n        &#x2F;&#x2F; 自定义查询方法，例如根据用户名和密码查询用户信息\n        @Select(&quot;select * from user where userName &#x3D; #&#123;username&#125; and userPwd &#x3D; #&#123;password&#125;&quot;)\n        UserEntity selectByUsernameAndPwd(@Param(&quot;username&quot;) String username ,@Param(&quot;password&quot;) String password);\n\n        &#x2F;&#x2F; 自定义查询方法，例如根据用户名用户信息\n        @Select(&quot;select * from user where userName &#x3D; #&#123;username&#125;  &quot;)\n        UserEntity selectByUsername (@Param(&quot;username&quot;) String username  );\n\n&#125;\n\n8.  实现CRUD操作在service里面创建impl包 在Service层中调用Mapper接口的方法，即可实现对数据库表的CRUD操作。创建service的的接口\npackage com.backendvol.service;\n\n\nimport com.backendvol.entity.UserEntity;\nimport com.backendvol.utils.Result;\nimport com.baomidou.mybatisplus.extension.service.IService;\n\npublic interface UserService extends IService&lt;UserEntity&gt; &#123;\n     \n&#125;\n创建service的的接口实现类例如，在UserService中编写如下代码：\n \npackage com.backendvol.service.impl;\n\nimport com.backendvol.entity.UserEntity;\nimport com.backendvol.mapper.UserMapper;\nimport com.backendvol.service.UserService;\nimport com.backendvol.utils.Result;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.core.toolkit.Constants;\nimport com.baomidou.mybatisplus.core.toolkit.Wrappers;\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport org.apache.ibatis.annotations.Param;\nimport org.springframework.stereotype.Service;\n\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, UserEntity&gt; implements UserService &#123;\n\n\n    private final UserMapper userMapper;\n\n    public UserServiceImpl(UserMapper userMapper) &#123;\n        this.userMapper &#x3D; userMapper;\n    &#125;\n\n    public Result login(String username, String password) &#123;\n        UserEntity user &#x3D; userMapper.selectByUsernameAndPwd(username, password);\n\n        System.out.println(user + &quot;登陆用户&quot;);\n\n        if (user !&#x3D; null &amp;&amp; user.getUserPwd().equals(password)) &#123;\n            return Result.success(&quot;登陆成功&quot;,user);\n        &#125;\n\n        return Result.fail(&quot;用户名或密码错误&quot;);\n    &#125;\n\n    @Override\n    public Result register(UserEntity UserEntity) &#123;\n        UserEntity user &#x3D; userMapper.selectByUsername(UserEntity.getUserName());\n\n        if (user !&#x3D; null) &#123;\n            return Result.fail(&quot;用户名已存在，请输入其他用户名&quot;);\n        &#125;\n        userMapper.insert(UserEntity);\n        UserEntity user2 &#x3D; userMapper.selectByUsername(UserEntity.getUserName());\n        return Result.success(&quot;注册成功&quot;,user2);\n\n    &#125;\n&#125;\n对返回值做统一的封装\npackage com.backendvol.utils;\n\nimport lombok.Data;\nimport org.springframework.data.relational.core.sql.In;\n\nimport java.io.Serializable;\n\n&#x2F;**\n * 封装统一的返回结果\n *&#x2F;\n@Data\npublic class Result implements Serializable &#123;\n    private Integer code;\n    private String msg;\n    private Object data;\n    public static Result success(Object data) &#123;\n        Result m &#x3D; new Result();\n        m.setCode(200);\n        m.setData(data);\n        m.setMsg(&quot;操作成功&quot;);\n        return m;\n    &#125;\n    public static Result success(String mess, Object data) &#123;\n        Result m &#x3D; new Result();\n        m.setCode(200);\n        m.setData(data);\n        m.setMsg(mess);\n        return m;\n    &#125;\n    public static Result fail(String mess) &#123;\n        Result m &#x3D; new Result();\n        m.setCode(500);\n        m.setData(null);\n        m.setMsg(mess);\n        return m;\n    &#125;\n    public static Result fail(String mess, Object data) &#123;\n        Result m &#x3D; new Result();\n        m.setCode(500);\n        m.setData(data);\n        m.setMsg(mess);\n        return m;\n    &#125;\n&#125;\n9.最后再创建路由控制器controllerpackage com.backendvol.controller;\n\nimport com.backendvol.entity.UserEntity;\nimport com.backendvol.service.UserService;\nimport com.backendvol.utils.Result;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.sql.Wrapper;\n\n\n@RestController\n@RequestMapping(&quot;&#x2F;user&quot;)\npublic class UserController &#123;\n\n    private final UserService UserService;\n\n    public UserController(UserService userService) &#123;\n        UserService &#x3D; userService;\n    &#125;\n\n    &#x2F;&#x2F;增加用户\n    @PostMapping(&quot;&#x2F;add&quot;)\n    public Boolean add(@RequestBody UserEntity UserEntity) &#123;\n        return UserService.save(UserEntity);\n    &#125;\n\n    &#x2F;&#x2F;删除\n    @GetMapping(&quot;delete&#x2F;&#123;id&#125;&quot;)\n    public Boolean delete(@PathVariable Integer id) &#123;\n        return UserService.removeById(id);\n    &#125;\n\n    &#x2F;&#x2F;修改\n    @PostMapping(&quot;&#x2F;update&quot;)\n    public Boolean update(@RequestBody UserEntity UserEntity) &#123;\n        return UserService.updateById(UserEntity);\n    &#125;\n\n    &#x2F;&#x2F;查询\n    @GetMapping(&quot;&#x2F;get&#x2F;&#123;id&#125;&quot;)\n    public UserEntity get(@PathVariable Integer id) &#123;\n        return UserService.getById(id);\n    &#125;\n\n    &#x2F;&#x2F;查询全部\n    @GetMapping(&quot;&#x2F;list&quot;)\n    public Result list() &#123;\n        return Result.success(&quot;测试&quot;, UserService.list());\n    &#125;\n\n    &#x2F;&#x2F;登陆接口\n    @PostMapping(&quot;&#x2F;login&quot;)\n    public Result login(@RequestBody UserEntity userEntity) &#123;\n        return UserService.login(userEntity.getUserName(), userEntity.getUserPwd());\n    &#125;\n\n    &#x2F;&#x2F;注册接口\n    @PostMapping(&quot;&#x2F;register&quot;)\n    public Result register(@RequestBody UserEntity userEntity) &#123;\n        return UserService.register(userEntity);\n    &#125;\n&#125;\n\n基本上都不用写sql语句了(复杂的除外)。\n运行测试一下接口。\n\n10.  总结通过整合Spring Boot和MyBatis-Plus，我们可以快速实现数据库的CRUD操作。MyBatis-Plus提供了许多便捷的功能和方法，使得开发更加高效。在本文中，我们介绍了整合的步骤，包括依赖的引入、数据库连接的配置、实体类和Mapper接口的创建以及Mapper XML文件的编写。希望本文对你在Spring Boot项目中整合MyBatis-Plus并快速实现CRUD操作有所帮助。\n","slug":"go/不会使用springboot写CRUD的前端不是好前端！","date":"2023-05-10T14:46:35.000Z","categories_index":"springBoot","tags_index":"java","author_index":"前端少年汪"},{"id":"e4991464a66a20205c1c693e50c451bc","title":"是时候该知道React中的Key属性的作用与最佳实践了","content":"\n前言在React中，我们常常会遇到需要渲染列表或循环生成组件的场景。为了提高性能和优化用户体验，React引入了一个特殊的属性——key。本文将详细介绍React中key属性的作用、原理，并提供一些最佳实践。\n一、Key属性的作用Key属性是React要求使用者在渲染多个组件时提供的一个特殊属性。它的作用主要有以下几个方面：\n\n元素的唯一标识：Key属性用于帮助React识别每个元素的唯一性。React通过key属性来判断当新旧元素对比时，哪些元素需要更新、哪些元素需要重新渲染，从而提高渲染性能。\n\n提高重排性能：在列表或循环生成组件的场景中，如果没有为每个元素指定key属性，React在进行diff算法比较时，会采用遍历比对的方式，导致性能下降。而指定了key属性后，React会通过key值快速定位到新旧元素之间的差异，从而减少不必要的重排操作。\n\n组件状态保持：当组件在重新渲染时，React会优先复用具有相同key值的组件实例，而不是销毁并重新创建一个新的组件实例。这使得在动态列表或条件渲染中保持组件状态成为可能。\n\n\n二、Key属性原理解析为了更好地理解key属性的工作原理，我们可以简单了解一下React的reconciliation（协调）过程。当React渲染组件时，会创建一个虚拟DOM树，并与之前的虚拟DOM树进行比较，找出差异，并将差异应用到真实的DOM上。\n在这个比较过程中，React需要对每个元素进行唯一性判断，以确定是否需要更新该元素。而这个唯一性判断就依赖于key属性。React使用key属性的值来判断元素是否相同。如果两个元素的key相同，React会认为它们是同一个元素，从而复用之前生成的组件实例，减少不必要的重绘操作。\n 以下是一个简单的示例代码，展示了在使用key属性的情况下，React如何对比新旧元素，从而实现部分更新：\nclass MyList extends React.Component &#123;\n  constructor(props) &#123;\n    super(props);\n    this.state &#x3D; &#123;\n      items: [\n        &#123; id: 1, text: &#39;Item 1&#39; &#125;,\n        &#123; id: 2, text: &#39;Item 2&#39; &#125;,\n        &#123; id: 3, text: &#39;Item 3&#39; &#125;,\n      ],\n    &#125;;\n  &#125;\n\n  handleClick &#x3D; () &#x3D;&gt; &#123;\n    const newItems &#x3D; [\n      &#123; id: 1, text: &#39;Item 1&#39; &#125;,\n      &#123; id: 2, text: &#39;Item 2 (updated)&#39; &#125;,\n      &#123; id: 3, text: &#39;Item 3&#39; &#125;,\n    ];\n    this.setState(&#123; items: newItems &#125;);\n  &#125;;\n\n  render() &#123;\n    return (\n      &lt;div&gt;\n        &lt;ul&gt;\n          &#123;this.state.items.map(item &#x3D;&gt; (\n            &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;&#x2F;li&gt;\n          ))&#125;\n        &lt;&#x2F;ul&gt;\n        &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;Update&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    );\n  &#125;\n&#125;\n\n在这个例子中，使用了一个简单的数组作为组件的state，每个数组元素包含一个id和text属性。在渲染列表项时，我们使用了每个元素的id作为key属性。\n当用户点击“Update”按钮时，我们改变了数组中第二个元素的文本内容，并重新设置state。由于该元素的id没有改变，React会认为它是同一个元素，并且只会更新它的文本内容，而不是重新渲染整个列表。这样就可以大大提高渲染性能，避免不必要的重绘操作。\n三、Key属性最佳实践根据对key属性的作用和原理的理解，以下是一些使用key属性的最佳实践建议：\n\n使用唯一且稳定的值：为了确保key属性的有效性，我们应该尽量使用唯一且稳定的值作为key。通常情况下，使用列表中的每个元素的唯一标识（如id）作为key是一个不错的选择。\n\n避免使用索引作为key：在列表或循环渲染场景中，有时会考虑使用索引作为key。然而，这种做法可能导致一些问题，在列表发生变化时，React可能会错误地复用组件实例，导致出现渲染错误或不必要的性能损失。\n\n不要频繁改变key的值：频繁地改变key的值可能会导致React无法正确地复用组件实例，从而降低性能。因此，我们应该尽量避免在组件的生命周期内频繁改变key值。\n\n\n示例代码：\n✅\nfunction MyComponent(&#123; items &#125;) &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map(item &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;\n\n❌\nfunction MyComponent(&#123; items &#125;) &#123;\n  return (\n    &lt;ul&gt;\n      &#123;items.map(（item，index） &#x3D;&gt; (\n        &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item.name&#125;&lt;&#x2F;li&gt;\n      ))&#125;\n    &lt;&#x2F;ul&gt;\n  );\n&#125;\n\n总结：在React中，key属性在列表或循环生成组件时起到了至关重要的作用。通过合理使用key属性，我们可以提高渲染性能、优化用户体验，并保持组件状态的一致性。同时，我们也需要遵循最佳实践，确保key属性的值唯一且稳定，避免索引作为key，并尽量避免频繁改变key的值。希望本文对你理解React中的key属性有所帮助！\n","slug":"react/是时候该知道React中的Key属性的作用与最佳实践了","date":"2023-05-04T14:46:35.000Z","categories_index":"react,前端,diff","tags_index":"前端 react diff 虚拟dom","author_index":"前端少年汪"},{"id":"3b6ae5332ee3a25497987c8c3919316f","title":"go-redis使用入门","content":"安装go-redis&#x2F;&#x2F;redis 6\ngo get github.com&#x2F;go-redis&#x2F;redis&#x2F;v8\n&#x2F;&#x2F;redis 7\ngo get github.com&#x2F;go-redis&#x2F;redis&#x2F;v9\n\n初始化连接redisfunc redisInit() &#123;\n\t&#x2F;&#x2F;初始化redis，连接地址和端口，密码，数据库名称\n\trdb &#x3D; redis.NewClient(&amp;redis.Options&#123;\n\t\tAddr:     &quot;localhost:6379&quot;,\n\t\tPassword: &quot;wmq12138&quot;,\n\t\tDB:       0,\n\t&#125;)\n&#125;\n\n入门案例package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n)\n\nvar rdb *redis.Client\n\nfunc main() &#123;\n\tredisInit()\n\t&#x2F;&#x2F;创建上下文\n\tctx :&#x3D; context.Background()\n\t&#x2F;&#x2F;set方法设置key和value，处理返回的错误，参数（上下文，key名，value值，过期时间）\n\terr :&#x3D; rdb.Set(ctx, &quot;goredistest&quot;, &quot;test&quot;, 0).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F;get方法获取value\n\tval, err :&#x3D; rdb.Get(ctx, &quot;goredistest&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\t&#x2F;&#x2F;do方法使用原生命令,返回值是一个interface类型\n\tresult, err :&#x3D; rdb.Do(ctx, &quot;get&quot;, &quot;goredistest&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n\tfmt.Println(&quot;get:&quot;, val)\n\tfmt.Print(&quot;原生命令：&quot;, result.(string))\n\n&#125;\n\n连接配置redis.NewClient(&amp;redis.Options{}),其中Options是连接的配置，是一个结构体类型，以下是配置选项和说明\ntype Options struct &#123;\n  &#x2F;&#x2F; 网络类型：[ tcp , unix ]\n  &#x2F;&#x2F; 默认是 tcp\n  Network string\n\n  &#x2F;&#x2F; host:port 地址\n  Addr string\n\n  &#x2F;&#x2F; 要使用的 TLS 配置。 当设置 TLS 时将协商。\n  TLSConfig *tls.Config\n  &#x2F;&#x2F;创建一个新的连接，优先于Newwork和Addr选项\n  Dialer func(ctx context.Context, network, addr string) (net.Conn, error)\n  &#x2F;&#x2F; 新建一个redis连接的时候，会回调这个函数\n  OnConnect func(ctx context.Context, cn *Conn) error\n  &#x2F;&#x2F; 当连接到使用 Redis ACL 系统的 Redis 6.0 或更高版本的实例时，\n  &#x2F;&#x2F; 使用指定的 用户名 对当前连接进行身份验证  (ACL 列表中定义的连接之一)。\n  Username string\n\n  &#x2F;&#x2F; 可选密码。 \n  &#x2F;&#x2F; 必须与 requirepass 服务器配置选项中指定的密码（如果连接到 Redis 5.0 或更低版本的实例）\n  &#x2F;&#x2F; 或 连接到使用 Redis ACL 系统的 Redis 6.0 或更高版本的实例时的用户密码 匹配。\n  Password string\n\n  &#x2F;&#x2F; 连接到服务器后要选择的数据库。\n  DB int\n\n  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 重试、退避时间&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  &#x2F;&#x2F; 放弃前的最大重试次数。\n  &#x2F;&#x2F; 默认是 3 次重试； -1（非 0）禁用重试。\n  MaxRetries int\n  &#x2F;&#x2F; 每次重试之间的最小退避。\n  &#x2F;&#x2F; 默认为 8 毫秒； -1 禁用退避。\n  MinRetryBackoff time.Duration\n   &#x2F;&#x2F; 每次重试之间的最大退避。\n  &#x2F;&#x2F; 默认为 512 毫秒； -1 禁用退避。\n  MaxRetryBackoff time.Duration\n\n  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;连接超时、读超时、写超时&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n  &#x2F;&#x2F; 建立新连接的拨号超时。\n  &#x2F;&#x2F; 默认为 5 秒。\n  DialTimeout time.Duration\n  &#x2F;&#x2F; 套接字读取超时。 \n  &#x2F;&#x2F; 如果达到，命令将失败并超时而不是阻塞。\n  &#x2F;&#x2F; 使用值 -1 表示无超时，使用 0 表示默认值。\n  &#x2F;&#x2F; 默认为 3 秒。\n  ReadTimeout time.Duration\n  &#x2F;&#x2F; 套接字写入超时。 \n  &#x2F;&#x2F; 如果达到，命令将失败并超时而不是阻塞。\n  &#x2F;&#x2F; 默认为 ReadTimeout。\n  WriteTimeout time.Duration\n\n  &#x2F;&#x2F; 连接池的类型。\n  &#x2F;&#x2F; FIFO 池为 true，LIFO 池为 false。\n  &#x2F;&#x2F; 请注意，与 lifo 相比，fifo 的开销更高。\n  PoolFIFO bool\n\n  &#x2F;&#x2F; 最大套接字连接数。\n  &#x2F;&#x2F; 默认为每个可用 CPU 10 个连接，由 runtime.GOMAXPROCS 报告。  \n  PoolSize int\n\n  &#x2F;&#x2F; 建立新连接缓慢时有用的最小空闲连接数。\n  MinIdleConns int\n\n  &#x2F;&#x2F; 客户端退出（关闭）连接的连接年龄。\n  &#x2F;&#x2F; 默认是不关闭老化的连接。\n  MaxConnAge time.Duration\n\n  &#x2F;&#x2F; 如果所有连接都忙，则客户端在返回错误之前等待连接的时间。\n  &#x2F;&#x2F; 默认为 ReadTimeout + 1 秒。\n  PoolTimeout time.Duration\n\n  &#x2F;&#x2F; 客户端关闭空闲连接的时间。\n  &#x2F;&#x2F; 应该小于服务器的超时时间。\n  &#x2F;&#x2F; 默认为 5 分钟。 -1 禁用空闲超时检查。\n  IdleTimeout time.Duration\n\n  &#x2F;&#x2F; 空闲连接 reaper 进行空闲检查的频率。\n  &#x2F;&#x2F; 默认为 1 分钟。 -1 禁用空闲连接reaper，\n  &#x2F;&#x2F; 但如果设置了 IdleTimeout，空闲连接仍会被客户端丢弃。\n  IdleCheckFrequency time.Duration\n  \n  &#x2F;&#x2F; 在从节点上启用只读查询。\n  readOnly bool\n\n  &#x2F;&#x2F; 用于实现断路器或速率限制器的限制器接口。\n  Limiter Limiter\n&#125;\n\n\n基本使用package main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n\t&quot;time&quot;\n)\n\nvar rdb *redis.Client          &#x2F;&#x2F;创建redis客户端实例\nvar ctx &#x3D; context.Background() &#x2F;&#x2F;创建上下文\n\nstring类型的操作方法\n  Get\n  Set\n  GetSet\n  SetNX\n  MGset\n  MSet\n  Incr,IncrBy\n  Decr,DecrBy\n  Del\n  Expire\n\nGet 获取key的值，返回值：错误信息error和value&#x2F;&#x2F;get 方法 返回值和错误信息\nfunc Get(k string) string &#123;\n\tstr, err :&#x3D; rdb.Get(ctx, k).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n\tfmt.Println(&quot;key&quot;, k, &quot;的值：&quot;, str)\n\treturn str\n&#125;\n\nSet 设置key和value，以及key的过期时间expiration 返回值：error&#x2F;&#x2F;set 方法\nfunc Set(key string, val interface&#123;&#125;, expiration time.Duration) &#123;\n\terr :&#x3D; rdb.Set(ctx, key, val, expiration).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t\treturn\n\t&#125;\n&#125;\n\nGetSet 设置一个key的值，并且返回这个key的旧值func GetSet(k string, v interface&#123;&#125;) interface&#123;&#125; &#123;\n\toldValue, err :&#x3D; rdb.GetSet(ctx, k, v).Result()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n\tfmt.Println(&quot;设置一个key的值，并返回这个key的旧值:&quot;, oldValue)\n\treturn oldValue\n&#125;\n\nSetNX 如果key不存在，则设置这个key的值func SetNx(k string, v interface&#123;&#125;, t time.Duration) &#123;\n\terr :&#x3D; rdb.SetNX(ctx, k, v, t)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n&#125;\n\nMGet 批量查询key的值func MGet(k ...string) &#123;\n\terr :&#x3D; rdb.MGet(ctx, k...)\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Print(err)\n\t&#125;\n&#125;\n\nMSet 批量设置key的值&#x2F;&#x2F;MSet 批量设置key的值\nfunc MSet(values ...interface&#123;&#125;) &#123;\n\trdb.MSet(ctx, values)\n&#125;\n\nDel 删除单个或者多个key&#x2F;&#x2F;delOneKeys 删除单个key\nfunc delOneKeys(k string) &#123;\n    rdb.Del(ctx, k)\n&#125;\n\n&#x2F;&#x2F;delKeys 删除多个key\nfunc delKeys(k ...string) &#123;\n\trdb.Del(ctx, k...)\n&#125;\n\nExpire 设置key的过期时间func expire(k string, t time.Duration) &#123;\n\trdb.Expire(ctx, k, t)\n&#125;\n\nIncr针对一个key的数值进行递增操作IncrBy指定每次递增多少 IncrByFloat 指定每次递增多少，跟IncrBy的区别是累加的是浮点数\n&#x2F;&#x2F;addVal 针对一个key的数值进行递增操作\nfunc addVal(k string) &#123;\n\t&#x2F;&#x2F; Incr函数每次加一\n\tval, err :&#x3D; rdb.Incr(ctx, &quot;key&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, val)\n\n\t&#x2F;&#x2F; IncrBy函数，可以指定每次递增多少\n\tvalBy, err :&#x3D; rdb.IncrBy(ctx, &quot;key&quot;, 2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valBy)\n\n\t&#x2F;&#x2F; IncrByFloat函数，可以指定每次递增多少，跟IncrBy的区别是累加的是浮点数\n\tvalFloat, err :&#x3D; rdb.IncrByFloat(ctx, &quot;key1&quot;, 2.2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valFloat)\n&#125;\n\nDecr 针对一个key的数值进行递减操作func Decr() &#123;\n\t&#x2F;&#x2F; Decr函数每次减一\n\tval, err :&#x3D; rdb.Decr(ctx, &quot;key&quot;).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, val)\n\n\t&#x2F;&#x2F; DecrBy函数，可以指定每次递减多少\n\tvalBy, err :&#x3D; rdb.DecrBy(ctx, &quot;key&quot;, 2).Result()\n\tif err !&#x3D; nil &#123;\n\t\tpanic(err)\n\t&#125;\n\tfmt.Println(&quot;最新值&quot;, valBy)\n&#125;\n\nHash类型的操作方法内部采用数组+链表结构，采用链地址法解决哈希冲突。\n\n  1. HSet\n  2. HGet\n  3. HGetAll\n  4. HIncrBy\n  5. HKeys\n  6. HLen\n  7. HMGet\n  8. HMSet\n  9. HSetNX\n  10. HDel\n  11. HExists\n\n&#x2F;&#x2F; HashMethods Hash 操作方法\nfunc HashMethods() &#123;\n\t&#x2F;&#x2F;●  HSet\n\t&#x2F;&#x2F; user_1 是hash key，username 是字段名, zhangsan是字段值\n\trdb.HSet(ctx, &quot;user_1&quot;, &quot;username&quot;, &quot;zhangsan&quot;, &quot;f1&quot;, &quot;f_v1&quot;)\n\t&#x2F;&#x2F;● 2. HGet \t根据key和field字段，查询field字段的值\n\tresult, _ :&#x3D; rdb.HGet(ctx, &quot;user_1&quot;, &quot;username&quot;).Result()\n\tfmt.Println(result)\n\n\t&#x2F;&#x2F;● 3. HGetAll\t获取所有的字段和值\n\tall, _ :&#x3D; rdb.HGetAll(ctx, &quot;user_1&quot;).Result()\n\tfmt.Println(all)\n\t&#x2F;&#x2F;● 4. HIncrBy 累加count字段的值，一次性累加2， user_1为hash key\n\tcount, err :&#x3D; rdb.HIncrBy(ctx, &quot;user_1&quot;, &quot;count&quot;, 2).Result()\n\tfmt.Println(count, err)\n\t&#x2F;&#x2F;● 5. HKeys根据key返回所有的字段名\n\tkeys :&#x3D; rdb.HKeys(ctx, &quot;user_1&quot;)\n\tfmt.Println(keys)\n\t&#x2F;&#x2F;● 6. HLen根据key，查询hash的字段数量\n\ti, err :&#x3D; rdb.HLen(ctx, &quot;user_1&quot;).Result()\n\tfmt.Println(i)\n\t&#x2F;&#x2F;● 7. HMGet根据key和多个字段名，批量查询多个hash字段值\n\tb, err :&#x3D; rdb.HMGet(ctx, &quot;user_1&quot;, &quot;f1&quot;, &quot;count&quot;).Result()\n\tfmt.Println(b)\n\t&#x2F;&#x2F;● 8. HMSet根据key和多个字段名和字段值，批量设置hash字段值\n\t&#x2F;&#x2F; 初始化hash数据的多个字段值\n\tdata :&#x3D; make(map[string]interface&#123;&#125;)\n\tdata[&quot;id&quot;] &#x3D; 1\n\tdata[&quot;username&quot;] &#x3D; &quot;lisi&quot;\n\t&#x2F;&#x2F; 一次性保存多个hash字段值\n\trdb.HMSet(ctx, &quot;key&quot;, data).Err()\n\n\t&#x2F;&#x2F;● 9. HSetNX如果field字段不存在，则设置hash字段值\n\trdb.HSetNX(ctx, &quot;user_1&quot;, &quot;f2&quot;, &quot;f2value&quot;)\n\t&#x2F;&#x2F;● 10. HDel根据key和字段名，删除hash字段，支持批量删除hash字段\n\t&#x2F;&#x2F; 删除一个字段id\n\trdb.HDel(ctx, &quot;key&quot;, &quot;id&quot;)\n\t&#x2F;&#x2F; 删除多个字段\n\trdb.HDel(ctx, &quot;key&quot;, &quot;id&quot;, &quot;username&quot;)\n\t&#x2F;&#x2F;● 11. HExists检测hash字段名是否存在\n\terr &#x3D; rdb.HExists(ctx,&quot;key&quot;, &quot;id&quot;).Err()\n\tif err !&#x3D; nil &#123;\n\t\tfmt.Println(err)\n\t&#125;\n\n&#125;\n\nList的操作方法\n  1. LPush\n  2. LPushX\n  3. RPop\n  4. RPush\n  5. RPushX\n  6. LPop\n  7. LLen\n  8. LRange\n  9. LRem\n  10. LIndex\n  11. LInsert\n\n&#x2F;&#x2F;ListOperateMethods List操作方法\nfunc ListOperateMethods() &#123;\n\t&#x2F;&#x2F;● 1. LPush 添加到list的左侧,LPush支持一次插入一个或者任意个数据\n\trdb.LPush(ctx, &quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w&quot;)\n\t&#x2F;&#x2F;● 2. LPushX 跟LPush的区别是，仅当列表存在的时候才插入数据,用法完全一样。\n\trdb.LPushX(ctx, &quot;w1&quot;, &quot;w2&quot;, &quot;w3&quot;, &quot;w4&quot;, &quot;w&quot;)\n\t&#x2F;&#x2F;● 3. RPop从列表的右边删除第一个数据，并返回删除的数据\n\trdb.RPop(ctx, &quot;w1&quot;)\n\t&#x2F;&#x2F;● 4. RPush\n\trdb.RPush(ctx, &quot;w1&quot;, &quot;wmq&quot;, &quot;wmq2&quot;)\n\t&#x2F;&#x2F;● 5. RPushX 跟RPush的区别是，仅当列表存在的时候才插入数据, 他们用法一样\n\trdb.RPushX(ctx, &quot;w1&quot;, &quot;wm3&quot;, &quot;w3&quot;)\n\t&#x2F;&#x2F;● 6. LPop从列表左边删除第一个数据，并返回删除的数据\n\tval, _ :&#x3D; rdb.LPop(ctx, &quot;w1&quot;).Result()\n\tfmt.Println(val)\n\t&#x2F;&#x2F;● 7. LLen返回列表的大小\n\tlLen, _ :&#x3D; rdb.LLen(ctx, &quot;w1&quot;).Result()\n\tfmt.Println(lLen)\n\t&#x2F;&#x2F;● 8. LRange返回列表的一个范围内的数据，也可以返回全部数据\n\tresult, _ :&#x3D; rdb.LRange(ctx, &quot;w1&quot;, 0, lLen).Result()\n\tfmt.Println(result)\n\t&#x2F;&#x2F;● 9. LRem删除列表中的数据 从列表左边开始，删除100， 如果出现重复元素，仅删除1次，也就是删除第一个\n\tdels, _ :&#x3D; rdb.LRem(ctx, &quot;key&quot;, 1, &quot;w1&quot;).Result()\n\tfmt.Println(dels)\n\t&#x2F;&#x2F;● 10. LIndex\n\t&#x2F;&#x2F; 列表索引从0开始计算，这里返回第6个元素\n\tval, _ &#x3D; rdb.LIndex(ctx, &quot;w1&quot;, 5).Result()\n\n\tfmt.Println(val)\n\t&#x2F;&#x2F;● 11. LInsert&#x2F;&#x2F; 在列表中5的前面插入4\n\t&#x2F;&#x2F;&#x2F;&#x2F; before是之前的意思\n\tinsert :&#x3D; rdb.LInsert(ctx, &quot;w1&quot;, &quot;after&quot;, 1, 2)\n\tfmt.Println(insert)\n&#125;\n\nSet的操作方法Set是无序且不会重复的字符串集合 set和list的区别是set不包含重复的元素\n\n  1. SAdd\n  2. SCard\n  3. SIsMember\n  4. SMembers\n  5. SRem\n  6. SPop,SPopN\n\n&#x2F;&#x2F;\tSet操作方法\nfunc setOperateMethods() &#123;\n\t&#x2F;&#x2F;● 1. SAdd\n\trdb.SAdd(ctx, &quot;set_key&quot;, 100, 10, 32, 4, 100, 5)\n\t&#x2F;&#x2F;● 2. SCard\n\tres, _ :&#x3D; rdb.SCard(ctx, &quot;set_key&quot;).Result()\n\tfmt.Println(res)\n\n\t&#x2F;&#x2F;● 3. SIsMember判断元素是否在集合中\n\tresult, _ :&#x3D; rdb.SIsMember(ctx, &quot;set_key&quot;, 900).Result()\n\tfmt.Println(result)\n\t&#x2F;&#x2F;● 4. SMembers 获取集合中所有的元素\n\tstrings, _ :&#x3D; rdb.SMembers(ctx, &quot;set_key&quot;).Result()\n\tfmt.Println(strings)\n\n\t&#x2F;&#x2F;● 5. SRem删除集合元素\n\ti, _ :&#x3D; rdb.SRem(ctx, &quot;set_key&quot;, 100, 4).Result()\n\tfmt.Println(&quot;返回删除的个数&quot;, i)\n\t&#x2F;&#x2F;● 6. SPop,SPopN 随机返回集合中的元素，并且删除返回的元素\n\trdb.SPop(ctx, &quot;set_key&quot;)\n\tfmt.Println(rdb.SMembers(ctx, &quot;set_key&quot;).Result())\n\n\t&#x2F;&#x2F; 随机返回集合中的一个元素，并且删除这个元素\n\tval, _ :&#x3D; rdb.SPop(ctx,&quot;key&quot;).Result()\n\tfmt.Println(val)\n\n\t&#x2F;&#x2F; 随机返回集合中的5个元素，并且删除这些元素\n\tvals, _ :&#x3D; rdb.SPopN(ctx,&quot;key&quot;, 5).Result()\n\tfmt.Println(vals)\n\n&#125;\n\nsorted set操作方法有序的，非重复的的字符串集合\n\n  1. ZAdd\n  2. ZCard\n  3. ZCount\n  4. ZIncrBy\n  5. ZRange,ZRevRange\n  6. ZRangeByScore\n  7. ZRevRangeByScore\n  8. ZRangeByScoreWithScores\n  9. ZRem\n  10. ZRemRangeByRank\n  11.ZRemRangeByScore\n  12. ZScore\n  13. ZRank\n\n\n发布订阅Redis提供了发布订阅功能，可以用于消息的传输，Redis的发布订阅机制包括三个部分，发布者，订阅者和Channel。\n\n发布者和订阅者都是Redis客户端，Channel则为Redis服务器端，发布者将消息发送到某个的频道，订阅了这个频道的订阅者就能接收到这条消息。\n订阅者 subscriber&#x2F;&#x2F;subscriber 订阅者订阅channel1的消息\nfunc subscriber() &#123;\n\t&#x2F;&#x2F; 订阅channel1这个channel\n\tsub :&#x3D; rdb.Subscribe(ctx, &quot;channel1&quot;)\n\t&#x2F;&#x2F; sub.Channel() 返回go channel，可以循环读取redis服务器发过来的消息\n\tfor msg :&#x3D; range sub.Channel() &#123;\n\t\t&#x2F;&#x2F; 打印收到的消息\n\t\tfmt.Println( msg.Channel, msg.Payload)\n\t\tfmt.Println()\n\t&#125;\n\t&#x2F;&#x2F;或者\n\tfor &#123;\n\t\tmsg, err :&#x3D; sub.ReceiveMessage(ctx)\n\t\tif err !&#x3D; nil &#123;\n\t\t\tfmt.Println(err)\n\t\t&#125;\n\t\tfmt.Println(msg.Channel, msg.Payload)\n\t&#125;\n&#125;\n\n发布者 publisherpackage main\n\nimport (\n\t&quot;context&quot;\n\t&quot;fmt&quot;\n\t&quot;github.com&#x2F;go-redis&#x2F;redis&#x2F;v8&quot;\n\t&quot;strconv&quot;\n)\n\nvar rdb *redis.Client          &#x2F;&#x2F;创建redis客户端实例\nvar ctx &#x3D; context.Background() &#x2F;&#x2F;创建上下文\nfunc main() &#123;\n\t&#x2F;&#x2F;初始化redis，连接地址和端口，密码，数据库名称\n\trdb &#x3D; redis.NewClient(&amp;redis.Options&#123;\n\t\tAddr:     &quot;localhost:6379&quot;,\n\t\tPassword: &quot;&quot;,\n\t\tDB:       0,\n\t&#125;)\n\t&#x2F;&#x2F; 将&quot;message&quot;消息发送到channel1这个通道上\n\n\tfor i :&#x3D; 1; i &lt;&#x3D; 100; i++ &#123;\n\t\tfmt.Println(i)\n\t\tstr :&#x3D; strconv.Itoa(i) + &quot;.message收到前端回答&quot;\n\t\trdb.Publish(ctx, &quot;channel1&quot;, str)\n\t&#125;\n&#125;\n\n\n其他的一些方法\nfunc cancelSub() &#123;\n\t&#x2F;&#x2F; 订阅channel1这个channel\n\tsub :&#x3D; rdb.Subscribe(ctx, &quot;channel1&quot;)\n\t&#x2F;&#x2F; 取消订阅\n\tsub.Unsubscribe(ctx, &quot;channel1&quot;)\n&#125;\n\nfunc querySubCount() &#123;\n\t&#x2F;&#x2F; 查询channel_1通道的订阅者数量\n\tchs, _ :&#x3D; rdb.PubSubNumSub(ctx, &quot;channel_1&quot;).Result()\n\tfor ch, count :&#x3D; range chs &#123;\n\t\tfmt.Println(ch)    &#x2F;&#x2F; channel名字\n\t\tfmt.Println(count) &#x2F;&#x2F; channel的订阅者数量\n\t&#125;\n&#125;\n\n事务操作redis事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n  事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n\nTxPinline&#x2F;&#x2F;事务操作\n&#x2F;&#x2F;TxPinline\nfunc Txline() &#123;\n\t&#x2F;&#x2F; 开启一个TxPipeline事务\npipe :&#x3D; rdb.TxPipeline()\n\n&#x2F;&#x2F; 执行事务操作，可以通过pipe读写redis\nincr :&#x3D; pipe.Incr(ctx,&quot;tx_pipeline_counter&quot;)\npipe.Expire(ctx,&quot;tx_pipeline_counter&quot;, time.Hour)\n\n&#x2F;&#x2F; 上面代码等同于执行下面redis命令\n&#x2F;&#x2F;\n&#x2F;&#x2F;     MULTI\n&#x2F;&#x2F;     INCR pipeline_counter\n&#x2F;&#x2F;     EXPIRE pipeline_counts 3600\n&#x2F;&#x2F;     EXEC\n\n&#x2F;&#x2F; 通过Exec函数提交redis事务\n_, err :&#x3D; pipe.Exec(ctx)\n\n&#x2F;&#x2F; 提交事务后，我们可以查询事务操作的结果\n&#x2F;&#x2F; 前面执行Incr函数，在没有执行exec函数之前，实际上还没开始运行。\nfmt.Println(incr.Val(), err)\n&#125;\n\nwatchredis乐观锁支持，可以通过watch监听一些Key, 如果这些key的值没有被其他人改变的话，才可以提交事务\nfunc watch() &#123;\n\n\t&#x2F;&#x2F; 定义一个回调函数，用于处理事务逻辑\n\tfn :&#x3D; func(tx *redis.Tx) error &#123;\n\t\t&#x2F;&#x2F; 先查询下当前watch监听的key的值\n\t\tv, err :&#x3D; tx.Get(ctx, &quot;key&quot;).Int()\n\t\tif err !&#x3D; nil &amp;&amp; err !&#x3D; redis.Nil &#123;\n\t\t\treturn err\n\t\t&#125;\n\t\t&#x2F;&#x2F; 这里可以处理业务\n\t\tv++\n\n\t\t&#x2F;&#x2F; 如果key的值没有改变的话，Pipelined函数才会调用成功\n\t\t_, err &#x3D; tx.Pipelined(ctx, func(pipe redis.Pipeliner) error &#123;\n\t\t\t&#x2F;&#x2F; 在这里给key设置最新值\n\t\t\tpipe.Set(ctx, &quot;key&quot;, v, 0)\n\t\t\treturn nil\n\t\t&#125;)\n\t\treturn err\n\t&#125;\n\n\t&#x2F;&#x2F; 使用Watch监听一些Key, 同时绑定一个回调函数fn, 监听Key后的逻辑写在fn这个回调函数里面\n\t&#x2F;&#x2F; 如果想监听多个key，可以这么写：client.Watch(ctx,fn, &quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;)\n\trdb.Watch(ctx, fn, &quot;key&quot;)\n&#125;","slug":"go/go-redis使用入门","date":"2023-04-18T02:46:35.000Z","categories_index":"go","tags_index":"go","author_index":"前端少年汪"},{"id":"aede38527e7a3b6a941a59510b6feb5f","title":"前端项目(Vue,React)性能优化","content":"前言前端随着node等JavaScript运行时平台的出现，逐渐向工程化方向发展。项目开发也越来越规范化，但是随着项目的体积越来越大，依赖库越来越多，项目的运行，热更新和打包发布也是越来越慢，甚至卡顿。这个时候就需要对项目进行“瘦身”（性能优化）了。本文就围绕着如何给前端项目进行性能优化等技术点一一展开讨论\n为什么为什么要进行项目性能优化，其实这个问题我在前言中已经简单阐述过了。优化的目的是为了改善用户的使用体验，提高用户的留存率，你的产品页面和功能的响应的速度越快，交互更加的人性化，对用户更加的友好，那自然而然的就会收到用户的青睐啦。所以对项目的优化不仅仅是要从技术思维去作为出发点，同时也要从产品思维出发站在用户的角度(也就是一个使用者的角度)作为出发点。这样的优化才是有效优化，否则就是东施效颦了，乱搞一通，随大流。。。\nWeb 性能这里声明一下，本文只阐述web项目的性能优化。其他平台的项目是否适用，自行斟酌！\n在对web项目优化之前先了解一下web的性能指标，这里引用MDN中的一段描述。\nWeb 性能是客观的衡量标准，是用户对加载时间和运行时的直观体验。Web 性能指页面加载到可交互和可响应所消耗的时间，以及页面在交互时的流畅度——滚动是否顺滑？按钮能否点击？弹窗能否快速打开，动画是否平滑？Web 性能既包括客观的度量如加载时间，每秒帧数和到页面可交互的时间；也包括用户的对页面内容加载时间的主观感觉。\n页面响应时间越长，越多的用户就会放弃该网站。重要的是，通过使体验尽可能早地变得可用和交互，同时异步地加载长尾体验部分，来最大程度地减少加载和响应时间，并添加其他功能以降低延迟。\nWeb性能指标模型RAIL 是 Response、Animation、Idle 和 Load 的首字母缩写，是一种由 Google Chrome 团队于 2015 年提出的性能模型，用于提升浏览器内的用户体验和性能。\n\n\nResponse(响应) ：在50ms内处理事件  目标：在 100 ms内完成由用户输入发起的转换，让用户感觉交互是即时的。  \n\n\nAnimatio(动画) : 在10ms内生成一帧，目的为流畅的视觉效果  在 10 毫秒或更短的时间内生成动画的每一帧。从技术上来讲，每帧的最大预算为 16 ms（1000 ms/每秒 60 帧≈16 ms） ，但是，浏览器需要大约 6 ms速来渲染一帧，因此，准则为每帧 10ms。\nIdle(空闲) ：最大限度增加空闲时间  最大限度增加空闲时间以提高页面在 50 ms内响应用户输入的几率\nLoad(加载) ：在5s内交付并实现可交互  目前对于首次加载，在使用速度较慢 3G 连接的中端移动设备上，理想的目标是在5s或更短的事件内实现交互对于后续加载，理想的目标是在2s内加载页面。\n\n优化方向所以综上所述，所以我们优化的项主要是集中在：\n\n  http的请求的响应\n  动画的视觉和流畅效果\n  交互的响应速度\n  页面加载的时间\n\n这四个大的方向\n当然除了这四个方向以为我觉得还可以有其他的途径去进一步的优化，当然了，这肯定也是要看应用场景的，根据业务的需要去具体问题具体分析的，不能够为了优化而去优化。\n也可以换个说法：\n\n  传输资源的优化：比如图像资源，不同的格式类型会有不同的使用场景，在使用过程中判断是否恰当；\n  加载过程的优化：比如加载延迟，是否有不需要在首屏展示的非关键信息，占用了页面的加载时间；\n  JavaScript的优化：JavaScript代码是否进行了压缩，书写是否规范，有无考虑内存泄漏等；\n  关键渲染路径优化：比如是否存在不必要的回流与重绘等；\n  本地存储和浏览器缓存。\n\n举个栗子🌰，从资源请求数量+代码执行效率两个角度来考虑，可以从DMO结构，JS脚本，webpack打包，服务端优化，ssr，框架(Vue,React)的优化等等\n怎么做？怎么做？当然是从四个大的方向先入手啦，然后在根据你的业务和场景，再细分。\nhttp的请求的响应优化方案：\n\n  并行处理请求和响应\n  减少服务器响应时间\n  部分资源可以使用懒加载或者预加载\n  消除阻塞渲染的资源\n  避免过大的网络负载，压缩传输的资源\n  最小化关键请求的深度\n  使用缓存策略\n  减少重定向\n  使用CDN内容分发网络\n  根据需要使用SSR(服务端渲染)\n\nChrome限制每个域名最多执行6个TCP连接。如果您一次请求十二个资源，前6个将开始，后6个将排队。一旦其中一个请求完成，队列中的第一个请求项目将开始其请求过程。\n浏览器发起一个http请求的过程\n\n  Queuing (排队)排队时间\n  Stalled (停滞)发送请求之前等待的时间\n  DNS lookup (DNS查找)，\n  initial connection (初始连接)\n  SSL handshake (SSL握手)\n  Request sent (请求发送)发出网络请求所花费的时间\n  Waiting (等待)（到开始下载第一个字节的时间（TTFB））等待初始响应所花费的时间\n  Content Download (内容下载)接收响应数据所花费的时间\n\n动画的视觉和流畅效果前端前端实现动画有三种主流的方式:csss,canvas,dom，他们在浏览器中的渲染方式有所不同，所以优化的时候也要注意区分\n进行CSS的动画优化必须了解一定的浏览器的几个概念,图层、重绘、回流。\ncss3动画的优化方案：\n  缩小CSS，移除未使用的CSS\n  避免DOM过大\n  减少重绘和回流\n  尽量将动画放在一个图层，避免多层污染\n  尽量使用GPU加速\n\nCanvas动画优化方案CSS虽然更加简单也更加保证性能的下限,但是要想实现更加复杂可控的动画,那就必须用到Canvas+JavaScript这个组合了.\nCanvas作为浏览器提供的2D图形绘制API本身有一定的复杂度,优化的方法非常多,我们仅仅介绍几种比较主流的优化方式.\n\n  运用requestAnimationFrame\n  离屏canvas\n  避免浮点运算\n  减少调用Canvas API\n  使用web worker\n\n交互的响应速度优化方案：\n\n  减少第三方代码的影响\n  减少Java Script执行时间\n  最小化线程工作\n  保持较低的请求数和传输大小\n  使用节流和防抖减少事件的触发频率\n\n页面加载的时间优化方案：\n\n  缩小javascript\n  预连接到所需的来源\n  预先价值关键请求\n  减少对DOM的操作\n  减少http请求\n  图片懒加载\n  优化TCP协议\n  优化css\n  异步加载脚本，防止主线程阻塞\n  使用cdn\n  代理缓存\n\n下面是一些关于前端框架项目的一些优化方法\nVue项目优化代码层面的优化\n  路由懒加载\n\n&#123;\npath: &#39;&#x2F;&#39;,\n  name: &#39;home&#39;,\n    component: () &#x3D;&gt; import(&#x2F;* webpackChunkName: &quot;home&quot; *&#x2F; &#39;.&#x2F;views&#x2F;home&#x2F;index.vue&#39;),\n    meta: &#123; isShowHead: true &#125;\n  &#125;\n\n\n  computed 和 watch 区分使用场景\n\n\n\n\n\n  computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；\n  watch：类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。\n\n\n\n\n\n\n  v-if 和 v-show 区分使用场景\n\n\n\n\n\n  v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show则适用于需要非常频繁切换条件的场景。这里要说的优化点在于减少页面中 dom 总数，我比较倾向于使用 v-if，因为减少了 dom 数量。\n\n\n\n\n\n\n  v-for 遍历必须为 item 添加 key，且避免同时使用 v-if\n\n\n\n\n\n  v-for 遍历必须为 item 添加 key，循环调用子组件时添加 key，key 可以唯一标识一个循环个体，可以使用例如 item.id 作为 key\n  避免同时使用 v-if，v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度。\n\n\n\n\n\n\n  vue-lazyload可参考下官方介绍，不再赘述。\n  style方面\n\n\n\n\n\n  style文件按照模块划分，无论放在内外都 锁住样式，目的就是避免多人开发样式混乱，锁住之后内部的命名也可以很简短。\n  全局样式抽象化，将公共组件以及elementUI修改的样式建议都放到公共样式，抽象做的越好说明你的样式文件体积越小，复用率越高。\n\n\n\n\n\n\n  合理组件化\n\n\n\n\n\n使用重复率高的模块尽量封装成组件，包括布局的封装，按钮，表单，提示框，弹出框等，封装的组件只处理  类似业务，复用率越高越好\n\n\n  封装组件配置的 props 细化到一个字段，不要一个对象传进去，这样只传需要修改的参数，在子组件 props 里加数据类型，是否必传，以及默认值，便于排查错误，让传值更严谨\n  Vue组件动态加载\n\n\n\n\n\n\n  Vue库dist里面的Runtime-only比Runtime+Compiler小30%\n  Vue的计算属性会根据依赖的data进行缓存\n  keep-alive可以缓存常用组件\n  Vuex中的getter也会根据依赖的state进行缓存\n  Vue全局错误处理errorHandle\n\n长列表性能优化Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。\nTips：这里只是冻结了 users的值，引用不会被冻结，当我们需要 reactive 数据的时候，我们可以重新给 users 赋值。\nexport default &#123;\n  data: () &#x3D;&gt; (&#123;\n    users: &#123;&#125;\n  &#125;),\n  async created() &#123;\n      const users &#x3D; await axios.get(&quot;&#x2F;api&#x2F;users&quot;);\n      this.users &#x3D; Object.freeze(users);\n  &#125;,\n  methods:&#123;\n    &#x2F;&#x2F; 改变值不会触发视图响应  \n    this.data.users[0] &#x3D; newValue\n\n    &#x2F;&#x2F; 改变引用依然会触发视图响应\n    this.data.users &#x3D; newArray\n  &#125;\n&#125;;\n\n事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内\ncreated() &#123;\n  addEventListener(&#39;click&#39;, this.click, false)\n&#125;,\nbeforeDestroy() &#123;\n  removeEventListener(&#39;click&#39;, this.click, false)\n&#125;\n\n\n  第三方插件按需引入\n\n\n\n\n\n  我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。\n\n\n\nReact项目优化代码层面的优化\n  在constructor改变this指向代替箭头函数和render内绑定this，避免函数作为props带来不必要的rerender\n  shouldComponentUpdate，减少不不必要的rerender\n  PureComponent高性能组件只响应引用数据的深拷贝\n  合并setState操作，减少虚拟dom对比频率\n\n\n\n\n  React路由动态加载react-loadable\n  避免使用Context\n\n\n\n\n\n  Context是react中跨组件树传递数据的一种方法，但是会让组件复用性变差，不推荐使用，有相应场景的话就使用redux。\n\n\n\n\n\n\n  虚拟化长列表\n\n\n\n\n\n  当页面有非常多的元素时，会出现卡顿，这时可以使用虚拟滚动替代，仅渲染有限的内容，降低重新渲染的时间，以及创建DOM节点的数量，推荐库：react-window\n\n\n\n\n\n\n  key不要使用index\n\n\n\n\n\n  循环渲染时，数据变化频繁的话，建议使用唯一的key，例如id。\n\n\n\n\n\n\n  多使用Memo、useMemo缓存\n\n\n\n\n\n  当传递的数据发生变化时才会重新渲染。\n\n\n\n\n\n\n  组件卸载时清空还在执行的方法\n\n\n\n\n\n  例如定时器、轮询方法在卸载后还是会继续执行，卸载时要清空。\n\n\n\n\n\n\n  使用fragement或者空标签&lt;&gt;&lt;/&gt;避免额外标签\n  使用 或者React.lazy懒加载，只支持default exports\n  尽量使用纯组件，避免重复渲染\n  在构造函数中进行函数 this 绑定\n  避免使用内联样式属性\n  不要在render中改变应用的状态\n  为组件创造错误边界\n\n其他优化方法除了以上的一些优化方法，还有从其他维度的优化方向也可以对项目进行性能上的一些优化\n\n  服务端渲染 SSR or 预渲染\n\n服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。\n\n  webpack层面的优化\n\n\n\n\n\n  压缩图片媒体等静态资源\n  减少 ES6 转为 ES5 的冗余代码\n  提取公共代码\n  模版预编译\n  提取组件的css\n  优化SourceMap\n  构建结果输出分析\n\n\n\n\n\n\n  开启gzip压缩\n\ngzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右。\n\n  浏览器缓存\n\n为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》。\n\n  cdn\n\n浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。\n总结以上总结了那么多的方法 当然肯定还有许多其他方向的优化啦，本人技术有限，肯定不能够阐述完全，性能优化是个大话题，有不同意见的小伙伴可以评论区讨论一下\n","slug":"js/前端项目(Vue,React)性能优化","date":"2023-04-18T02:46:35.000Z","categories_index":"性能优化","tags_index":"性能优化","author_index":"前端少年汪"},{"id":"85ace94f5f65156ab225562196d7492a","title":"前端10大排序算法详解","content":"\n\n冒泡🫧排序\n\n\n\n\n\n\n\n\n通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。内循环： 使用相邻双指针 j , j + 1 从左至右遍历，依次比较相邻元素大小，若左元素大于右元素则将它们交换；遍历完成时，最大元素会被交换至数组最右边 。外循环： 不断重复「内循环」，每轮将当前最大元素交换至 剩余未排序数组最右边 ，直至所有元素都被交换至正确位置时结束。\n\n\n&#x2F;**\n * 冒泡🫧\n * 每一趟找出最大的,总共比较次数为arr.length-1次,每次的比较次数为arr.length-1-i次，依次递减\n * @param &#123;*&#125; arr \n * @returns array\n *&#x2F;\nfunction bubbleSort(arr) &#123;\n    &#x2F;**\n        比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n        对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。\n        针对所有的元素重复以上的步骤，除了最后一个。\n        持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n        相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。\n        \n        原始数组： [ 99, 88, 66, 101, 90, 45 ]\n\n        第1次循环 [ 88, 66, 99, 90, 45, 101 ]\n        第2次循环 [ 66, 88, 90, 45, 99, 101 ]\n        第3次循环 [ 66, 88, 45, 90, 99, 101 ]\n        第4次循环 [ 66, 45, 88, 90, 99, 101 ]\n        第5次循环 [ 45, 66, 88, 90, 99, 101 ]\n     *&#x2F;\n    let len &#x3D; arr.length;\n    if (!len) &#123;\n        return [];\n    &#125;\n    console.log(&#39;原始数组：&#39;, arr);\n    &#x2F;&#x2F;外循环，对被排序的数组进行遍历，轮数为数组的长度\n    for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        &#x2F;&#x2F; 内循环，循环比较相邻元素\n        for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n            &#x2F;&#x2F;如果前一个元素大于后一个元素的话，就交换两个元素的位置，最后是以从大到小的顺序输出\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]; &#x2F;&#x2F;元素交换\n            &#125;\n        &#125;\n        console.log(&#96;第$&#123;i+1&#125;次循环&#96;, arr);\n    &#125;\n    return arr;\n&#125;\n\n \n优化\n\n\n\n\n\n\n\n\n普通冒泡排序的时间复杂度恒为 O(N2)，与输入数组的元素分布无关。通过增加一个标志位 flag ，若在某轮「内循环」中未执行任何交换操作，则说明数组已经完成排序，直接返回结果即可。优化后的冒泡排序的最差和平均时间复杂度仍为 O(N2) ;在输入数组 已排序 时，达到 最佳时间复杂度 𝜴(N)\nfunction bubbleSort(arr) &#123;\n  let len &#x3D; arr.length;\n  if (!len) &#123;\n    return [];\n  &#125;\n  console.log(&#39;原始数组：&#39;, arr);\n  &#x2F;&#x2F;外循环，对被排序的数组进行遍历，轮数为数组的长度\n  for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n    let flag &#x3D; false; &#x2F;&#x2F; 初始化标志位\n    &#x2F;&#x2F; 内循环，循环比较相邻元素\n    for (let j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n      &#x2F;&#x2F;如果前一个元素大于后一个元素的话，就交换两个元素的位置，最后是以从大到小的顺序输出\n      if (arr[j] &gt; arr[j + 1]) &#123;\n        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]; &#x2F;&#x2F;元素交换\n         flag &#x3D; true;  &#x2F;&#x2F; 记录交换元素\n      &#125;\n    &#125;\n    if (!flag) break;     &#x2F;&#x2F; 内循环未交换任何元素，则跳出\n    console.log(&#96;第$&#123;i+1&#125;次循环&#96;, arr);\n  &#125;\n  return arr;\n&#125;\n\n选择排序\n\n\n\n\n\n\n\n\n思路：依次找到剩余元素的最小值或者最大值，放置在末尾或者开头。\n\n\n&#x2F;**\n * 选择排序\n * 依次找到剩余元素的最小值或者最大值，放置在末尾或者开头。\n * @param &#123;Array&#125; arr\n * @returns\n *&#x2F;\nfunction selectionSort(arr) &#123;\n    let len &#x3D; arr.length;\n    let minIndex;\n    for (let i &#x3D; 0; i &lt; len - 1; i++) &#123;\n        minIndex &#x3D; i;&#x2F;&#x2F;先假设第一个数字最小\n        for (let j &#x3D; i + 1; j &lt; len; j++) &#123;\n            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数\n                minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存\n            &#125;\n        &#125;\n        [arr[minIndex], arr[i]] &#x3D; [arr[i], arr[minIndex]]&#x2F;&#x2F;交换两个元素\n    &#125;\n    return arr;\n&#125;\n\n\n\n插入排序\n\n\n\n\n\n\n\n\n思路：以第一个元素为有序数组，其后的元素通过再这个已有序的数组中找到合适的元素并插入。\nfunction insertSort(arr) &#123;\n  let length &#x3D; arr.length,\n    preIndex, current;\n  for (let i &#x3D; 1; i &lt; length; i++) &#123;\n    preIndex &#x3D; i - 1;\n    current &#x3D; arr[i];\n    &#x2F;&#x2F; 和已经排序好的序列进行比较，插入到合适的位置\n    while (preIndex &gt;&#x3D; 0 &amp;&amp; arr[preIndex] &gt; current) &#123;\n      arr[preIndex + 1] &#x3D; arr[preIndex];\n      preIndex--;\n    &#125;\n    arr[preIndex + 1] &#x3D; current;\n    console.log(&#96;第$&#123;i&#125;次循环&#96;, arr);\n  &#125;\n  return arr;\n&#125;\n\n希尔排序\n\n\n\n\n\n\n\n\n通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap\nfunction shellSort(arr) &#123;\n  let len &#x3D; arr.length;\n  &#x2F;&#x2F; 初始步数\n  let gap &#x3D; parseInt(len &#x2F; 2);\n  &#x2F;&#x2F; 逐渐缩小步数\n  while (gap) &#123;\n    &#x2F;&#x2F; 从第gap个元素开始遍历\n    for (let i &#x3D; gap; i &lt; len; i++) &#123;\n      &#x2F;&#x2F; 逐步其和前面其他的组成员进行比较和交换\n      for (let j &#x3D; i - gap; j &gt;&#x3D; 0; j -&#x3D; gap) &#123;\n        if (arr[j] &gt; arr[j + gap]) &#123;\n          [arr[j], arr[j + gap]] &#x3D; [arr[j + gap], arr[j]];\n        &#125; else &#123;\n          break;\n        &#125;\n      &#125;\n    &#125;\n    gap &#x3D; parseInt(gap &#x2F; 2);\n  &#125;\n&#125;\n\n\n归并排序\n\n\n\n\n\n\n\n\n递归将数组分为两个序列，有序合并这两个序列。作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：\n\n自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）。\n自下而上的迭代。\n\nfunction  &#x2F;**\n     * 归并排序\n     *&#x2F;\n  mergeSort(arr) &#123;\n    let len &#x3D; arr.length;\n    if (len &lt; 2) &#123;\n      return arr;\n    &#125;\n    let middle &#x3D; Math.floor(len &#x2F; 2),\n      left &#x3D; arr.slice(0, middle),\n      right &#x3D; arr.slice(middle);\n    console.log(&#96;处理过程：&#96;, arr);\n    return this.merge(this.mergeSort(left), this.mergeSort(right));\n  &#125;,\n&#x2F;**\n     * 归并排序辅助方法\n     *&#x2F;\nfunction merge(left, right) &#123;\n  let result &#x3D; [];\n  while (left.length &amp;&amp; right.length) &#123;\n    if (left[0] &lt;&#x3D; right[0]) &#123;\n      result.push(left.shift());\n    &#125; else &#123;\n      result.push(right.shift());\n    &#125;\n  &#125;\n  while (left.length) &#123;\n    result.push(left.shift());\n  &#125;\n  while (right.length)&#123;\n    result.push(right.shift());\n  &#125;\n  return result;\n&#125;\n快速排序\n\n\n\n\n\n\n\n\n快速排序算法是一种基于分治思想的排序算法，其核心思路在于通过选取一个基准值，将待排序数组划分为左右两个子序列，其中左侧序列所有元素均小于基准值，右侧序列所有元素均大于基准值。之后对左右子序列递归进行快排操作，最终将整个序列排好序。以下是使用 TypeScript 实现的快速排序算法代码：\nfunction quickSort(arr: number[]): number[] &#123;\n  if (arr.length &lt;&#x3D; 1) &#123;\n    return arr;\n  &#125;\n\n  const pivotIndex &#x3D; Math.floor(arr.length &#x2F; 2);\n  const pivot &#x3D; arr[pivotIndex];\n  const left &#x3D; [];\n  const right &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (i &#x3D;&#x3D;&#x3D; pivotIndex) &#123;\n      continue;\n    &#125;\n\n    const currentItem &#x3D; arr[i];\n\n    if (currentItem &lt; pivot) &#123;\n      left.push(currentItem);\n    &#125; else &#123;\n      right.push(currentItem);\n    &#125;\n  &#125;\n\n  return [...quickSort(left), pivot, ...quickSort(right)];\n&#125;\n\n\n\n\n堆排序\n\n\n\n\n\n\n\n\n堆排序算法是一种基于堆数据结构的排序算法，其核心思路在于将待排序数组看做二叉树，通过构建大顶堆或小顶堆来实现排序。对于大顶堆，每个节点的值均大于或等于它的子节点；对于小顶堆，每个节点的值均小于或等于它的子节点。排序时，取堆顶元素，将其存储到已排序数组中，并从堆中删除；然后重新调整剩余元素形成新的堆，重复以上操作直至所有元素排序完成。以下是使用 TypeScript 实现的堆排序算法代码：\nfunction heapSort(arr: number[]): number[] &#123;\n  const len &#x3D; arr.length;\n\n  &#x2F;&#x2F; 初始化大顶堆，从第一个非叶子结点开始\n  for (let i &#x3D; Math.floor(len &#x2F; 2) - 1; i &gt;&#x3D; 0; i--) &#123;\n    heapify(arr, len, i);\n  &#125;\n\n  &#x2F;&#x2F; 排序，每次将堆顶元素与未排定部分的最后一个元素交换，并重新构造大顶堆\n  for (let i &#x3D; len - 1; i &gt; 0; i--) &#123;\n    [arr[0], arr[i]] &#x3D; [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  &#125;\n\n  return arr;\n&#125;\n\n&#x2F;&#x2F; 堆化函数，将以i为根节点的子树调整为大顶堆\nfunction heapify(arr: number[], len: number, i: number) &#123;\n  let largest &#x3D; i; &#x2F;&#x2F; 最大值默认为根节点\n  const left &#x3D; 2 * i + 1; &#x2F;&#x2F; 左子节点下标\n  const right &#x3D; 2 * i + 2; &#x2F;&#x2F; 右子节点下标\n\n  &#x2F;&#x2F; 如果左子节点比当前最大值大，则更新最大值\n  if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;\n    largest &#x3D; left;\n  &#125;\n\n  &#x2F;&#x2F; 如果右子节点比当前最大值大，则更新最大值\n  if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;\n    largest &#x3D; right;\n  &#125;\n\n  &#x2F;&#x2F; 如果最大值不是根节点，则交换根节点和最大值，并继续调整以最大值为根的子树\n  if (largest !&#x3D;&#x3D; i) &#123;\n    [arr[i], arr[largest]] &#x3D; [arr[largest], arr[i]];\n    heapify(arr, len, largest);\n  &#125;\n&#125;\n\n记数排序\n\n\n\n\n\n\n\n\n记数排序（Counting Sort）是一种非基于比较的排序算法，其时间复杂度为O(n+k)，其中k表示待排序数组中最大元素与最小元素之差加1。该算法的基本思想是统计每个元素在待排序数组中出现的次数，然后根据统计结果构建有序序列。\n&#x2F;**\n * 计数排序\n * @param arr 待排序数组\n * @returns 排序后数组\n *&#x2F;\nfunction countingSort(arr: number[]): number[] &#123;\n  const max &#x3D; Math.max(...arr);\n  const count &#x3D; new Array(max + 1).fill(0);\n\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    count[arr[i]]++;\n  &#125;\n\n  const res &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt;&#x3D; max; i++) &#123;\n    while (count[i]--) &#123;\n      res.push(i);\n    &#125;\n  &#125;\n\n  return res;\n&#125;\n\n桶排序\n\n\n\n\n\n\n\n\n桶排序（Bucket Sort）是一种线性排序算法，它利用了函数的映射关系，将要排序的数据分到有限数量的桶子里，每个桶子再分别排序。桶排序的时间复杂度取决于桶的数量和桶内使用的排序算法，通常情况下是O(n+k)。\n&#x2F;**\n * 桶排序\n * @param arr 待排序数组\n * @param bucketSize 桶大小\n * @returns 排序后数组\n *&#x2F;\nfunction bucketSort(arr: number[], bucketSize &#x3D; 5): number[] &#123;\n  if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;\n    return arr;\n  &#125;\n\n  &#x2F;&#x2F; 找出最大值和最小值\n  let min &#x3D; arr[0];\n  let max &#x3D; arr[0];\n\n  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; min) &#123;\n      min &#x3D; arr[i];\n    &#125; else if (arr[i] &gt; max) &#123;\n      max &#x3D; arr[i];\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 计算桶的数量\n  const bucketCount &#x3D; Math.floor((max - min) &#x2F; bucketSize) + 1;\n  const buckets: number[][] &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; bucketCount; i++) &#123;\n    buckets[i] &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 将元素分配到桶中\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    const index &#x3D; Math.floor((arr[i] - min) &#x2F; bucketSize);\n    buckets[index].push(arr[i]);\n  &#125;\n\n  &#x2F;&#x2F; 对每个桶进行排序，并将结果合并\n  const res &#x3D; [];\n\n  for (let i &#x3D; 0; i &lt; buckets.length; i++) &#123;\n    if (buckets[i]) &#123;\n      const sortedBucket &#x3D; countingSort(buckets[i]);\n\n      for (let j &#x3D; 0; j &lt; sortedBucket.length; j++) &#123;\n        res.push(sortedBucket[j]);\n      &#125;\n    &#125;\n  &#125;\n\n  return res;\n&#125;\n\n基数排序\n\n\n\n\n\n\n\n\n基数排序（Radix Sort）是一种多关键字排序算法，可用于对数字序列进行排序。基数排序先按照最低有效位（LSB）对元素进行排序，然后依次按照次低有效位、次次低有效位……最高有效位进行排序。该算法的时间复杂度为O(d*(n+k))，其中d表示数字位数，k表示每个数字可能的取值范围。\n&#x2F;**\n * 基数排序\n * @param arr 待排序数组\n * @returns 排序后数组\n *&#x2F;\nfunction radixSort(arr: number[]): number[] &#123;\n  const max &#x3D; Math.max(...arr);\n  const buckets: number[][] &#x3D; [];\n\n  &#x2F;&#x2F; 初始化桶\n  for (let i &#x3D; 0; i &lt; 10; i++) &#123;\n    buckets[i] &#x3D; [];\n  &#125;\n\n  &#x2F;&#x2F; 计算最大数字的位数\n  let digitCount &#x3D; 0;\n\n  while (max &gt; 0) &#123;\n    max &#x3D; Math.floor(max &#x2F; 10);\n    digitCount++;\n  &#125;\n\n  &#x2F;&#x2F; 根据每一位进行排序\n  for (let i &#x3D; 0; i &lt; digitCount; i++) &#123;\n    for (let j &#x3D; 0; j &lt; arr.length; j++) &#123;\n      const num &#x3D; arr[j];\n      const digit &#x3D; Math.floor(num &#x2F; Math.pow(10, i)) % 10;\n      buckets[digit].push(num);\n    &#125;\n\n    arr &#x3D; [];\n\n    for (let k &#x3D; 0; k &lt; buckets.length; k++) &#123;\n      while (buckets[k].length) &#123;\n        arr.push(buckets[k].shift()!);\n      &#125;\n    &#125;\n  &#125;\n\n  return arr;\n&#125;\n","slug":"js/前端10大排序算法详解","date":"2023-04-16T02:46:35.000Z","categories_index":"算法","tags_index":"排序","author_index":"前端少年汪"},{"id":"f47aa374ec8bb25754a7283a60088fec","title":"使用Vite+Vue3创建Cesium项目","content":"Vite+Vue3+Cesium项目模版\n\n\n\n\n\n\n\n\nCesium是AGI公司计算机图形开发小组与2011年研发的三维地球和地图可视化开源JavaScript库，Cesium一词来源于化学元素铯，铯是制造原子钟的关键元素，研发小组通过命名强调Cesium产品精益求精，专注时间数据可视化。Cesium为三维GIS提供了一个高效的数据可视化平台\n使用viet创建vue3项目创建vue3项目 这里使用的是vue的模版。如果选择其他框架，则不用加–template vuepnpm create vite vite+vue3+cesium --template vue\n进入项目 cd vite-app\n安装依赖 pnpm install\n运行项目 pnpm run dev\n\n看到这个页面就说明vite+vue3的项目初始化成功了，下面就是安装和初始化cesium框架和cesium的vite插件了 在vite项目中要正常使用cesium我目前知道的有两种方法。\n下面先讲第一种，也就是使用vite-plugin-cesium这个插件 首先找到这个插件的git仓库 https://github.com/nshen/vite-plugin-cesium\n第一种方法installnpm i cesium vite-plugin-cesium vite -D\n\nyarn add cesium vite-plugin-cesium vite -D\n\nUsage在vite.config.js文件中添加cesium的插件\nimport &#123; defineConfig &#125; from &#39;vite&#39;;\nimport cesium from &#39;vite-plugin-cesium&#39;;\nexport default defineConfig(&#123;\n  plugins: [cesium()]\n&#125;);\n\n下面去页面中初始化cesium&lt;script setup&gt;\nimport &#123;onMounted, ref&#125; from &#39;vue&#39;\nimport * as Cesium from &#39;cesium&#39;\n\n&#x2F;&#x2F;cesium初始化必须写在mounted生命周期里面，否则会报错&quot;Element with id &quot;cesiumContainer&quot; does not exist in the document.&quot;\nonMounted(() &#x3D;&gt; &#123;\n  const viewer &#x3D; new Cesium.Viewer(&#39;cesiumContainer&#39;, &#123;\n    &#x2F;&#x2F;这里是配置项\n  &#125;)\n&#125;)\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;div id&#x3D;&quot;cesiumContainer&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n&lt;style scoped&gt;\n#cesiumContainer &#123;\n  width: 100vw;\n  height: 100vh;\n&#125;\n&lt;&#x2F;style&gt;\n\n\n发现样式有些问题。我一看，哦，原来是style.css中有模版的默认样式的影响。 把style.css中的默认样式删除就好了\n\n这才是正确的姿势嘛！🚀\n第2种方法第二种方法就是本地引入，把下载好的cesium依赖包（node_modules里面）复制放到public里面， 然后在index.html里面引入cesium和css文件  \n\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;public&#x2F;Cesium&#x2F;Cesium.js&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;public&#x2F;Cesium&#x2F;Widgets&#x2F;widgets.css&quot;&gt;\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;svg+xml&quot; href&#x3D;&quot;&#x2F;vite.svg&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;title&gt;Vue+Cesium&lt;&#x2F;title&gt;\n      &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;public&#x2F;Cesium&#x2F;Widgets&#x2F;widgets.css&quot;&gt;\n\n![img_3.png](https:&#x2F;&#x2F;p6-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;06e65d12be0540ddb17c9a7b2476a7e2~tplv-k3u1fbpfcp-watermark.image?)\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;public&#x2F;Cesium&#x2F;Cesium.js&quot;&gt;&lt;&#x2F;script&gt;\n\n![img_1.png](https:&#x2F;&#x2F;p3-juejin.byteimg.com&#x2F;tos-cn-i-k3u1fbpfcp&#x2F;cd519580e2904edbb34dc4d0dba5a00b~tplv-k3u1fbpfcp-watermark.image?)\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n然后同样的去页面种初始化cesium就可以了。\n不过还有一个小问题，在控制台中我发现有个报错:\nVM19:1 Blocked script execution in ‘about:blank’ because the document’s frame is sandboxed and the ‘allow-scripts’ permission is not set.\n目前还没找到解决的办法\n下篇文章将介绍vite+react+cesium应该如何搭建react项目框架,以及cesium的一些概念和基本知识。\n","slug":"vue/使用Vite+Vue3创建Cesium项目","date":"2023-04-15T02:46:35.000Z","categories_index":"vue3","tags_index":"cesium","author_index":"前端少年汪"},{"id":"c277cd2494021925450e9b212637db7d","title":"gorm的CRUD操作","content":"gorm的CRUD操作安装go get -u gorm.io&#x2F;gorm\ngo get -u gorm.io&#x2F;driver&#x2F;mysql\n\n第一个是gorm的库，第二个是mysql的连接驱动\n连接数据库GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server\n创建DB实例&#x2F;&#x2F;构建连接字符串\n&#x2F;*注意：想要正确的处理 time.Time ，您需要带上 parseTime 参数， (更多参数)要支持完整的 UTF-8 编码，您需要将 charset&#x3D;utf8 更改为 charset&#x3D;utf8mb4 查看 此文章 获取详情*&#x2F;\ndsn :&#x3D; &quot;root:password1234@tcp(127.0.0.1:3306)&#x2F;gorm?charset&#x3D;utf8mb4&amp;parseTime&#x3D;True&amp;loc&#x3D;Local&quot;\ndb, _ &#x3D; gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)\n\n结构体映射数据库表创建结构体\npackage main\n\nimport (\n\t&quot;gorm.io&#x2F;gorm&quot;\n)\n\ntype User struct &#123;\n\tgorm.Model\n\tName string\n\tAge  uint8\n&#125;\n\n使用db.AutoMigrate(User&#123;&#125;)方法从结构体生成数据库表\n连接设置sqlDB, _ :&#x3D; db.DB()\n\n&#x2F;&#x2F; SetMaxIdleConns 设置空闲连接池中连接的最大数量\nsqlDB.SetMaxIdleConns(10)\n\n&#x2F;&#x2F; SetMaxOpenConns 设置打开数据库连接的最大数量。\nsqlDB.SetMaxOpenConns(100)\n\n&#x2F;&#x2F; SetConnMaxLifetime 设置了连接可复用的最大时间。\nsqlDB.SetConnMaxLifetime(time.Hour)\n\n插入数据\n&#x2F;&#x2F;添加数据\nfunc add() &#123;\n    &#x2F;&#x2F;插入单条数据\n    user :&#x3D; User&#123;Model: gorm.Model&#123;&#125;, Name: &quot;wmq&quot;, Age: 17&#125;\n    result :&#x3D; db.Create(&amp;user)\n    fmt.Println(user.ID, result.RowsAffected)\n    \n    &#x2F;&#x2F;插入指定字段\n    result &#x3D; db.Select(&quot;Name&quot;, &quot;Age&quot;).Create(&amp;User&#123;Name: &quot;前端少年&quot;, Age: 22&#125;)\n    fmt.Println(user, result.RowsAffected)\n    \n    &#x2F;&#x2F;切片批量插入\n    var users &#x3D; []User&#123;&#123;Name: &quot;w1&quot;&#125;, &#123;Name: &quot;w2&quot;&#125;, &#123;Name: &quot;w3&quot;&#125;&#125;\n    result &#x3D; db.Create(&amp;users)\n    fmt.Println(&quot;users&quot;, result.RowsAffected, users)\n    \n    &#x2F;&#x2F;map批量插入\n    db.Model(&amp;User&#123;&#125;).Create(map[string]interface&#123;&#125;&#123;\n         &quot;Name&quot;: &quot;jinzhu&quot;, &quot;Age&quot;: 18,\n    &#125;)\n    \n    &#x2F;&#x2F; 根据 &#96;[]map[string]interface&#123;&#125;&#123;&#125;&#96; 批量插入\n    db.Model(&amp;User&#123;&#125;).Create([]map[string]interface&#123;&#125;&#123;\n        &#123;&quot;Name&quot;: &quot;&quot;, &quot;Age&quot;: nil&#125;,\n        &#123;&quot;Name&quot;: &quot;&quot;, &quot;Age&quot;: nil&#125;,\n        &#123;&#125;,\n    &#125;)\n&#125;\n\n创建时的Hook操作// 开始事务BeforeSaveBeforeCreate// 关联前的 save// 插入记录至 db // 关联后的 saveAfterCreate AfterSave// 提交或回滚事务\n更新数据\n  使用Save方法 会保存所有的字段，即使字段是零值\n\n\n&#x2F;&#x2F;修改\nfunc update() &#123;\n\t&#x2F;&#x2F;更新单列\n\tvar user User\n\tuser.Name &#x3D; &quot;迁客骚人&quot;\n\tuser.Age &#x3D; 100\n\tdb.Save(&amp;user)\n\tfmt.Println(user.Name)\n\n\t&#x2F;&#x2F; 条件更新\n\tdb.Model(&amp;User&#123;&#125;).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE active&#x3D;true;\n\n\t&#x2F;&#x2F; User 的 ID 是 &#96;111&#96;\n\tdb.Model(&amp;user).Update(&quot;name&quot;, &quot;hello&quot;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n\t&#x2F;&#x2F; 根据条件和 model 的值进行更新\n\tdb.Model(&amp;user).Where(&quot;active &#x3D; ?&quot;, true).Update(&quot;name&quot;, &quot;hello&quot;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111 AND active&#x3D;true;\n\n\t&#x2F;&#x2F; 根据 &#96;struct&#96; 更新属性，只会更新非零值的字段\n\tdb.Model(&amp;user).Updates(User&#123;Name: &quot;hello&quot;, Age: 18&#125;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, updated_at &#x3D; &#39;2013-11-17 21:34:10&#39; WHERE id &#x3D; 111;\n\n\t&#x2F;&#x2F; 根据 &#96;map&#96; 更新属性\n\tdb.Model(&amp;user).Updates(map[string]interface&#123;&#125;&#123;&quot;Name&quot;: &quot;hello&quot;, &quot;Age&quot;: 18&#125;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18, actived&#x3D;false, updated_at&#x3D;&#39;2013-11-17 21:34:10&#39; WHERE id&#x3D;111;\n\n\t&#x2F;&#x2F;批量更新\n\t&#x2F;&#x2F; 根据 struct 更新\n\tdb.Model(User&#123;&#125;).Where(&quot;role &#x3D; ?&quot;, &quot;admin&quot;).Updates(User&#123;Name: &quot;wmq&quot;, Age: 18&#125;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE role &#x3D; &#39;admin;\n\n\t&#x2F;&#x2F; 根据 map 更新\n\tdb.Table(&quot;users&quot;).Where(&quot;id IN ?&quot;, []int&#123;10, 11&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: 18&#125;)\n\t&#x2F;&#x2F; UPDATE users SET name&#x3D;&#39;hello&#39;, age&#x3D;18 WHERE id IN (10, 11);\n&#125;\n\n\nxorm的CRUD操作xorm的特性\n支持Struct和数据库表之间的灵活映射，并支持自动同步\n事务支持\n同时支持原始SQL语句和ORM操作的混合执行\n使用连写来简化调用\n支持使用Id, In, Where, Limit, Join, Having, Table, SQL, Cols等函数和结构体等方式作为条件\n支持级联加载Struct\nSchema支持（仅Postgres）\n支持缓存\n支持根据数据库自动生成xorm的结构体\n支持记录版本（即乐观锁）\n内置SQL Builder支持 \n通过EngineGroup支持读写分离和负载均衡\n\n安装go get xorm.io&#x2F;xorm\n\n\n创建 Engine 引擎  创建结构体同步数据库表&#x2F;&#x2F; CoonXormMysql 连接数据库\npackage main\n\nimport (\n&quot;fmt&quot;\n_ &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n&quot;time&quot;\n&quot;xorm.io&#x2F;xorm&quot;\n)\n\n&#x2F;&#x2F;数据库连接基本信息\nvar (\n   userName  string &#x3D; &quot;root&quot;\n   password  string &#x3D; &quot;12138&quot;\n   ipAddress string &#x3D; &quot;127.0.0.1&quot;\n   port      int    &#x3D; 3306\n   dbName    string &#x3D; &quot;xorm_db&quot;\n   charset   string &#x3D; &quot;utf8mb4&quot;\n)\n\ntype User struct &#123;\n   Id      int64\n   Name    string\n   Age     int\n   Passwd  string    &#96;xorm:&quot;varchar(200)&quot;&#96;\n   Created time.Time &#96;xorm:&quot;created&quot;&#96;\n   Updated time.Time &#96;xorm:&quot;updated&quot;&#96;\n&#125;\n\nvar engine *xorm.Engine\n\n&#x2F;&#x2F; CoonXormMysql 连接数据库\nfunc CoonXormMysql() &#123;\n   &#x2F;&#x2F;构建数据库连接信息\n   dataSourceName :&#x3D; fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)&#x2F;%s?charset&#x3D;%s&quot;, userName, password, ipAddress, port, dbName, charset)\n   &#x2F;&#x2F;创建引擎\n   engine, _ &#x3D; xorm.NewEngine(&quot;mysql&quot;, dataSourceName)\n\n   err :&#x3D; engine.Sync2(new(User))\n   if err !&#x3D; nil &#123;\n      fmt.Println(&quot;同步失败&quot;)\n   &#125;\n&#125;\n\n\n#CRUD操作使用Engine的insert，query，update，delete等方法\n添加\n插入一条数据，此时可以用Insert或者InsertOne \nuser :&#x3D; User&#123;Id: 1, Name: &quot;wmq1&quot;, Age: 17, Passwd: &quot;1234567&quot;&#125;\nn, _ :&#x3D; engine.Insert(user)\n插入数据使用Insert方法，Insert方法的参数可以是一个或多个Struct的指针，一个或多个Struct的Slice的指针。如果传入的是Slice并且当数据库支持批量插入时，Insert会使用批量插入的方式进行插入。\n&#x2F;&#x2F;user切片\nvar users []User\nusers &#x3D; append(users, User&#123;Id: 2, Name: &quot;wmq2&quot;, Age: 11, Passwd: &quot;12344567&quot;&#125;)\nusers &#x3D; append(users, User&#123;Id: 3, Name: &quot;wmq3&quot;, Age: 10, Passwd: &quot;12344567&quot;&#125;)\nn, _ &#x3D; engine.Insert(users)\n\n\n\n\n\n\n\n\n\n这里虽然支持同时插入，但这些插入并没有事务关系。因此有可能在中间插入出错后，后面的插入将不会继续。此时前面的插入已经成功，如果需要回滚，请开启事务。批量插入会自动生成Insert into table values (),(),()的语句，因此各个数据库对SQL语句有长度限制，因此这样的语句有一个最大的记录数，根据经验测算在150条左右。大于150条后，生成的sql语句将太长可能导致执行失败。因此在插入大量数据时，目前需要自行分割成每150条插入一次。\n\n\n查询&#x2F;&#x2F;查询\nfunc query() &#123;\n   &#x2F;&#x2F;使用sql语句查询\n   results, _ :&#x3D; engine.Query(&quot;select * from user&quot;)\n   fmt.Println(results)\n   results2, _ :&#x3D; engine.QueryString(&quot;select * from user&quot;)\n   fmt.Println(results2)\n   results3, _ :&#x3D; engine.QueryInterface(&quot;select * from user&quot;)\n   fmt.Println(results3)\n\n   &#x2F;&#x2F;Get 只能查询单条数据\n   user :&#x3D; User&#123;&#125;\n   engine.Get(&amp;user)\n   fmt.Println(&quot;查询单条数据&quot;, user)\n\n   &#x2F;&#x2F;指定条件查询\n   user1 :&#x3D; User&#123;Name: &quot;wmq1&quot;&#125;\n   engine.Where(&quot;name&#x3D;?&quot;, user1.Name).Asc(&quot;id&quot;).Get(&amp;user1)\n   fmt.Println(&quot;指定条件查询&quot;, user1)\n\n   &#x2F;&#x2F;获取指定字段的值\n   var name string\n   engine.Table(&amp;user).Where(&quot;id &#x3D; 3&quot;).Cols(&quot;name&quot;).Get(&amp;name)\n   fmt.Println(&quot;获取指定字段的值&quot;, name)\n\n   &#x2F;&#x2F;查询多条&#x2F;所有记录 find\n   var users []User &#x2F;&#x2F;定义切片\n   engine.Find(&amp;users)\n   fmt.Println(&quot;查询多条&#x2F;所有记录&quot;, users)\n\n   &#x2F;&#x2F;Count 获取记录条数\n   user2 :&#x3D; User&#123;Passwd: &quot;12344567&quot;&#125;\n   count, _ :&#x3D; engine.Count(&amp;user2)\n   fmt.Println(&quot;获取记录条数&quot;, count)\n\n   &#x2F;&#x2F;Iterate 和 Rows根据条件遍历数据\n   engine.Iterate(&amp;User&#123;Passwd: &quot;12344567&quot;&#125;, func(idx int, bean interface&#123;&#125;) error &#123;\n      user :&#x3D; bean.(*User)\n      fmt.Println(&quot;Iterate 和 Rows根据条件遍历数据&quot;, user)\n      return nil\n   &#125;)\n   rows, _ :&#x3D; engine.Rows(&amp;User&#123;Passwd: &quot;12344567&quot;&#125;)\n   defer rows.Close()\n   userBean :&#x3D; new(User)\n   for rows.Next() &#123;\n      rows.Scan(userBean)\n      fmt.Println(userBean)\n   &#125;\n&#125;\n\n\n修改&#x2F;&#x2F;修改\nfunc update() &#123;\n   &#x2F;&#x2F;更新\n   user :&#x3D; User&#123;Name: &quot;前端少年汪&quot;&#125;\n   n, _ :&#x3D; engine.ID(1).Update(&amp;user)\n   fmt.Println(n)\n&#125;\n\n删除&#x2F;&#x2F;删除\nfunc del() &#123;\n   &#x2F;&#x2F;删除\n   var user1 User\n   n1, _ :&#x3D; engine.ID(3).Delete(&amp;user1)\n   fmt.Println(n1)\n   \n&#125;\n\n执行一个sql语句engine.Exec(&quot;update user set age &#x3D; ? where id &#x3D; ?&quot;, 10, 1001)\n\n完整代码package main\n\nimport (\n   &quot;fmt&quot;\n   _ &quot;gorm.io&#x2F;driver&#x2F;mysql&quot;\n   &quot;time&quot;\n   &quot;xorm.io&#x2F;xorm&quot;\n)\n\n&#x2F;&#x2F;数据库连接基本信息\nvar (\n   userName  string &#x3D; &quot;root&quot;\n   password  string &#x3D; &quot;12138&quot;\n   ipAddress string &#x3D; &quot;127.0.0.1&quot;\n   port      int    &#x3D; 3306\n   dbName    string &#x3D; &quot;xorm_db&quot;\n   charset   string &#x3D; &quot;utf8mb4&quot;\n)\n\ntype User struct &#123;\n   Id      int64\n   Name    string\n   Age     int\n   Passwd  string    &#96;xorm:&quot;varchar(200)&quot;&#96;\n   Created time.Time &#96;xorm:&quot;created&quot;&#96;\n   Updated time.Time &#96;xorm:&quot;updated&quot;&#96;\n&#125;\n\nvar engine *xorm.Engine\n\nfunc main() &#123;\n   fmt.Println(&quot;xorm 学习&quot;)\n\n   CoonXormMysql()\n   var input int\n\n   var flag bool &#x3D; true\n   for flag &#123;\n      fmt.Println(&quot;1.添加&quot;)\n      fmt.Println(&quot;2.查询&quot;)\n      fmt.Println(&quot;3.更新&quot;)\n      fmt.Println(&quot;4.删除&quot;)\n      fmt.Println(&quot;5.退出&quot;)\n      fmt.Scan(&amp;input)\n      if input &#x3D;&#x3D; 1 &#123;\n         add()\n      &#125; else if input &#x3D;&#x3D; 2 &#123;\n         query()\n      &#125; else if input &#x3D;&#x3D; 3 &#123;\n         update()\n      &#125; else if input &#x3D;&#x3D; 4 &#123;\n         del()\n      &#125; else if input &#x3D;&#x3D; 5 &#123;\n         flag &#x3D; false\n      &#125;\n   &#125;\n\n&#125;\n\n&#x2F;&#x2F; CoonXormMysql 连接数据库\nfunc CoonXormMysql() &#123;\n   &#x2F;&#x2F;构建数据库连接信息\n   dataSourceName :&#x3D; fmt.Sprintf(&quot;%s:%s@tcp(%s:%d)&#x2F;%s?charset&#x3D;%s&quot;, userName, password, ipAddress, port, dbName, charset)\n   &#x2F;&#x2F;创建引擎\n   engine, _ &#x3D; xorm.NewEngine(&quot;mysql&quot;, dataSourceName)\n\n   err :&#x3D; engine.Sync2(new(User))\n   if err !&#x3D; nil &#123;\n      fmt.Println(&quot;同步失败&quot;)\n   &#125;\n&#125;\n\n&#x2F;&#x2F;添加\nfunc add() &#123;\n   user :&#x3D; User&#123;Id: 1, Name: &quot;wmq1&quot;, Age: 17, Passwd: &quot;1234567&quot;&#125;\n   n, _ :&#x3D; engine.Insert(user)\n   fmt.Println(n)\n   if n &gt;&#x3D; 1 &#123;\n      fmt.Println(&quot;插入成功&quot;)\n   &#125;\n\n   &#x2F;&#x2F;user切片\n   var users []User\n   users &#x3D; append(users, User&#123;Id: 2, Name: &quot;wmq2&quot;, Age: 11, Passwd: &quot;12344567&quot;&#125;)\n   users &#x3D; append(users, User&#123;Id: 3, Name: &quot;wmq3&quot;, Age: 10, Passwd: &quot;12344567&quot;&#125;)\n   n, _ &#x3D; engine.Insert(users)\n\n&#125;\n\n&#x2F;&#x2F;查询\nfunc query() &#123;\n   &#x2F;&#x2F;使用sql语句查询\n   results, _ :&#x3D; engine.Query(&quot;select * from user&quot;)\n   fmt.Println(results)\n   results2, _ :&#x3D; engine.QueryString(&quot;select * from user&quot;)\n   fmt.Println(results2)\n   results3, _ :&#x3D; engine.QueryInterface(&quot;select * from user&quot;)\n   fmt.Println(results3)\n\n   &#x2F;&#x2F;Get 只能查询单条数据\n   user :&#x3D; User&#123;&#125;\n   engine.Get(&amp;user)\n   fmt.Println(&quot;查询单条数据&quot;, user)\n\n   &#x2F;&#x2F;指定条件查询\n   user1 :&#x3D; User&#123;Name: &quot;wmq1&quot;&#125;\n   engine.Where(&quot;name&#x3D;?&quot;, user1.Name).Asc(&quot;id&quot;).Get(&amp;user1)\n   fmt.Println(&quot;指定条件查询&quot;, user1)\n\n   &#x2F;&#x2F;获取指定字段的值\n   var name string\n   engine.Table(&amp;user).Where(&quot;id &#x3D; 3&quot;).Cols(&quot;name&quot;).Get(&amp;name)\n   fmt.Println(&quot;获取指定字段的值&quot;, name)\n\n   &#x2F;&#x2F;查询多条&#x2F;所有记录 find\n   var users []User &#x2F;&#x2F;定义切片\n   engine.Find(&amp;users)\n   fmt.Println(&quot;查询多条&#x2F;所有记录&quot;, users)\n\n   &#x2F;&#x2F;Count 获取记录条数\n   user2 :&#x3D; User&#123;Passwd: &quot;12344567&quot;&#125;\n   count, _ :&#x3D; engine.Count(&amp;user2)\n   fmt.Println(&quot;获取记录条数&quot;, count)\n\n   &#x2F;&#x2F;Iterate 和 Rows根据条件遍历数据\n   engine.Iterate(&amp;User&#123;Passwd: &quot;12344567&quot;&#125;, func(idx int, bean interface&#123;&#125;) error &#123;\n      user :&#x3D; bean.(*User)\n      fmt.Println(&quot;Iterate 和 Rows根据条件遍历数据&quot;, user)\n      return nil\n   &#125;)\n   rows, _ :&#x3D; engine.Rows(&amp;User&#123;Passwd: &quot;12344567&quot;&#125;)\n   defer rows.Close()\n   userBean :&#x3D; new(User)\n   for rows.Next() &#123;\n      rows.Scan(userBean)\n      fmt.Println(userBean)\n   &#125;\n&#125;\n\n&#x2F;&#x2F;修改\nfunc update() &#123;\n   &#x2F;&#x2F;更新\n   user :&#x3D; User&#123;Name: &quot;前端少年汪&quot;&#125;\n   n, _ :&#x3D; engine.ID(1).Update(&amp;user)\n   fmt.Println(n)\n&#125;\n\n&#x2F;&#x2F;删除\nfunc del() &#123;\n   &#x2F;&#x2F;删除\n   var user1 User\n   n1, _ :&#x3D; engine.ID(3).Delete(&amp;user1)\n   fmt.Println(n1)\n&#125;\n\n\n以上就是go使用gorm或者xorm的一个最简单的crud的基本操作了，当然gorm和xorm的功能远不止如此，更多的特性和功能可以在开发过程中查阅其官网即可  \ngorm 和 xorm 的区别gorm 和 xorm 都是 Go 语言中常用的 ORM（对象关系映射）框架。下面是它们的主要区别：\n\n设计哲学不同：gorm 设计思维更加严谨、规范化，更加注重符合 SQL 标准；xorm 设计思维更加灵活，允许用户通过指定标签轻松映射 struct，提供了更多针对 NoSQL 数据库的支持。\n\n性能表现不同：根据各自的 benchmark 结果，xorm 的性能通常比 gorm 更高，并且 xorm 对于连接池的处理也更优秀。\n\n使用方式不同：gorm 支持链式调用和原生 SQL，而 xorm 和 gorm 都支持链式调用和模板语言。\n\n社区支持度不同：由于 gorm 的设计更加严谨，因此它的稳定性和一致性更高，得到了更加广泛的社区支持和认可。而 xorm 在社区中的影响力不如 gorm，但是在某些特定领域（例如非关系型数据库）中的支持度相对较好。\n\n\n总体来说，gorm 和 xorm 的目标群体有所不同，gorm 更适合那些需要严格符合 SQL 标准、更加稳定的场景，而 xorm 更适用于需要灵活性和可扩展性的场景。当然，选择哪一个 ORM 还需要根据具体项目的需求和开发者的个人喜好做出决定。\n","slug":"go/一文入门gorm和xorm的基本操作（CRUD）","date":"2023-04-14T02:46:35.000Z","categories_index":"go","tags_index":"gorm","author_index":"前端少年汪"},{"id":"89c83197a75c1245116b0a9c7aba1d2b","title":"vite使用入门","content":"为开发提供极速响应v4.1.0\n目前Vite已经更新到v4.1.0的版本了\n\nvite的特性\n\n  💡极速的服务启动，意思就是一个字快\n  ⚡️轻量快速的热重载，就是说热更新也很快\n  🔧丰富的功能，支持的工具集比较多，开箱即用\n  📦优化的构建 对于生产环境的构建有更好的优化\n  🔩通用的插件，在开发和构建之间共享 Rollup-superset 插件接口。\n完全类型化的API 使用TS，有较好的语法提示和类型支持\n\n使用Vite创建项目\n使用npm\nnpm create vite@latest\n\n使用yarn\nyarn create vite\n\n使用pnpm\npnpm create vite\n\n如果使用vite创建Vue项目的话，可以创建带模版的vue项目\n# npm 6.x\nnpm create vite@latest my-vue-app --template vue\n\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n查看 create-vite 以获取每个模板的更多细节：vanilla，vanilla-ts, vue, vue-ts，react，react-ts，react-swc，react-swc-ts，preact，preact-ts，lit，lit-ts，svelte，svelte-ts。\n区分开发环境，测试环境和生产环境\n首先在项目根目录下创建.env文件,Vite 使用 dotenv 从你的 环境目录 中的下列文件加载额外的环境变量\n.env                # 所有情况下都会加载\n.env.local          # 所有情况下都会加载，但会被 git 忽略\n.env.[mode]         # 只在指定模式下加载\n.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略\n\n.env.development\t\t# 开发模式\n.env.production\t\t\t# 生产模式\n.env.test\t\t\t\t\t\t# 测试模式\n\n默认情况下\n\n  npm run dev 会加载 .env 和 .env.development 内的配置\n  npm run build 会加载 .env 和 .env.production 内的配置\n  mode 可以通过命令行 –mode 选项来重写。\n\n**\n在package.json文件中配置一个test命令\n\n**\n环境加载优先级\n一份用于指定模式的文件（例如 .env.production）会比通用形式的优先级更高（例如 .env）。\n另外，Vite 执行时已经存在的环境变量有最高的优先级，不会被 .env 类文件覆盖。例如当运行 VITE_SOME_KEY=123 vite build 的时候。\n.env 类文件会在 Vite 启动一开始时被加载，而改动会在重启服务器后生效\nconsole.log(&#39;获取当前目录&#39;,process.cwd());\n&#x2F;&#x2F;参数：模式：development||production,入口文件，修改.env变量前缀\nconst env&#x3D;loadEnv(&#39;development&#39;,process.cwd(),&#39;wmq&#39;)\nconsole.log(env);\n\n\n加载的环境变量也会通过 import.meta.env 以字符串形式暴露给客户端源码。\n为了防止意外地将一些环境变量泄漏到客户端，只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码\n所以这里如果没配置前缀的话，import.meta.env 就访问不到了\nVITE_BASE_API&#x3D;base&#x2F;api\t这个可以被访问到\nwmq_client&#x3D;&#39;aa🤔&#39;。访问不了\n\n使用envPrefix方法可以更换环境变量的前缀\n\n然后在main.js文件中去打印import.mate.env的环境变量，在不同的开发模式下就可以获取到相应的环境变量了\n\n开发模式下\n\n生产模式下\n\n测试模式下\n\n通过验证我们可以看出，不管是什么模式下，都可以加载到.env文件中的变量\n更改.env的默认地址\n我们现在的.env文件都是建立在根目录的，如果.env.XX的文件太多，会显得我们的项目目录很乱，我们能将.env放在一个统一的文件夹内吗？\n可以通过envDir配置来改变！参考：共享配置 | Vite 官方中文文档\nenvDir用于加载 .env 文件的目录。可以是一个绝对路径，也可以是相对于项目根的路径。\n\n  类型： string\n  默认： root\n\n比如，我们在vite.config.js中这样配置\nimport &#123; defineConfig &#125; from &quot;vite&quot;;\nexport default defineConfig( &#123;\n  envDir:&quot;env&quot;\n&#125;);\n\n然后，所有的.env.xxx文件就可以放在项目根目录的env文件夹下了。\n配置服务端选项export default defineConfig(&#123;\n  server: &#123;\n    host: &#39;localhost&#39;,&#x2F;&#x2F;  开放服务器启动的地址，默认时localhost\n    port: 9000,&#x2F;&#x2F;项目启动端口\n    open: true,&#x2F;&#x2F;项目启动时是否打开浏览器\n    base:&#39;&#x2F;&#39;,&#x2F;&#x2F;用于代理 Vite 作为子文件夹时使用。\n    cors: true,&#x2F;&#x2F;为开发服务器配置 CORS。默认启用并允许任何源，传递一个 选项对象 来调整行为或设为 false 表示禁用。\n    headers:&#123;&#125;,&#x2F;&#x2F;指定服务端响应的headers信息\n    strictPort:true,&#x2F;&#x2F;设为 true 时若端口已被占用则会直接退出，而不是尝试下一个可用端口。\n    proxy: &#123;&#x2F;&#x2F;配置后端代理\n      &#x2F;&#x2F; 字符串简写写法\n      &#39;&#x2F;foo&#39;: &#39;http:&#x2F;&#x2F;localhost:4567&#39;,\n      &#x2F;&#x2F; 选项写法\n      &#39;&#x2F;api&#39;: &#123;\n        target: &#39;http:&#x2F;&#x2F;jsonplaceholder.typicode.com&#39;,&#x2F;&#x2F;指向后端地址\n        changeOrigin: true,&#x2F;&#x2F;允许跨域\n        rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^&#x2F;api&#x2F;, &#39;&#39;)\n      &#125;,\n      &#x2F;&#x2F; 正则表达式写法\n      &#39;^&#x2F;fallback&#x2F;.*&#39;: &#123;\n        target: &#39;http:&#x2F;&#x2F;jsonplaceholder.typicode.com&#39;,\n        changeOrigin: true,\n        rewrite: (path) &#x3D;&gt; path.replace(&#x2F;^&#x2F;fallback&#x2F;, &#39;&#39;)\n      &#125;,\n      &#x2F;&#x2F; 使用 proxy 实例\n      &#39;&#x2F;api&#39;: &#123;\n        target: &#39;http:&#x2F;&#x2F;jsonplaceholder.typicode.com&#39;,\n        changeOrigin: true,\n        configure: (proxy, options) &#x3D;&gt; &#123;\n          &#x2F;&#x2F; proxy 是 &#39;http-proxy&#39; 的实例\n        &#125;\n      &#125;,\n      &#x2F;&#x2F; Proxying websockets or socket.io\n      &#39;&#x2F;socket.io&#39;: &#123;\n        target: &#39;ws:&#x2F;&#x2F;localhost:3000&#39;,\n        ws: true\n      &#125;\n    &#125;，\n  &#125;\n&#125;)\n\nserver其中server是比较常用的重要属性，特别是proxy主要是配置代理后端API地址的\n\n  target\n  changeOrigin\n  rewrite\n\n服务端的选项常用的大概就这些了，期中最常用的就是解决开发过程中的跨域问题了，需要在proxy里面去设置即可，其他的不常用的选项如有用到去查vite官网的服务器选项\n\n配置CSSexport default defineConfig(&#123;\n  &#x2F;&#x2F;css配置\n  css: &#123;\n    &#x2F;&#x2F; 开发模式为true，生产模式为flase, devSourcemap:true,&#x2F;&#x2F;源代码映射\n    devSourcemap:command &#x3D;&#x3D;&#x3D; &#39;serve&#39;,\n    &#x2F;&#x2F; css模块化配置项\n    modules:&#123;\n      &#x2F;&#x2F; 是否开启模块化。模块化or全局化\n      scopeBehaviour: &#39;global&#39; | &#39;local&#39;,\n      &#x2F;&#x2F; css模块化的路径\n      globalModulePaths: RegExp[],\n      &#x2F;&#x2F; 更改生成的哈希名称，一个字符串模板或者通过函数返回\n      generateScopedName: string| ((name, filename, css) &#x3D;&gt; string),\n      &#x2F;&#x2F; 生成hash名称的前缀\n      hashPrefix: string,\n      &#x2F;&#x2F; 修改生成的配置对象的key的展示形式(驼峰还是中划线形式)\n      localsConvention:&#39;camelCase&#39;\n        | &#39;camelCaseOnly&#39;\n        | &#39;dashes&#39;\n        | &#39;dashesOnly&#39;\n        | null\n    &#125;,\n    &#x2F;&#x2F; 预处理器配置项\n    preprocessorOptions: &#123;\n      less: &#123;\n        math: &quot;always&quot;,\n      &#125;,\n      scss: &#123;\n        additionalData: &#39;@import &quot;src&#x2F;assets&#x2F;styles&#x2F;var.scss&quot;;&#39;\n      &#125;\n    &#125;,\n    \n    postcss:&#123;\n      &#x2F;&#x2F; 一些配置\n    &#125;\n\n  &#125;\n&#125;)\n\ncss的配置主要是一些css的模块化和预处理器的配置。比如scss，less，postcss等等\n模块化属性\n  scopeBehaviour：是否开启模块化，global为全局化，local为模块化\n  globalModulePaths：css模块化的路径\n  generateScopedName：生成的哈希名称，一个字符串模板或者通过函数返回\n  hashPrefix：生成hash名称的前缀\nlocalsConvention：生成的配置对象的key的展示形式(驼峰还是中划线形式)\n\n其他的less，scss，postcss属性使用的时候查询官方文档即可\n其他的一些常用小配置\n配置别名export default defineConfig(&#123;\n  resolve:&#123;\n        alias:&#123;\n            &#39;@&#39;: resolve(__dirname, &#39;src&#39;)&#x2F;&#x2F;配置别名\n        &#125;\n    &#125;\n&#125;)\n\n打包速度的问题vite在打包中会计算包的大小，但是只是计算不做处理，会长打包时间，所以可以在build中再添加一个配置项关闭打包计算。\n启用/禁用 gzip 压缩大小报告。压缩大型输出文件可能会很慢，因此禁用该功能可能会提高大型项目的构建性能。\nbrotliSize: false,&#x2F;&#x2F;vite2\nreportCompressedSize:false &#x2F;&#x2F;vite3\n\ngizp压缩plugins: [vue(),\n      viteCompression(&#123;\n        &#x2F;&#x2F;生成压缩包gz\n        verbose: true,\n        disable: false,\n        threshold: 10240,\n        algorithm: &#39;gzip&#39;,\n        ext: &#39;.gz&#39;,\n    &#125;),],\n\n我把打包后的项目用express稍微搭了个后台跑了一下，发现express开启了gzip和没开启gzip，都是一样的。不知道vite是不是默认启动gzip压缩？有了解的小伙伴也可以说一下。\n生产环境移除consolebuild:&#123;\n  ...\n  terserOptions: &#123;\n      compress: &#123;\n        drop_console: true,\n        drop_debugger: true\n      &#125;\n  &#125;\n&#125;\n\n以上就是vite的一些常用的项目配置了，基本上绝大多数都是在项目中需要经常使用的，而且随着前端技术的不断发展，构建工具也是在不停的更新迭代，作为技术人员也得紧跟技术潮流，也许你现在的项目用的不是vite，但是你不能说你不会，所谓技多不压身嘛，小伙伴们赶紧学起来吧！🚀\n\n","slug":"vue/vite3使用指南,小白再也不用担心项目配置问题了","date":"2023-04-13T02:46:35.000Z","categories_index":"vite","tags_index":"vite","author_index":"前端少年汪"},{"id":"4112198ee0b9e47478edd7a567ce5aa9","title":"python多线程爬虫-下载wallhaven超清壁纸","content":"\n\n\n\n\n\n\n\n\n\n大家好我是前端少年汪！痴迷技术，对programming有着极大的兴趣和爱好。从明天起，做一个新思维的人 继承，多态，层层封装 从明天起,不再关心内存管理 让每一条数据，自动放到合适的位子上 从明天起，我将为每一个对象 取一个温暖的名字 它们用驼峰命名，优雅，大方 陌生人，我也祝福你哈 愿你不再为系统级bug烦恼 愿你在平台之间肆意游荡 愿你不再关心溢出与异常\n爬取的目标网站：https://wallhaven.cc/\n\n使用到的库：\n\n  requests\n  Xpath\n\n分析目标网站的DOM结构我们可以看到这个网站总共分为六个大的模块：Latest，Hot，Toplist，Random，Upload，Forums我爬取的主要是latest，hot，toplist，random这四个模块的图片.这四个模块对应的url网址分别为：\n\n  https://wallhaven.cc/latest\n  https://wallhaven.cc/hot\n  https://wallhaven.cc/toplist\n  https://wallhaven.cc/random\n\n图片的预览页面\n\n这里可以看到page=2的页面总共🈶️24张图片，这个只是缩略图，点击单个item项就可以进入到图片的详情页，可以看到对应的图片的详情页面的url在section&gt;ul&gt;li&gt;figure&gt;a标签的href属性中。\n图片的详情页\n\n可以看到真正的图片的url是存在于img标签的src属性，只要我们拿到这个图片的地址就可以下载图片到本地了。\n梳理一下逻辑：\n 请求latest，hot，toplist，random四个模块中的任意一个页面获取到缩略图的a标签里面的url，保存到一个列表里面\n 遍历缩略图列表，获取详情页img标签的src图片地址\n 请求图片地址，下载保存到本地\n\n大概的逻辑就是这么简单\n代码实现导入相关包，定义全局变量import os\nimport threading\n\nimport requests\nfrom lxml import etree\n\n&quot;&quot;&quot;\n爬取网站：https:&#x2F;&#x2F;wallhaven.cc&#x2F;\n&quot;&quot;&quot;\n# 伪装浏览器请求\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36&#39;\n&#125;\n# 存放下载图片的文件夹名称\nnew_folder &#x3D; &#39;img&#39;\n# 5个模块对应的字符串列表\ntype_list &#x3D; [&#39;hot&#39;, &#39;toplist&#39;, &#39;latest&#39;, &#39;random&#39;]\n# 线程池\nthreads &#x3D; []\n\n获取缩略图页面# 单页下载，只下载一页24张图片\ndef get_wall_one_page(type_index: int, page_num) -&gt; None:\n    # page_num爬取的页码\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], page_num)\n    print(url)\n    # 获取当前目录\n    current_dir &#x3D; os.getcwd()\n\n    # 新文件夹的名称\n    # new_folder &#x3D; &#39;img_&#123;&#125;&#39;.format(type_list[type_index])  # 创建新文件夹\n    if not os.path.exists(new_folder):\n        os.mkdir(os.path.join(current_dir, new_folder))\n\n    res &#x3D; requests.get(url, headers&#x3D;headers).text\n    selector &#x3D; etree.HTML(res)\n    img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n    # 调用获取详情页方法\n    detail_img(img_urls)\n\n\n获取图片详情页面def detail_img(img_urls):\n    &quot;&quot;&quot;\n    图片详情\n    :param img_urls:获取到单个图片item的详情url\n    :return:\n    &quot;&quot;&quot;\n    i &#x3D; 0\n\n    for item in img_urls:\n        son_res &#x3D; requests.get(item, headers&#x3D;headers).text\n        selector &#x3D; etree.HTML(son_res)\n        src_arr &#x3D; selector.xpath(&#39;&#x2F;&#x2F;img[@id&#x3D;\\&#39;wallpaper\\&#39;]&#x2F;@src&#39;)\n        # 使用多线程下载图片，调用下载方法\n        t &#x3D; threading.Thread(target&#x3D;download_img, args&#x3D;(src_arr[0], i))\n        t.start()\n        threads.append(t)\n        # download_img(src_arr[0], i)\n\n        i +&#x3D; 1\n        # 等待所有线程完成\n    for t in threads:\n        t.join()\n    print(&quot;当前页所有图片下载完成&quot;)\n\n下载图片def download_img(img_src, i):\n    &quot;&quot;&quot;\n    图片下载\n    :param img_src: 图片的src\n    :param i: 序号\n    :return: void\n    &quot;&quot;&quot;\n    with open(&#39;.&#x2F;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&#39;.format(new_folder, i, img_src.split(&#39;&#x2F;&#39;)[-1]), &#39;wb&#39;) as f:\n        f.write(requests.get(img_src).content)\n    print(i, img_src)\n\n以上就是爬取单页（一页24张图片的方法），观察url可以得知，通过改变page这个参数就可以不断爬取不同页码的图片了。可以有2种不同的思路：\n\n 爬取所有页，从1到total。有多少就爬多少\n 输入指定页码范围，爬取指定多少页\n\n如果是第一种的话，我们还需要获取到total总页码数。因为页码是懒加载的，鼠标滑动到底部才会请求加载下一页，这个时候才能看到总页码。我想到了两种思路：\n\n 直接请求第二页。如果存在的话，就获取到总页码，如果不存在第二页说明这个只有一页，返回1。\n 使用selenium库，控制鼠标滑动页码到底部，加载下一页，然后获取总页码。\n\n我感觉两种方法都差不多，就用简单一点的第一种方法\n获取总页码\ndef get_num(type_index):\n    &quot;&quot;&quot; 获取总页码\n    :param type_index:爬取的类型索引\n    :return:当前的页码数量\n    &quot;&quot;&quot;\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;2&#39;.format(type_list[type_index])\n    selector &#x3D; etree.HTML(requests.get(url, headers&#x3D;headers).text)\n    page_num &#x3D; selector.xpath(&#39;&#x2F;&#x2F;header[@class&#x3D;\\&#39;thumb-listing-page-header\\&#39;]&#x2F;h2&#x2F;&#x2F;text()&#39;)\n    return &#39;&#39;.join(page_num).split(&#39; &#39;)[-1]\n\n爬取指定类型，页码范围or爬取全部页循环起始页到最后页，无非就是在爬取单页的基础上再多一层循环。如果不传入开始页码和最后页码的话，那开始页码就是第一页，总页码就是当前页面最后页码\n\ndef get_total(type_index, start, end):\n    &quot;&quot;&quot;\n    爬取指定类型，页码范围\n    :param type_index:\n    :param start:\n    :param end:\n    :return:\n    &quot;&quot;&quot;\n    # total &#x3D; int(get_num(type_index))\n    if end is None:\n    \tend &#x3D; total\n    if start is None:\n        start &#x3D; 1\n    try:\n        for i in range(start, end):\n            url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], i)\n            print(url, &#39;开始下载第&#123;&#125;&#x2F;&#123;&#125;页&#39;.format(i, end - 1))\n            res &#x3D; requests.get(url, headers&#x3D;headers).text\n            selector &#x3D; etree.HTML(res)\n            img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n            detail_img(img_urls)\n            # threading.Thread(target&#x3D;detail_img, args&#x3D;(img_urls)).start()\n    except Exception as e:\n        print(e)\n\n\n\n这是获取到的图片结果\n\n最后是所有代码import os\nimport threading\n\nimport requests\nfrom lxml import etree\n\n&quot;&quot;&quot;\n爬取网站：https:&#x2F;&#x2F;wallhaven.cc&#x2F;\n&quot;&quot;&quot;\n# 伪装浏览器请求\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36&#39;\n&#125;\n# 存放下载图片的文件夹名称\nnew_folder &#x3D; &#39;img&#39;\n# 5个模块对应的字符串列表\ntype_list &#x3D; [&#39;hot&#39;, &#39;toplist&#39;, &#39;latest&#39;, &#39;random&#39;]\n# 线程池\nthreads &#x3D; []\n\n\n# 单页下载，只下载一页24张图片\ndef get_wall_one_page(type_index: int, page_num) -&gt; None:\n    # page_num爬取的页码\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], page_num)\n    print(url)\n    # 获取当前目录\n    current_dir &#x3D; os.getcwd()\n\n    # 新文件夹的名称\n    # new_folder &#x3D; &#39;img_&#123;&#125;&#39;.format(type_list[type_index])  # 创建新文件夹\n    if not os.path.exists(new_folder):\n        os.mkdir(os.path.join(current_dir, new_folder))\n\n    res &#x3D; requests.get(url, headers&#x3D;headers).text\n    selector &#x3D; etree.HTML(res)\n    img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n    detail_img(img_urls)\n\n\ndef detail_img(img_urls):\n    &quot;&quot;&quot;\n    图片详情\n    :param img_urls:获取到单个图片item的详情url\n    :return:\n    &quot;&quot;&quot;\n    i &#x3D; 0\n\n    for item in img_urls:\n        son_res &#x3D; requests.get(item, headers&#x3D;headers).text\n        selector &#x3D; etree.HTML(son_res)\n        src_arr &#x3D; selector.xpath(&#39;&#x2F;&#x2F;img[@id&#x3D;\\&#39;wallpaper\\&#39;]&#x2F;@src&#39;)\n        # 使用多线程下载图片\n        t &#x3D; threading.Thread(target&#x3D;download_img, args&#x3D;(src_arr[0], i))\n        t.start()\n        threads.append(t)\n        # download_img(src_arr[0], i)\n\n        i +&#x3D; 1\n        # 等待所有线程完成\n    for t in threads:\n        t.join()\n    print(&quot;当前页所有图片下载完成&quot;)\n\n\ndef download_img(img_src, i):\n    &quot;&quot;&quot;\n    图片下载\n    :param img_src: 图片的src\n    :param i: 序号\n    :return: void\n    &quot;&quot;&quot;\n    with open(&#39;.&#x2F;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&#39;.format(new_folder, i, img_src.split(&#39;&#x2F;&#39;)[-1]), &#39;wb&#39;) as f:\n        f.write(requests.get(img_src).content)\n    print(i, img_src)\n\n\ndef get_num(type_index):\n    &quot;&quot;&quot; 获取总页码\n    :param type_index:爬取的类型索引\n    :return:当前的页码数量\n    &quot;&quot;&quot;\n    url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;2&#39;.format(type_list[type_index])\n    selector &#x3D; etree.HTML(requests.get(url, headers&#x3D;headers).text)\n    page_num &#x3D; selector.xpath(&#39;&#x2F;&#x2F;header[@class&#x3D;\\&#39;thumb-listing-page-header\\&#39;]&#x2F;h2&#x2F;&#x2F;text()&#39;)\n    return &#39;&#39;.join(page_num).split(&#39; &#39;)[-1]\n\n\ndef get_total(type_index, start, end):\n    &quot;&quot;&quot;\n    爬取指定类型，页码范围\n    :param type_index:\n    :param start:\n    :param end:\n    :return:\n    &quot;&quot;&quot;\n    # total &#x3D; int(get_num(type_index))\n    if end is None:\n    \tend &#x3D; total\n    if start is None:\n        start &#x3D; 1\n    try:\n        for i in range(start, end):\n            url &#x3D; &#39;https:&#x2F;&#x2F;wallhaven.cc&#x2F;&#123;&#125;?page&#x3D;&#123;&#125;&#39;.format(type_list[type_index], i)\n            print(url, &#39;开始下载第&#123;&#125;&#x2F;&#123;&#125;页&#39;.format(i, end - 1))\n            res &#x3D; requests.get(url, headers&#x3D;headers).text\n            selector &#x3D; etree.HTML(res)\n            img_urls &#x3D; selector.xpath(&#39;&#x2F;&#x2F;a[@class&#x3D;\\&#39;preview\\&#39;]&#x2F;@href&#39;)\n            detail_img(img_urls)\n            # threading.Thread(target&#x3D;detail_img, args&#x3D;(img_urls)).start()\n    except Exception as e:\n        print(e)\n\n\n# https:&#x2F;&#x2F;wallhaven.cc&#x2F;search?q&#x3D;code&amp;page&#x3D;1\n# todo 根据输入关键词，查找下载\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    &quot;&quot;&quot;\n    0:&#39;hot&#39;, 热榜\n    1:&#39;toplist&#39;, top排名\n    2:&#39;latest&#39;, 最新\n    3:&#39;random&#39; 随机\n    4:&#39;search&#39; 关键字查找\n    &quot;&quot;&quot;\n    get_wall_one_page(1,1)  # 爬取单页\n    # get_total(2, 1, 11)  # 爬取多个指定页码\n\n\n上面代码还有优化的空间，还可以加入关键词查询爬取，还有标签爬取，条件爬取等等，欢迎评论不同意见\n想要壁纸的也可以私信我发你！\n\n\n\n喜欢我的小伙伴可以点一波关注。点个赞, 欢迎评论区留言讨论,看到会回复.\n","slug":"python/python多线程爬虫-下载wallhaven超清壁纸","date":"2023-04-12T02:46:35.000Z","categories_index":"python","tags_index":"爬虫","author_index":"前端少年汪"},{"id":"f95adddbe06f4765087659d0718f1490","title":"一遍就能读懂的WebSocket协议详解","content":"什么是WebSocket协议概念用一句话解释一下:\n\n\n\n\n\n\n\n\n\nWebSocket协议是一种基于TCP的网络协议，用于在客户端和服务器之间建立持久连接，实现全双工通信,它允许服务器主动向客户端推送数据，同时也允许客户端向服务器发送数据。\n\nWebSocket协议的特点1.  较低的开销： WebSocket使用更少的头部信息和保持连接的机制，减少了数据传输的开销。\n2.  实时性：WebSocket提供了实时的、双向的通信机制，可以立即将数据从服务器推送到客户端，实现即时更新。\n3.  更好的性能：WebSocket通过减少每次连接的握手次数和数据包的开销，提高了通信的效率和性能。\n4.  跨域支持：WebSocket协议可以跨域使用，允许不同源的客户端与服务器进行通信。\n\nWebSocket和Http协议的异同\n 连接方式不同：HTTP协议采用请求-响应模式，每次请求需要建立一个新的连接；而WebSocket协议通过一次握手后，建立起持久连接，可以实现双向通信。\n 支持的数据类型不同：HTTP协议只能传输文本和二进制数据，而WebSocket协议支持传输任意类型的数据。\n 头部信息不同：HTTP协议的头部信息较多，包含请求方法、请求头等；WebSocket协议的头部信息相对简洁，只包含必要的信息。\n 状态码不同：HTTP协议有大量的状态码，表示服务器处理请求的结果；WebSocket协议仅有几个状态码，主要用于表示连接状态和关闭原因。\n 安全性不同：HTTP协议的通信是明文的，容易被窃听和篡改；WebSocket协议可以使用SSL/TLS协议进行加密，提高了通信的安全性。\n  数据帧格式不同：WebSocket协议的数据帧格式与HTTP协议的数据包格式不同。WebSocket协议的每个数据帧都包含一个头部和数据部分，头部包含标识数据类型、数据长度等信息；而HTTP协议的请求和响应数据包则包含请求行、请求头和请求体等部分。\n 通信方式不同：HTTP协议是一种请求-响应式的协议，客户端发送请求，服务器返回响应；而WebSocket协议是一种全双工通信协议，客户端和服务器可以同时发送和接收数据。\n 适用场景不同：HTTP协议主要用于浏览器与Web服务器之间的通信，常用于请求Web页面、图片、音频、视频等资源；而WebSocket协议主要用于实现实时通信、在线游戏、远程控制等场景。\n 跨域支持不同：在跨域访问方面，HTTP协议需要使用JSONP、CORS等机制来进行跨域操作；而WebSocket协议可以直接跨域使用，不需要额外的跨域处理。\n\nwebsocket是如何和服务端进行连接的\n 客户端发送 HTTP 请求建立连接：客户端通过发送一个 HTTP 请求给服务器来建立 WebSocket 连接。请求头中包含了一些特殊的字段，如 Upgrade 和 Connection 字段，告诉服务器它希望升级到 WebSocket 连接。\n 服务器响应握手请求：服务器收到客户端发送的握手请求后，会进行相应的处理并返回一个 HTTP 响应。响应头中同样包含了一些特殊的字段，如 Upgrade 和 Connection 字段，以及一个 Sec-WebSocket-Accept 字段，用于验证请求的合法性。\n WebSocket 连接建立成功：客户端收到服务器返回的响应后，会验证响应的合法性。如果验证通过，表示 WebSocket 连接已经成功建立。\n 双向通信：一旦 WebSocket 连接建立成功，客户端和服务器就可以通过该连接进行双向通信了。客户端可以发送消息给服务器，服务器也可以发送消息给客户端，实现真正的双向通信。\n 连接关闭：当客户端或服务器决定关闭连接时，可以发送一个特殊的消息，通知对方关闭连接。双方收到关闭消息后，会相应地关闭连接。\n\n需要注意的是，WebSocket 是一种持久化的协议，一旦连接建立成功，它会保持长时间的连接状态，不会像传统的 HTTP 请求那样频繁地建立和关闭连接。这种长连接的特性使得 WebSocket 协议在实时通信场景下具有较好的性能优势。\nWebSocket协议详解构造函数我们可以使用websocket的构造函数来创建一个websocket对象WebSocket() 构造函器会返回一个 [WebSocket] 对象。\nlet ws &#x3D;new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;)\nWebSocket()参数:\n\nurl:要连接的 URL；这应该是 WebSocket 服务器将响应的 URL。\n protocols 可选: 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议（例如，你可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。\n\n\n常量\n\n\nWebSocket.CONNECTING\n0\n\n\n\nWebSocket.OPEN\n1\n\n\nWebSocket.CLOSING\n2\n\n\nWebSocket.CLOSED\n3\n\n\n主要表示websocket生命周期的状态码\n属性点击Websocket的原型展开就可以看到websocket的所有属性和方法了\n\n  [WebSocket.binaryType]  使用二进制的数据类型连接。\n  [WebSocket.bufferedAmount]  只读:未发送至服务器的字节数。\n[WebSocket.extensions]  只读:服务器选择的扩展   \n[WebSocket.onclose] 用于指定连接关闭后的回调函数。\n  [WebSocket.onerror]  用于指定连接失败后的回调函数。\n  [WebSocket.onmessage]  用于指定当从服务器接收到信息时的回调函数。\n  [WebSocket.onopen]  用于指定连接成功后的回调函数。\n  [WebSocket.protocol] 只读:服务器选择的下属协议。\n  [WebSocket.readyState] 只读:当前的链接状态。\n  [WebSocket.url]  只读:WebSocket 的绝对路径。\n\n方法websocket主要有两个方法:\n\nclose:关闭当前链接 WebSocket.close(); \n\n [code] 可选: 一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用 1005。[CloseEvent] 的允许的状态码见状态码列表 。\n[reason] 可选:一个人类可读的字符串，它解释了连接关闭的原因。这个 UTF-8 编码的字符串不能超过 123 个字节。\n\n\nsend: WebSocket.send()  方法将需要通过 WebSocket 链接传输至服务器的数据排入队列，并根据所需要传输的 data bytes 的大小来增加 bufferedAmount的值。若数据无法传输（例如数据需要缓存而缓冲区已满）时，套接字会自行关闭。\n\n参数data:用于传输至服务器的数据。它必须是以下类型之一：\n\n[USVString] :文本字符串。字符串将以 UTF-8 格式添加到缓冲区，并且 bufferedAmount 将加上该字符串以 UTF-8 格式编码时的字节数的值。\n\n[ArrayBuffer]   你可以使用一有类型的数组对象发送底层二进制数据；其二进制数据内存将被缓存于缓冲区，bufferedAmount 将加上所需字节数的值。\n\n  [Blob]   Blob 类型将队列 blob 中的原始数据以二进制中传输。 bufferedAmount 将加上原始数据的字节数的值。\n\n  [ArrayBufferView]  你可以以二进制帧的形式发送任何 JavaScript 类数组对象 其二进制数据内容将被队列于缓冲区中。值 bufferedAmount 将加上必要字节数的值。\n\n\n\n\n\n\n事件如上面所讲,websocket有一些方法在连接的过程中自动触发使用 addEventListener() 或将一个事件监听器赋值给本接口的 oneventname 属性，来监听下面的事件。\n\n  [close] 当一个 WebSocket 连接被关闭时触发。 也可以通过 [onclose]  属性来设置。\n\n  [error] 当一个 WebSocket 连接因错误而关闭时触发，例如无法发送数据时。 也可以通过 [onerror]  属性来设置。\n\n  [message] 当通过 WebSocket 收到数据时触发。 也可以通过 [onmessage] 属性来设置。\n\n  [open] 当一个 WebSocket 连接成功时触发。 也可以通过 [onopen] 属性来设置。\n\n\n如何使用Websocket协议\n创建websocket对象\nlet ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9090&quot;);\n调用open方法\nws.onopen &#x3D; function () &#123;\n    console.log(&quot;链接成功&quot;);\n    \n&#125;;\n调用onmessage,接收数据\nws.onmessage &#x3D; function (data) &#123;\n    console.log(&#39;接受服务端数据&#39;, data)\n        ws.send(&#39;hello world&#39;)\n\n&#125;;\n调用send方法,向服务端发送数据 ws.send(&#39;hello world&#39;)\n\n在断开连接的方法中处理错误或者重连\nws.onclose &#x3D; function (e) &#123;\n    console.log(&#39;连接已经关闭&#39;)\n&#125;\nws.onerror &#x3D; function (e) &#123;\n    console.log(&#39;连接发生错误&#39;)\n&#125;\n\n自己动手封装WebSocket的常用方法功能export default class WebSocketClient &#123;\n    &#x2F;**\n     * 创建一个WebSocket客户端对象。\n     *\n     * @param &#123;string&#125; url - WebSocket服务器的URL。\n     *&#x2F;\n    constructor(url) &#123;\n        this.url &#x3D; url; &#x2F;&#x2F; 保存WebSocket服务器的URL\n        this.websocket &#x3D; null; &#x2F;&#x2F; WebSocket连接对象\n        this.reconnectAttempts &#x3D; 0; &#x2F;&#x2F; 重连尝试次数\n        this.maxReconnectAttempts &#x3D; 10; &#x2F;&#x2F; 最大重连次数\n        this.messageHandlers &#x3D; &#123;&#125;; &#x2F;&#x2F; 消息处理器\n        this.eventHandlers &#x3D; &#123;&#125;; &#x2F;&#x2F; 事件处理器\n        this.timeoutIds &#x3D; &#123;&#125;; &#x2F;&#x2F; 超时定时器ID\n    &#125;\n\n    &#x2F;**\n     * 连接WebSocket服务器。\n     *&#x2F;\n    connect(type, data) &#123;\n        this.websocket &#x3D; new WebSocket(this.url); &#x2F;&#x2F; 创建WebSocket连接\n        this.websocket.binaryType &#x3D; &#39;arraybuffer&#39;; &#x2F;&#x2F; 设置二进制数据类型为ArrayBuffer\n        this.websocket.onopen &#x3D; () &#x3D;&gt; &#123;\n            console.log(&#39;Websocket connection established.&#39;); &#x2F;&#x2F; WebSocket连接建立成功\n            this.reconnectAttempts &#x3D; 0; &#x2F;&#x2F; 重连尝试次数重置\n            this.dispatchEvent(&#39;open&#39;, data); &#x2F;&#x2F; 分发打开事件\n        &#125;;\n        this.websocket.onmessage &#x3D; event &#x3D;&gt; &#123;\n            const message &#x3D; event.data instanceof ArrayBuffer ? event.data : JSON.parse(event.data); &#x2F;&#x2F; 解析收到的消息\n            if (message.id &amp;&amp; this.timeoutIds[message.id]) &#123; &#x2F;&#x2F; 收到响应消息时清除超时定时器\n                clearTimeout(this.timeoutIds[message.id]);\n                delete this.timeoutIds[message.id];\n            &#125;\n            if (message.type &amp;&amp; this.messageHandlers[message.type]) &#123;\n                for (let handler of this.messageHandlers[message.type]) &#123;\n                    handler(message); &#x2F;&#x2F; 处理收到的消息\n                &#125;\n            &#125;\n            this.dispatchEvent(&#39;message&#39;, message); &#x2F;&#x2F; 分发消息事件\n        &#125;;\n        this.websocket.onerror &#x3D; error &#x3D;&gt; &#123;\n            console.error(&#39;Websocket error:&#39;, error); &#x2F;&#x2F; WebSocket错误处理\n            this.dispatchEvent(&#39;error&#39;, error); &#x2F;&#x2F; 分发错误事件\n        &#125;;\n        this.websocket.onclose &#x3D; (type, data) &#x3D;&gt; &#123;\n            console.log(&#39;Websocket connection closed.&#39;); &#x2F;&#x2F; WebSocket连接关闭\n            if (this.reconnectAttempts &lt; this.maxReconnectAttempts) &#123;\n                setTimeout(() &#x3D;&gt; &#123;\n                    this.connect(); &#x2F;&#x2F; 重新连接\n                    this.reconnectAttempts++;\n                &#125;, 2000);\n            &#125; else &#123;\n                console.error(&#96;Websocket connection failed after $&#123;this.maxReconnectAttempts&#125; attempts.&#96;); &#x2F;&#x2F; 达到最大重连次数后仍未成功连接\n                this.dispatchEvent(&#39;close&#39;, data); &#x2F;&#x2F; 分发关闭事件\n            &#125;\n        &#125;;\n    &#125;\n\n    &#x2F;**\n     * 发送一个WebSocket消息。\n     *\n     * @param &#123;object|ArrayBuffer&#125; message - 要发送的消息，可以是JavaScript对象或ArrayBuffer。\n     * @param &#123;number&#125; timeout - 超时时间（毫秒），如果在指定时间内没有收到响应，则调用超时处理函数。\n     * @param &#123;function&#125; timeoutHandler - 超时处理函数，接收一个参数：要发送的消息对象。\n     *&#x2F;\n    send(message, timeout, timeoutHandler) &#123;\n        if (this.websocket.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN) &#123;\n            if (message instanceof ArrayBuffer) &#123;\n                this.websocket.send(message); &#x2F;&#x2F; 发送二进制消息\n            &#125; else &#123;\n                const messageId &#x3D; Math.random().toString(36).substr(2, 8); &#x2F;&#x2F; 生成随机消息ID\n                const messageWithId &#x3D; Object.assign(&#123;&#125;, message, &#123;id: messageId&#125;); &#x2F;&#x2F; 添加消息ID字段\n                const data &#x3D; JSON.stringify(messageWithId); &#x2F;&#x2F; 将消息对象转换为JSON字符串\n                this.websocket.send(data); &#x2F;&#x2F; 发送消息\n                if (timeout) &#123;\n                    this.timeoutIds[messageId] &#x3D; setTimeout(() &#x3D;&gt; &#123;\n                        console.warn(&#96;WebSocket request $&#123;messageId&#125; timed out.&#96;); &#x2F;&#x2F; 超时警告\n                        delete this.timeoutIds[messageId]; &#x2F;&#x2F; 清除超时定时器ID\n                        timeoutHandler &amp;&amp; timeoutHandler(message); &#x2F;&#x2F; 调用超时处理函数\n                    &#125;, timeout);\n                &#125;\n            &#125;\n        &#125; else &#123;\n            console.error(&#39;Websocket connection not open, message not sent:&#39;, message); &#x2F;&#x2F; WebSocket连接未打开时无法发送消息\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 添加一个WebSocket消息处理器。\n     *\n     * @param &#123;string&#125; type - 消息类型。\n     * @param &#123;function&#125; handler - 处理函数，接收一个参数：消息对象或ArrayBuffer。\n     *&#x2F;\n    addMessageHandler(type, handler) &#123;\n        if (!this.messageHandlers[type]) &#123;\n            this.messageHandlers[type] &#x3D; []; &#x2F;&#x2F; 若不存在该类型的消息处理器，则初始化为空数组\n        &#125;\n        this.messageHandlers[type].push(handler); &#x2F;&#x2F; 添加消息处理函数\n    &#125;\n\n    &#x2F;**\n     * 移除一个WebSocket消息处理器。\n     *\n     * @param &#123;string&#125; type - 消息类型。\n     * @param &#123;function&#125; handler - 处理函数。\n     *&#x2F;\n    removeMessageHandler(type, handler) &#123;\n        if (this.messageHandlers[type]) &#123;\n            const index &#x3D; this.messageHandlers[type].indexOf(handler); &#x2F;&#x2F; 查找处理函数在数组中的索引\n            if (index !&#x3D;&#x3D; -1) &#123;\n                this.messageHandlers[type].splice(index, 1); &#x2F;&#x2F; 移除处理函数\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 添加一个WebSocket事件处理器。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;function&#125; handler - 处理函数，接收一个参数：事件数据。\n     *&#x2F;\n    addEventHandler(type, handler) &#123;\n        if (!this.eventHandlers[type]) &#123;\n            this.eventHandlers[type] &#x3D; []; &#x2F;&#x2F; 若不存在该类型的事件处理器，则初始化为空数组\n        &#125;\n        this.eventHandlers[type].push(handler); &#x2F;&#x2F; 添加事件处理函数\n    &#125;\n\n    &#x2F;**\n     * 移除一个WebSocket事件处理器。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;function&#125; handler - 处理函数。\n     *&#x2F;\n    removeEventHandler(type, handler) &#123;\n        if (this.eventHandlers[type]) &#123;\n            const index &#x3D; this.eventHandlers[type].indexOf(handler); &#x2F;&#x2F; 查找处理函数在数组中的索引\n            if (index !&#x3D;&#x3D; -1) &#123;\n                this.eventHandlers[type].splice(index, 1); &#x2F;&#x2F; 移除处理函数\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 分发 WebSocket 事件。\n     *\n     * @param &#123;string&#125; type - 事件类型。\n     * @param &#123;any&#125; data - 事件数据。\n     *&#x2F;\n    dispatchEvent(type, data) &#123;\n        if (this.eventHandlers[type]) &#123;\n            for (let handler of this.eventHandlers[type]) &#123;\n                handler(data); &#x2F;&#x2F; 调用事件处理函数\n            &#125;\n        &#125;\n    &#125;\n    \n&#x2F;**\n * 发送心跳消息。\n *&#x2F;\nsendHeartbeat() &#123;\n    const message &#x3D; &#123; type: &#39;heartbeat&#39; &#125;; &#x2F;&#x2F; 心跳消息内容\n    const intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;\n        this.send(message,5,(e)&#x3D;&gt;&#123;\n            console.log(e)&#125;); &#x2F;&#x2F; 发送心跳消息\n    &#125;, 1000);\n    this.addEventHandler(&#39;close&#39;, () &#x3D;&gt; &#123;\n        clearInterval(intervalId); &#x2F;&#x2F; 关闭 WebSocket 连接时清除定时器\n    &#125;);\n&#125;\n \n&#125;\n \n我封装的是一个基于原生 JavaScript 的 WebSocket 客户端类的实现。这个类提供了一些方法和事件处理器，可以用于连接 WebSocket 服务器、发送消息、处理接收到的消息和处理 WebSocket 相关的事件。\n在这段代码中，WebSocketClient 类有以下主要成员：\n\n  constructor(url)：构造函数，接收 WebSocket 服务器的 URL，并初始化一些属性，如 WebSocket 连接对象、重连尝试次数等。\n  connect(type, data)：连接 WebSocket 服务器的方法，内部创建 WebSocket 连接，并设置连接建立、消息接收、错误和关闭等事件的处理函数。在连接关闭后，会根据重连尝试次数进行重连。\n  send(message, timeout, timeoutHandler)：发送 WebSocket 消息的方法，可以发送 JavaScript 对象或 ArrayBuffer 类型的消息，并支持设置超时时间和超时处理函数。\n  addMessageHandler(type, handler) 和 removeMessageHandler(type, handler)：添加和移除消息处理器的方法，用于处理特定类型的消息。\n  addEventHandler(type, handler) 和 removeEventHandler(type, handler)：添加和移除事件处理器的方法，用于处理特定类型的事件。\n  dispatchEvent(type, data)：分发 WebSocket 事件的方法，用于触发相应类型的事件处理器。\n\n 这个类封装了 WebSocket 的连接、消息发送和事件处理的逻辑，使得使用者可以更方便地操作 WebSocket 连接，并且支持自定义消息处理和事件处理逻辑。\n有哪些好用的客户端WebSocket第三方库\n Socket.io-client：Socket.io 是一个流行的实时通信库，它提供了客户端 JavaScript 库，可用于在浏览器中与 Socket.io 服务器建立 WebSocket 连接。它支持自动重连、事件处理等功能，用于构建实时应用非常方便。\n ReconnectingWebSocket：ReconnectingWebSocket 是一个带有自动重连功能的 WebSocket 客户端库，可以很好地处理网络连接断开和重新连接的情况，适合用于浏览器端的 WebSocket 开发。\n SockJS-client：SockJS 提供了一个浏览器端的 JavaScript 客户端库，用于与 SockJS 服务器建立连接。它可以在不支持 WebSocket 的浏览器上自动降级到其他传输方式，具有良好的兼容性。\n RxJS WebSocketSubject：RxJS 是一个流式编程库，它提供了 WebSocketSubject 类，可以将 WebSocket 转换为可观察对象，方便进行响应式编程。\n autobahn.js：autobahn.js 是一个用于实现 WebSocket 和 WAMP（Web Application Messaging Protocol）的客户端库，在浏览器中可以方便地使用它来与 WAMP 路由进行通信。\n\n这些库都提供了良好的接口封装和功能特性，可以根据项目需求选择适合的库来进行浏览器端的 WebSocket 开发。\n总结WebSocket 协议是一种基于 TCP 的应用层协议，它提供了在客户端和服务器之间进行双向通信的能力。相比传统的 HTTP 协议，它具有更低的延迟和更高的实时性。\nWebSocket 协议通过建立一条持久化的连接来实现双向通信，从而避免了 HTTP 协议中频繁建立和断开连接的过程，减少了网络开销和服务器的负担。客户端可以发送消息给服务器，服务器也可以发送消息给客户端，实现了真正的双向通信。\n在使用 WebSocket 协议时，客户端和服务器会进行一次握手过程，以建立起 WebSocket 连接。握手过程中，客户端会发送一个 HTTP 请求，请求头中包含 Upgrade 和 Connection 字段，告诉服务器它希望升级到 WebSocket 连接。服务器收到请求后会返回一个 HTTP 响应，响应头中包含 Upgrade 和 Connection 字段，以及一个 Sec-WebSocket-Accept 字段，用于验证请求的合法性。握手成功后，客户端和服务器就可以开始使用 WebSocket 协议进行通信了。\nWebSocket 协议支持二进制数据和文本数据的传输，开发者可以根据实际需求进行选择。同时，WebSocket 还提供了心跳机制、自动重连等功能，可以提高连接的稳定性和可靠性。\n总之，WebSocket 协议在实时通信、游戏、在线聊天等场景中得到了广泛应用，它为 Web 应用提供了更加高效、可靠的双向通信方式。\n","slug":"js/一遍就能读懂的WebSocket协议详解","date":"2023-04-04T13:46:35.000Z","categories_index":"网络,TCP/IP,HTTP","tags_index":"网络协议","author_index":"前端少年汪"},{"id":"353ce1343760f6de753e88dbaf24c997","title":"react18新特性","content":"\n前言目前react的最新版本是18.2.0。React 团队在 2022 年 3 月 29 日正式发布了 React 的第 18 个版本 是 React 框架的最新版本，它主要着眼于解决 React 应用在性能、稳定性、开发体验等方面的问题。本文将介绍 React 18 的升级内容、新特性、新的 API、底层逻辑更新等方面的内容，并通过示例展示其使用效果。 我将在这篇文章里简单介绍 React 18 的新特性，React Concurrent Mode（并发模式）的实现，以及简要的升级指南。\n升级\n  react18 已经不支持IE浏览器\n  新项目： 直接用 npm 或者 yarn 安装最新版依赖即可（如果是js，可以不需要安装types类型声明文件）\n  改变根节点的挂载方式使用新的 API createRoot，使用旧的 API 仍然兼容，只有在使用 createRoot 了之后才会有 React 18 的新特性。\n\nReactDOM.createRoot(document.getElementById(&#39;root&#39;)!).render(\n  &lt;React.StrictMode&gt;\n    &lt;Provider store&#x3D;&#123;store&#125;&gt;\n      &lt;App&#x2F;&gt;\n    &lt;&#x2F;Provider&gt;\n  &lt;&#x2F;React.StrictMode&gt;,\n)\n\n在这个示例中，我们使用了 ReactDOM.createRoot 方法创建了一个根节点，并使用 render 方法将组件渲染到根节点中。这样可以让 React 应用更快地响应用户操作，提高用户体验。\nreact18 setState异步同步在 React 18 中，setState 的行为有一些改变，它将更倾向于以异步方式进行更新，但也提供了一些选项来控制同步更新。下面是关于 React 18 中 setState 的异步和同步行为的解释：\n1.  异步更新（默认行为）：在 React 18 中，默认情况下，setState 方法会以异步方式进行更新。这意味着它会将多个状态更新批量处理，并在适当的时机进行合并和应用，以优化性能。这样做可以减少不必要的重渲染，并提高应用程序的响应性。\n\n&#x2F;&#x2F; 异步更新\nthis.setState(&#123; count: this.state.count + 1 &#125;);\n\n2.  同步更新（使用 flushSync）：尽管 setState 默认以异步方式进行更新，但在某些情况下，您可能需要立即获取更新后的状态。为了实现此目的，React 18 提供了 flushSync 方法，可以强制执行同步更新。\n\nimport &#123; flushSync &#125; from &#39;react-dom&#39;;\n\n&#x2F;&#x2F; 同步更新\n\nflushSync(() &#x3D;&gt; &#123;\n\n  this.setState(&#123; count: this.state.count + 1 &#125;);\n\n&#125;);\n\n通过使用 flushSync 包裹 setState 的调用，您可以确保在执行下一个任务之前立即获取到更新后的状态。请注意，使用 flushSync 可能会对性能产生影响，并且应谨慎使用，以避免阻塞主线程。\n需要注意的是，React 18 引入了一种新的异步渲染优先级机制，称为 useTransition。通过使用 useTransition，您可以控制异步更新的优先级。这对于在高优先级工作（例如用户交互）和低优先级工作（例如懒加载数据）之间进行平衡非常有用。然而，它不直接影响 setState 的异步/同步行为，而是影响更新的优先级。\n总结一下，在 React 18 中，setState 通常以异步方式进行更新，并且使用 flushSync 可以实现同步更新。此外，您还可以使用 useTransition 提供的优先级控制来平衡不同任务之间的更新。\nReact18 新增APIReact 18 是 React 的一个重要版本，它包含了一些新的特性和改进，其中一些会对应用程序的开发流程、性能和用户体验产生重要影响。以下是 React 18 中新增的一些 API：\n1.  startTransitionstartTransition 是一个新的 React API，旨在帮助开发者优化应用程序的性能和用户体验。这个函数可以告诉 React 在下次重新渲染组件时，应该延迟更新状态。这样，一些较慢的操作（例如异步请求等）就可以在后台执行，不会影响应用程序的交互性能。\n\nimport &#123; startTransition &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  const [results, setResults] &#x3D; useState([]);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      fetch(&#96;&#x2F;api&#x2F;search?query&#x3D;$&#123;searchTerm&#125;&#96;)\n\n        .then(response &#x3D;&gt; response.json())\n\n        .then(data &#x3D;&gt; setResults(data));\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &lt;ul&gt;\n\n        &#123;results.map(result &#x3D;&gt; (\n\n          &lt;li key&#x3D;&#123;result.id&#125;&gt;&#123;result.title&#125;&lt;&#x2F;li&gt;\n\n        ))&#125;\n\n      &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用 startTransition 函数将异步请求和状态更新操作包裹起来，以告诉 React 在下一次重新渲染之前应该延迟更新状态。\n2.  useTransitionuseTransition 是 startTransition 的 hook 版本。它可以在函数组件中使用，从而让开发者更方便地控制异步操作的状态。\n\nimport &#123; useState, useTransition &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  const [results, setResults] &#x3D; useState([]);\n\n  const [isPending, setIsPending] &#x3D; useState(false);\n\n  const [startTransition, isPendingTransition] &#x3D; useTransition(&#123; timeoutMs: 3000 &#125;);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      setIsPending(true);\n\n      fetch(&#96;&#x2F;api&#x2F;search?query&#x3D;$&#123;searchTerm&#125;&#96;)\n\n        .then(response &#x3D;&gt; response.json())\n\n        .then(data &#x3D;&gt; setResults(data))\n\n        .finally(() &#x3D;&gt; setIsPending(false));\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &#123;isPendingTransition ? &lt;p&gt;Loading...&lt;&#x2F;p&gt; : null&#125;\n\n      &lt;ul&gt;\n\n        &#123;results.map(result &#x3D;&gt; (\n\n          &lt;li key&#x3D;&#123;result.id&#125;&gt;&#123;result.title&#125;&lt;&#x2F;li&gt;\n\n        ))&#125;\n\n      &lt;&#x2F;ul&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用 useTransition hook 来控制异步请求的状态，并在加载数据时显示一个 Loading… 的提示信息。\n3.  createRootcreateRoot 是一个新的入口函数，用于创建根 React 组件。它可以替代原先的 ReactDOM.render 方法，使得开发者可以将多个根节点渲染到一个页面上。\n\nimport &#123; createRoot &#125; from &#39;react-dom&#39;;\n\nfunction App() &#123;\n\n  return (\n\n    &lt;div&gt;Hello, world!&lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n&#x2F;&#x2F; 原先的使用方式\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));\n\n&#x2F;&#x2F; 新的使用方式\n\nconst rootElement &#x3D; document.getElementById(&#39;root&#39;);\n\ncreateRoot(rootElement).render(&lt;App &#x2F;&gt;);\n\n在上述代码中，我们使用 createRoot 函数来创建根 React 组件，并将其渲染到页面上。这样，我们就可以使用多个根节点来构建各种复杂的应用程序界面。\n4.  useDeferredValueuseDeferredValue 是一个新的 hook，可以将某个状态值的更新延迟一段时间后再执行，从而提高应用程序的性能和用户体验。\n\nimport &#123; useState, useDeferredValue &#125; from &#39;react&#39;;\n\nfunction App() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  function handleSearch(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n  &#125;\n\n  const deferredSearchTerm &#x3D; useDeferredValue(searchTerm, &#123;\n\n    timeoutMs: 1000\n\n  &#125;);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleSearch&#125; &#x2F;&gt;\n\n      &lt;p&gt;Search term: &#123;deferredSearchTerm&#125;&lt;&#x2F;p&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用 useDeferredValue hook 将搜索词的更新延迟了一秒钟。这样，用户在快速输入搜索词时，不会因为频繁的重新渲染而出现卡顿等问题。\n5.  useTransition上面已经提到过了，在 React 18 中新增了 useTransition hook，用于帮助开发者控制异步操作的状态。\n6.  useMutableSourceuseMutableSource 是一个新的 hook，用于获取可变数据源，并可以在多个组件之间共享状态。它可以帮助开发者拆分组件逻辑，并使其更加灵活和可复用。\n\nimport &#123; useMutableSource &#125; from &#39;react&#39;;\n\nconst myDataSource &#x3D; &#123;\n\n  get: () &#x3D;&gt; (&#123; count: 0 &#125;),\n\n  subscribe: (handleUpdate) &#x3D;&gt; &#123;\n\n    const intervalId &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      handleUpdate(&#123; count: Math.floor(Math.random() * 100) &#125;);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; clearInterval(intervalId);\n\n  &#125;\n\n&#125;;\n\nfunction Counter() &#123;\n\n  const [dataSource, setDataSource] &#x3D; useState(() &#x3D;&gt; myDataSource);\n\n  const [count, setCount] &#x3D; useState(0);\n\n  function handleUpdate(data) &#123;\n\n    setCount(count &#x3D;&gt; count + data.count);\n\n  &#125;\n\n  useEffect(() &#x3D;&gt; &#123;\n\n    const unsubscribe &#x3D; dataSource.subscribe(handleUpdate);\n\n    return unsubscribe;\n\n  &#125;, [dataSource]);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setDataSource(myDataSource)&#125;&gt;Restart&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\nfunction App() &#123;\n\n  const [dataSource, setDataSource] &#x3D; useState(() &#x3D;&gt; myDataSource);\n\n  const [, forceUpdate] &#x3D; useReducer(x &#x3D;&gt; x + 1, 0);\n\n  function handleRestart() &#123;\n\n    setDataSource(myDataSource);\n\n    forceUpdate();\n\n  &#125;\n\n  const count &#x3D; useMutableSource(dataSource, (&#123; count &#125;) &#x3D;&gt; count);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;handleRestart&#125;&gt;Restart&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用 myDataSource 作为可变数据源，并将其共享到多个组件中。在 Counter 组件中，我们订阅了数据源的更新，并实时反映出计数器的变化。在 App 组件中，我们使用了 useMutableSource hook 来获取数据源的值，从而实现了多组件之间的状态共享。\n总而言之，React 18 中引入了许多有用的新特性和 API，包括 startTransition、useTransition、createRoot、useDeferredValue、useMutableSource 等。这些新特性和 API 可以让开发者更方便地构建高性能、灵活和可复用的 React 应用程序。\n新增HooksReact 18 引入了一些新的 hooks，以帮助开发者更好地管理状态和副作用。以下是 React 18 中新增的一些 hooks：\n1.  useTransitionuseTransition 允许开发者在处理潜在的延迟操作时控制异步更新的优先级。它接受一个配置对象，可以设置超时时间和中断标志等选项。\n\nimport &#123; useTransition &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n\n  const [isPending, startTransition] &#x3D; useTransition(&#123; timeoutMs: 2000 &#125;);\n\n  function handleClick() &#123;\n\n    startTransition(() &#x3D;&gt; &#123;\n\n      &#x2F;&#x2F; 执行某个需要较长时间的操作\n\n    &#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;button onClick&#x3D;&#123;handleClick&#125;&gt;开始操作&lt;&#x2F;button&gt;\n\n      &#123;isPending &amp;&amp; &lt;p&gt;操作进行中...&lt;&#x2F;p&gt;&#125;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用了 useTransition hook 来控制长时间操作的优先级，并在操作进行中显示一个提示信息。\n2.  useDeferredValueuseDeferredValue 允许开发者将某个状态的更新推迟到未来的帧中。这对于处理与用户输入相关的操作非常有用，可以避免在频繁输入时产生连续的重渲染。\n\nimport &#123; useState, useDeferredValue &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n\n  const [searchTerm, setSearchTerm] &#x3D; useState(&#39;&#39;);\n\n  function handleChange(event) &#123;\n\n    setSearchTerm(event.target.value);\n\n  &#125;\n\n  const deferredSearchTerm &#x3D; useDeferredValue(searchTerm, &#123;\n\n    timeoutMs: 500\n\n  &#125;);\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;searchTerm&#125; onChange&#x3D;&#123;handleChange&#125; &#x2F;&gt;\n\n      &lt;p&gt;搜索词: &#123;deferredSearchTerm&#125;&lt;&#x2F;p&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用了 useDeferredValue hook 来将搜索词的更新推迟了 500ms。这样，在频繁输入时，只有用户停止输入一段时间后，才会执行搜索操作。\n3.  useMutableSourceuseMutableSource 允许开发者访问可变的数据源，并在多个组件之间共享状态。这对于高性能的数据订阅和共享非常有用。\n\nimport &#123; useMutableSource &#125; from &#39;react&#39;;\n\nconst myDataSource &#x3D; &#123;\n\n  get: () &#x3D;&gt; (&#123; count: 0 &#125;),\n\n  subscribe: (callback) &#x3D;&gt; &#123;\n\n    const interval &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      callback(&#123; count: Math.floor(Math.random() * 100) &#125;);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; clearInterval(interval);\n\n  &#125;\n\n&#125;;\n\nfunction MyComponent() &#123;\n\n  const [, forceUpdate] &#x3D; useState(&#123;&#125;);\n\n  const count &#x3D; useMutableSource(myDataSource, source &#x3D;&gt; source.get());\n\n  function handleRestart() &#123;\n\n    forceUpdate(&#123;&#125;);\n\n  &#125;\n\n  return (\n\n    &lt;div&gt;\n\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;button onClick&#x3D;&#123;handleRestart&#125;&gt;重启&lt;&#x2F;button&gt;\n\n    &lt;&#x2F;div&gt;\n\n  );\n\n&#125;\n\n在上述代码中，我们使用了 useMutableSource hook 来获取可变数据源中的值，并在计数器组件中共享该状态。\n这些是 React 18 中新增的一些重要 hooks。通过使用这些 hooks，开发者可以更好地管理状态、处理潜在的延迟操作，并实现高性能的数据共享。除了这些新增的 hooks，React 18 也支持其他常用的 hooks，如 useState、useEffect、useCallback 等。\n严格模式React 严格模式（Strict Mode）是一个开发模式，可以帮助开发者发现一些潜在的问题，以提高应用程序的质量。启用严格模式后，React 会执行额外的检查和警告，以帮助开发者发现一些常见问题，并尽早地解决它们。\n启用 React 严格模式可以通过在代码中添加如下代码实现：\n\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nReactDOM.render(\n\n  &lt;React.StrictMode&gt;\n\n    &lt;App &#x2F;&gt;\n\n  &lt;&#x2F;React.StrictMode&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);\n\n在上述代码中，我们使用 React.StrictMode 组件来包裹应用程序的顶层组件 &lt;App&gt;。这样，React 将会在严格模式下执行应用程序，并对常见问题进行检查和提示。\nReact 严格模式主要包含以下几个方面的检查和提示：\n\n  识别不安全的生命周期方法，提示开发者修改，这些方法可能会导致意外的副作用或错误。\n  检测意外的副作用，例如：多余的重新渲染、不符合预期的函数调用等。\n  检测某些过时的 API 使用，提供更好的替代方案。\n  检测警告信息，使其更加明显和易于发现。\n\n需要注意的是，React 严格模式只在开发环境下工作，不会影响生产环境下的应用程序。因此，在开发过程中启用严格模式可以帮助开发者及早发现问题，并尽可能将这些问题解决，以提高应用程序的稳定性和质量。\n总而言之，React 严格模式是一种非常有用的开发模式，可以帮助开发者发现常见问题并提高应用程序的质量。通过在顶层组件中添加 &lt;React.StrictMode&gt; 包裹，我们可以启用严格模式，并享受其带来的好处。\n如何禁用严格模式在 React 应用中禁用严格模式可以通过以下两种方式实现：\n1.  直接移除 &lt;React.StrictMode&gt; 组件最简单的方法是将应用程序顶层组件中的 &lt;React.StrictMode&gt; 组件直接移除。这样，React 将不会启用严格模式，也不会执行额外的检查和警告。\n\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nimport App from &#39;.&#x2F;App&#39;;\n\nReactDOM.render(\n\n  &lt;App &#x2F;&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);\n\n2.  在应用程序启动时禁用严格模式在一些情况下，移除 &lt;React.StrictMode&gt; 组件可能不太方便，例如：在大型项目中或已经存在大量的 console.log 调用等代码片段。此时，可以在应用程序启动时禁用严格模式。\n在应用程序启动文件中，我们可以使用 React 的 unstable_disableDevMode() 函数来禁用严格模式：\n\nimport React from &#39;react&#39;;\n\nimport ReactDOM from &#39;react-dom&#39;;\n\nimport App from &#39;.&#x2F;App&#39;;\n\nReact.unstable_disableDevMode();\n\nReactDOM.render(\n\n  &lt;React.StrictMode&gt;\n\n    &lt;App &#x2F;&gt;\n\n  &lt;&#x2F;React.StrictMode&gt;,\n\n  document.getElementById(&#39;root&#39;)\n\n);\n\n在上述代码中，我们在调用 ReactDOM.render 之前调用了 React.unstable_disableDevMode() 函数，以禁用严格模式。该函数并不在文档中明确提供支持，因此请谨慎使用。\n需要注意的是，禁用严格模式可能会导致一些潜在问题无法被及早发现，因此建议仅在必要时使用。同时，需要确保 React 版本兼容性，并遵循最佳实践和安全规则。\n并发模式React 并发模式（React Concurrent Mode）是 React 的一项新功能，旨在改善在复杂应用程序中的用户体验和性能。在传统的 React 中，更新组件树时会阻塞用户界面的响应，可能导致卡顿和延迟。而并发模式通过将任务分解为多个小步骤，让 React 在执行渲染和布局时可以中断和恢复任务，从而提供更平滑和响应式的用户体验。\n在 React 并发模式中，引入了两个主要概念：任务调度和优先级。任务调度器负责决定哪些任务执行、何时执行以及中断和恢复任务。优先级允许 React 根据任务的紧迫性来安排任务的执行顺序，确保响应度更高的任务能够优先执行。\n利用并发模式，React 可以将渲染过程分解为多个小任务，并根据优先级来动态调整任务执行的顺序。这样，在浏览器空闲时间或网络请求等异步操作期间，React 可以暂停当前任务，执行其他具有更高优先级的任务，以实现更爽快的用户交互体验。\n总而言之，React 并发模式通过任务调度和优先级机制，提供了更好的用户体验和性能，使得 React 应用程序能够更加平滑地响应用户操作。\n以下是一个简单的示例代码，展示了 React Concurrent Mode 的基本用法：\nimport React, &#123; useState, useEffect, unstable_ConcurrentMode as ConcurrentMode &#125; from &#39;react&#39;;\n\n\nfunction App() &#123;\n\n  const [count, setCount] &#x3D; useState(0);\n\n  useEffect(() &#x3D;&gt; &#123;\n\n    const timer &#x3D; setInterval(() &#x3D;&gt; &#123;\n\n      setCount((prevCount) &#x3D;&gt; prevCount + 1);\n\n    &#125;, 1000);\n\n    return () &#x3D;&gt; &#123;\n\n      clearInterval(timer);\n\n    &#125;;\n\n  &#125;, []);\n\n  return (\n\n    &lt;ConcurrentMode&gt;\n\n      &lt;div&gt;\n\n        &lt;h1&gt;计数器&lt;&#x2F;h1&gt;\n\n        &lt;p&gt;&#123;count&#125;&lt;&#x2F;p&gt;\n\n      &lt;&#x2F;div&gt;\n\n    &lt;&#x2F;ConcurrentMode&gt;\n\n  );\n\n&#125;\n\nexport default App;\n\n在上面的示例中，我们使用了 unstable_ConcurrentMode 组件来包裹根元素。这表示该组件下的子组件可以享受到并发模式的好处。\n在 App 组件中，我们使用了 useState 来声明一个状态变量 count，并通过 setCount 来更新它的值。在 useEffect 中，我们使用定时器每秒钟增加 count 的值。注意，我们传递了空数组作为第二个参数，表示只在组件挂载时执行一次。\n最后，在组件的返回值中，我们使用 &lt;ConcurrentMode&gt; 组件包裹了整个应用程序的 UI。这样，React 将会利用并发模式来处理渲染任务，以提供更平滑和响应式的用户体验。\n服务端渲染React 18 并没有专门针对服务端渲染（SSR）进行大规模的改进，但它仍然提供了一些与 SSR 相关的 API 和改进。以下是一些我们在 React 18 中可以使用的 SSR 相关功能：\n1.  useOpaqueIdentifieruseOpaqueIdentifier 允许开发者生成与数据不相关的、不透明的标识符，并在 SSR 上使用这些标识符来生成唯一的 DOM ID。\nimport &#123; useOpaqueIdentifier &#125; from &#39;react&#39;;\n\nfunction MyComponent() &#123;\n  const id &#x3D; useOpaqueIdentifier();\n\n  return &lt;div id&#x3D;&#123;&#96;my-component-$&#123;id&#125;&#96;&#125;&gt;My component&lt;&#x2F;div&gt;;\n&#125;\n\n在上述代码中，我们使用了 useOpaqueIdentifier hook 来生成一个不透明的标识符，并将其用于组件的 DOM ID 中。由于这个标识符与数据无关，因此在 SSR 上也可以正确地生成唯一的 ID。\n2.  ReactDOMServer.renderToStringAsync  ReactDOMServer.renderToStringAsync 允许开发者异步地渲染组件并输出 HTML。这样可以避免在 SSR 期间阻塞主线程，在数据加载和计算时保持响应性。\nimport ReactDOMServer from &#39;react-dom&#x2F;server&#39;;\n\nasync function renderApp(req, res) &#123;\n  const app &#x3D; &lt;MyApp &#x2F;&gt;;\n  const html &#x3D; await ReactDOMServer.renderToStringAsync(app);\n  res.send(html);\n&#125;\n\n在上述代码中，我们使用了 ReactDOMServer.renderToStringAsync 方法异步地将 &lt;MyApp /&gt; 组件渲染为 HTML，并在 Express 中将其发送到客户端。\n3.  Concurrent Mode   Concurrent Mode 是 React 18 中引入的一个新特性，它通过异步渲染和交互优先级控制等方式提升了应用程序的响应性。在 SSR 中，Concurrent Mode 可以帮助开发者更好地处理异步数据加载和渲染等任务。\nimport &#123; unstable_createRoot &#125; from &#39;react-dom&#39;;\n\nasync function renderApp(req, res) &#123;\n  const app &#x3D; &lt;MyApp &#x2F;&gt;;\n  const root &#x3D; unstable_createRoot(document.createDocumentFragment());\n  await new Promise(resolve &#x3D;&gt; setTimeout(resolve, 1000)); &#x2F;&#x2F; 模拟数据加载延迟\n  root.render(app);\n  const html &#x3D; ReactDOMServer.renderToString(root);\n  res.send(html);\n&#125;\n\n在上述代码中，我们使用了 unstable_createRoot 方法来创建一个 Concurrent Mode 的根节点。在数据加载完成后，我们渲染了应用程序，并将其输出为 HTML。\n这些是 React 18 中与 SSR 相关的一些功能和改进。通过使用这些功能，开发者可以更好地处理异步数据加载和渲染，并提升应用程序的响应性。\n","slug":"react/听说你还不知道React18新特性？看我给你整明白！","date":"2023-03-17T02:46:35.000Z","categories_index":"reacr","tags_index":"react","author_index":"前端少年汪"},{"id":"b71e680387a5f2c0fe8c8eb63677ef1b","title":"VUE生命周期详解","content":"VUE生命周期\n\n\n\n\n\n\n\n\n大家好我是迁客，一个初入行的小白！痴迷技术，对programming有着极大的兴趣和爱好。每周写一篇自己个人成长的技术博客！既是对自己的一个学习技术的一个记录，也是督促自己，坚持下去！加油Fighting！==从明天起，做一个新思维的人继承，多态，层层封装从明天起,不再关心内存管理让每一条数据，自动放到合适的位子上从明天起，我将为每一个对象取一个温暖的名字它们用驼峰命名，优雅，大方陌生人，我也祝福你哈愿你不再为系统级bug烦恼愿你在平台之间肆意游荡愿你不再关心溢出与异常==\n\nVUE的生命周期大致分为8个阶段：\n\n1.beforeCreate(创建前):在数据观测和初始化事件还未开始\nbeforeCreate: function () &#123;\n            console.group(&#39;------beforeCreate创建前状态------&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el); &#x2F;&#x2F;undefined\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data); &#x2F;&#x2F;undefined\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message)\n        &#125;\n\n\n2.created(创建后):完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来\ncreated: function () &#123;\n            console.group(&#39;------created创建完毕状态------&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el); &#x2F;&#x2F;undefined\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data); &#x2F;&#x2F;已被初始化\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); &#x2F;&#x2F;已被初始化\n        &#125;\n3.beforeMount(载入前):        在挂载开始之前被调用，相关的render函数首次被调用。        实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。\nbeforeMount: function () &#123;\n            console.group(&#39;------beforeMount挂载前状态------&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + (this.$el)); &#x2F;&#x2F;已被初始化\n            console.log(this.$el);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot;, this.$data); &#x2F;&#x2F;已被初始化\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot;, this.message); &#x2F;&#x2F;已被初始化\n        &#125;,\n\n\n​4.mounted（载入后）:​        在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。​        实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。\nmounted: function () &#123;\n           console.group(&#39;------mounted 挂载结束状态------&#39;);\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el); &#x2F;&#x2F;已被初始化\n           console.log(this.$el);\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data); &#x2F;&#x2F;已被初始化\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message); &#x2F;&#x2F;已被初始化\n       &#125;,\n 5.beforeUpdate（更新前）:     在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。\nbeforeUpdate: function () &#123;\n    \n            console.group(&#39;beforeUpdate 更新前状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el);\n            console.log(this.$el);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message);\n        &#125;,\n 6.updated（更新后）:     在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。     调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。     该钩子在服务器端渲染期间不被调用。\nupdated: function () &#123;\n            console.group(&#39;updated 更新完成状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el);\n            console.log(this.$el);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message);\n        &#125;,\n\n 7.beforeDestroy（销毁前）:在实例销毁之前调用。实例仍然完全可用。 beforeDestroy: function () &#123;\n           console.group(&#39;beforeDestroy 销毁前状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》&#39;);\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el);\n           console.log(this.$el);\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data);\n           console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message);\n       &#125;, 8.destroyed（销毁后）:        在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。\ndestroyed: function () &#123;\n            console.group(&#39;destroyed 销毁完成状态&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&gt;&#39;);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;el     : &quot; + this.$el);\n            console.log(this.$el);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;data   : &quot; + this.$data);\n            console.log(&quot;%c%s&quot;, &quot;color:red&quot;, &quot;message: &quot; + this.message)\n        &#125;\n\n==好了，最后有什么不足和错误的地方欢迎大家在评论区指出，希望大家对大家有所帮助，谢谢==\n","slug":"vue/vue生命周期详解","date":"2023-03-15T02:46:35.000Z","categories_index":"vue","tags_index":"vue","author_index":"前端少年汪"},{"id":"76203a7a58be01e7fd00254c86e3c923","title":"VUE3新特性","content":"\n\n\n\n\n\n\n\n\n\n想起来上次好好认真学vue，还是刚实习那会儿，如今回头看，已是三年有余了。vue从当初的vue2也大升级到vue3了。新的 API，新的语法糖，新的响应式…如今，我已不是以前那个小白了，对vue和js的使用也越来越熟练了，打算在好好系统的复习一下vue3的新特性。\nvue2和vue3有哪些区别？首先说明一下，vue2和vue3是Vue.js的两个主要版本。目前vue3已经更新到3.3.4的版本了\n\nvue3是vue2的一个重大升级，当然vue2的版本也在更新，目前已经更新到2.7.14的版本\n还有一个消息就是：   \n\n  Vue 2 将于 2023 年 12 月 31 日停止维护。详见 Vue 2 延长 LTS。\n  Vue 2 中文文档已迁移至 v2.cn.vuejs.org。\n  想从 Vue 2 升级？请参考迁移指南。\n\n\n我个人觉得vue2和vue3的区别主要有以下几个方面：\n\n 性能优化：Vue 3 在底层进行了重写，采用了更先进的编译器和运行时优化，提供了更好的性能表现。Vue 3 的虚拟 DOM 重构、组件渲染优化以及更新机制的改进等方面都使得应用程序的性能更高效。\n 组合式 API：Vue 3 引入了组合式 API，这是一种新的组件组织方式，可以更灵活地复用和组合逻辑。与 Vue 2 中的 Options API 不同，组合式 API 基于函数，可以更清晰地分离关注点，并提供了更好的 TypeScript 支持。\n Composition API：Vue 3 中的 Composition API 可以让开发者根据功能组织代码，而不是按照选项对象的方式。它可以更好地处理组件中的逻辑复用、代码组织和代码重用。\n 更小的包体积：由于底层的重构和模块的重组，Vue 3 的包体积更小，以及更好的树摇（Tree Shaking）支持，可以减少最终打包文件的大小。\n TypeScript 内建支持：Vue 3 对于 TypeScript 的支持更加友好，包括改进的类型推断、更好的声明文件支持和针对 Composition API 的类型推导。\n 更好的响应式系统：Vue 2 的响应式系统通过 Object.defineProperty() 实现了数据的劫持，而Vue 3 中的响应式系统使用Proxy对象进行了重写，提供了更好的性能和更全面的响应式处理方式。Vue 3 使用了 Proxy 代理对象来实现响应式数据的追踪和触发，相比 Vue 2 的 Object.defineProperty，提供了更多的功能和更好的性能。\n Vu3支持自定义hooks。Vue 3 中引入的 Composition API 与 React 中的 Hooks 概念类似，提供了一组新的函数式 API，用于更灵活、清晰地组织和复用组件逻辑。\n\n\n\n\n\n\n\n\n其中常用的 hooks 基本等同于 React 中的对应 hook：\n\n  setup：在组件创建之前执行，并返回一个响应式对象和一些函数，是使用 Composition API 的入口。\n  ref：用于创建一个响应式数据，可以通过 .value 属性进行读写。类似于 Vue 2.x 中的 data。\n  reactive：创建一个响应式对象，可以通过属性访问器（getter 和 setter）实现数据绑定。类似于 Vue 2.x 中的 data。\n  computed：创建一个计算属性，它的值会根据其依赖的 ref 或 reactive 对象自动更新。\n  watch：监听一个响应式数据或计算属性，当它的值发生变化时触发回调函数。\n  onMounted：当前组件挂载到 DOM 上后执行的回调函数。\n  onUnmounted：当前组件从 DOM 上卸载后执行的回调函数。\n  onUpdated：当前组件更新后执行的回调函数。\n  watchEffect：监听响应式数据的变化，在回调函数中处理相关逻辑。\n\n这些 hooks 使得我们可以更方便地组织组件逻辑，将关注点分离，提高代码的可复用性和可维护性。比如，我们可以将某个组件逻辑抽离成一个自定义 hook，然后在多个组件中进行复用。总之，Vue 3 中的 hooks 实现了类似 React 中的 hook 模式，使得组件逻辑更加清晰，能够更加灵活地共享和组合逻辑，并且提供了更好的 TypeScript 支持。\n\n\nvue3有哪些新的APIvue3新的API还是比较多的，主要包括组合式API，选项式API，全局API，内置指令，组件，属性，进阶API，SFC单文件组件等等…\n组合式API组合式API是vue3区别于vue2最明显的不一样的地方。其中有几个比较常用的API，比如\n\n setup()\n ref()\n reactive()\n watchEffect()\n computed()\n\n还有生命周期钩子，和vue2也是稍有区别。没有了 BeforeCreate和created，在方法名前面都加了个on.猜的不错的话，相信大家用的最多的肯定是onMounted()这个钩子吧，一般网络请求都放在这个里面去执行。\n\n\n\n\n\n\n\n\n\n生命周期钩子\n  onMounted()\n  onUpdated()\n  onUnmounted()\n  onBeforeMount()\n  onBeforeUpdate()\n  onBeforeUnmount()\n  onErrorCaptured()\n  onRenderTracked()\n  onRenderTriggered()\n  onActivated()\n  onDeactivated()\n  onServerPrefetch()\n\n全局API全局API里面也有几个是需要注意的，也是经常用到的。\n\ncreateApp() \napp.mount()\napp.use()\napp.provide()\napp.config\nnextTick()\napp.config.globalProperties\n\n这几个API是Vue.js 3.x中一些常用的核心方法和属性，它们的作用如下：\n\ncreateApp():\n\ncreateApp()是一个工厂函数，用于创建一个Vue应用程序实例。在Vue.js 3.x中，使用createApp()来代替之前版本中的Vue构造函数，可以用更简单的方式创建Vue实例。createApp()需要传入一个根组件对象和一个配置选项对象，可以配置应用程序的各种属性和行为。\n例如，可以通过createApp()创建一个Vue实例，并指定根组件为App，如下所示：\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\n\nconst app &#x3D; createApp(App)\n\napp.mount(&#39;#app&#39;)\n\n\napp.mount():\n\napp.mount()方法用于将Vue实例挂载到一个DOM元素上，使得Vue可以控制这个DOM元素内的所有内容。\n例如，在上面的示例代码中，我们调用了app.mount()方法，将Vue实例挂载到了id为”app”的DOM元素上，如下所示：\napp.mount(&#39;#app&#39;)\n\n\napp.use():\n\napp.use()方法用于注册Vue插件，可以在Vue应用程序中添加一些全局功能和附加的特性。插件通常以函数或对象的形式提供，用于扩展或修改Vue的核心功能。\n例如，可以使用app.use()方法注册Vue-Router插件，如下所示：\nimport &#123; createApp &#125; from &#39;vue&#39;\nimport &#123; createRouter, createWebHistory &#125; from &#39;vue-router&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport routes from &#39;.&#x2F;routes&#39;\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHistory(),\n  routes,\n&#125;)\n\nconst app &#x3D; createApp(App)\n\napp.use(router)\n\napp.mount(&#39;#app&#39;)\n\n通过调用app.use()方法，将Vue-Router插件注册到Vue应用程序中，从而实现路由功能。\n\napp.provide():\n\napp.provide()方法用于定义一个全局的依赖注入，提供了一种在组件层次结构中共享数据和函数的方式。provide()方法需要传入一个键值对对象，用于指定要注入的变量和其对应的值。\n例如，可以使用app.provide()方法将一个名为”theme”的字符串注入到Vue应用程序中，如下所示：\nconst app &#x3D; createApp(App)\n\napp.provide(&#39;theme&#39;, &#39;dark&#39;)\n\napp.mount(&#39;#app&#39;)\n\n在上面的示例代码中，我们使用app.provide()方法将”theme”字符串注入到Vue应用程序中，并设置为”dark”。接着，我们就可以在任何子组件中通过inject()方法来访问这个变量。\n\napp.config:\n\napp.config是一个全局的配置对象，可以用于配置Vue应用程序中的各种选项和行为。该对象包含很多属性，例如productionTip、globalProperties、isNativeTag等，可以根据应用程序的需求进行相应的配置。\n例如，在Vue.js 3.x中，我们可以使用app.config.productionTip来设置控制台日志输出的环境，如下所示：\nconst app &#x3D; createApp(App)\n\napp.config.productionTip &#x3D; false\n\napp.mount(&#39;#app&#39;)\n\n在上面的示例代码中，我们禁用了控制台日志输出，以提高Vue应用程序的性能和安全性。\n\nnextTick():nextTick()是Vue.js提供的一个异步方法。它允许你在下次 DOM 更新循环结束之后执行一段代码，以确保操作发生在更新完成后。在许多情况下，当你修改了数据之后，想要立即去访问更新后的 DOM 结构，可能会出现问题，因为 Vue 异步执行 DOM 更新。使用nextTick()可以将回调函数推迟到下一个 DOM 更新周期中执行，这样可以确保在操作数据后，DOM已经更新完毕。\n\n例如，当我们需要在更新后获取某个元素的宽度时，需要使用nextTick()来确保在DOM更新完成后再进行获取操作。示例代码如下：\napp.config.globalProperties.$nextTick(() &#x3D;&gt; &#123;\n  const width &#x3D; document.querySelector(&#39;.element&#39;).offsetWidth;\n  console.log(width);\n&#125;);\n\n\napp.config.globalProperties:app.config.globalProperties是Vue应用程序的全局属性配置对象。通过设置该对象的属性，可以将这些属性添加到每个组件实例中，从而在所有组件中共享和访问这些属性。\n\n例如，我们可以将一个自定义的全局方法添加到Vue应用程序中的所有组件中。示例代码如下：\napp.config.globalProperties.$customMethod &#x3D; (arg) &#x3D;&gt; &#123;\n  &#x2F;&#x2F; 这里是自定义的方法逻辑\n&#125;\n\n通过在app.config.globalProperties上定义$customMethod，我们可以在任何组件内部直接调用$customMethod()方法，而无需进行额外的导入和注册。\nexport default &#123;\n  methods: &#123;\n    handleClick() &#123;\n      this.$customMethod(&#39;Hello World&#39;);\n    &#125;\n  &#125;\n&#125;\n\n在上述示例中，我们可以在组件的方法中直接调用$customMethod()方法并传入参数。这样就实现了将自定义方法添加到全局的目的，以便在任何组件中共享和使用。\nvue3的响应式系统Vue3响应式实现是通过ES6中的proxy代理对象，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。这样在改写对象时就能触发响应式。同样通过递归解决对象嵌套问题。\nVue 3 的响应式系统相比于 Vue 2 发生了一些变化，介绍一下 Vue 3 的响应式系统。有几个主要的API和工具函数。\n\n\n\n\n\n\n\n\n\n响应式: 核心\n  ref()\n  computed()\n  reactive()\n  readonly()\n  watchEffect()\n  watchPostEffect()\n  watchSyncEffect()\n  watch()\n\n\nreactive / readonly 函数\n\nVue 3 中的响应式系统使用 reactive 和 readonly 函数来创建响应式对象。相较于 Vue 2 中使用的 Vue.observable，新的 API 更加清晰、易懂。\nreactive 函数接受一个普通的 JavaScript 对象作为参数，返回一个响应式代理对象。这个代理对象可以监控被代理对象所有的属性的变化，包括嵌套对象和数组。\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nconst obj &#x3D; reactive(&#123;\n  count: 0,\n  message: &#39;Hello World&#39;,\n  nested: &#123;\n    foo: &#39;bar&#39;\n  &#125;,\n  arr: [1, 2, 3]\n&#125;)\n\n&#x2F;&#x2F; 访问代理对象的属性\nconsole.log(obj.count) &#x2F;&#x2F; 0\n\n&#x2F;&#x2F; 修改代理对象的属性\nobj.count++\n\n&#x2F;&#x2F; 修改代理对象的嵌套属性和数组\nobj.nested.foo &#x3D; &#39;baz&#39;\nobj.arr.push(4)\n\nreadonly 与 reactive 的用法类似，不同之处在于它返回的是一个只读的响应式代理对象，无法修改代理对象的属性。\n\nref 函数\n\nVue 3 中的 ref 函数用来包装基本类型的值，使其变成响应式的。ref 返回一个包含该值的引用对象，该引用对象有一个 value 属性，访问或修改该属性会触发依赖更新。\nimport &#123; ref &#125; from &#39;vue&#39;\n\nconst count &#x3D; ref(0)\nconsole.log(count.value) &#x2F;&#x2F; 0\n\ncount.value++\n\n\ncomputed 函数\n\nVue 3 中的 computed 函数用来创建计算属性。与 Vue 2 中的 computed 类似，但是在使用时需要在 computed 函数内部返回计算结果。\nimport &#123; computed, reactive &#125; from &#39;vue&#39;\n\nconst state &#x3D; reactive(&#123;\n  message: &#39;Hello&#39;,\n  name: &#39;World&#39;\n&#125;)\n\nconst fullName &#x3D; computed(() &#x3D;&gt; &#123;\n  return &#96;$&#123;state.message&#125; $&#123;state.name&#125;&#96;\n&#125;)\n\nconsole.log(fullName.value) &#x2F;&#x2F; &#39;Hello World&#39;\n\n&#x2F;&#x2F; 修改响应式对象中的属性\nstate.name &#x3D; &#39;Vue 3&#39;\nconsole.log(fullName.value) &#x2F;&#x2F; &#39;Hello Vue 3&#39;\n\n\nwatch / watchEffect 函数\n\nVue 3 中的 watch 和 watchEffect 函数用来监视响应式对象的变化，当被监视的对象发生变化时，会触发回调函数执行。\nwatch 函数用来监视特定的响应式属性，当该属性的值发生变化时才会触发回调函数执行。\nimport &#123; watch, reactive &#125; from &#39;vue&#39;\n\nconst state &#x3D; reactive(&#123;\n  count: 0,\n  message: &#39;Hello World&#39;\n&#125;)\n\nwatch(\n  () &#x3D;&gt; state.count,\n  (newValue, oldValue) &#x3D;&gt; &#123;\n    console.log(&#96;count changed from $&#123;oldValue&#125; to $&#123;newValue&#125;&#96;)\n  &#125;\n)\n\nstate.count++ &#x2F;&#x2F; count changed from 0 to 1\n\nwatchEffect 函数用来监视响应式对象中的任何属性，当该对象的任何属性发生变化时都会触发回调函数执行。\nimport &#123; watchEffect, reactive &#125; from &#39;vue&#39;\n\nconst state &#x3D; reactive(&#123;\n  count: 0,\n  message: &#39;Hello World&#39;\n&#125;)\n\nwatchEffect(() &#x3D;&gt; &#123;\n  console.log(&#96;state changed: $&#123;state.count&#125;, $&#123;state.message&#125;&#96;)\n&#125;)\n\nstate.count++ &#x2F;&#x2F; state changed: 1, Hello World\nstate.message &#x3D; &#39;Vue 3&#39; &#x2F;&#x2F; state changed: 1, Vue 3\n\n以上是 Vue 3 中响应式系统的一些基础使用方法。与 Vue 2 相比，Vue 3 的响应式系统更加简洁、易懂，同时在性能和体积方面也得到了优化。\nsetup语法糖到底是什么 起初 Vue3.0 暴露变量必须 return 出来，template中才能使用； 这样会导致在页面上变量会出现很多次。 很不友好，vue3.2只需在script标签中添加setup。 可以帮助我们解决这个问题。\n\n\n\n\n\n\n\n\n\n1.组件只需引入不用注册，属性和方法也不用返回2.也不用写setup函数，也不用写export default3.自定义指令也可以在我们的template中自动获得。4.子组件使用defineProps接受父组件参数5.子组件defineEmits自定义事件，父组件调用6.将子组件中的属性defineExpose(）暴露出去，这样父组件可以获取 \n新项目应该用vue2还是vue3这个问题，应该是毋庸置疑的，Vue 2 将于 2023 年 12 月 31 日停止维护。所以我们在做新的项目肯定是优先考虑vue3的。老项目用的是vue2的话，需不需要重构，这要看实际的场景了。vue3搭配vite，开发体验简直提升了一个档次。速度更快，体验更好，性能更好，为何不用新的呢？而且vue3的学习成本也不高，有vue2的基础，上手vue3那简直是分分钟的事情，如果有问题就直接查文档就好了。vue的官方文档还是比较详细的。\n总结一下：对于新项目，建议优先考虑使用 Vue 3。\n以下是一些选择 Vue 3 的理由：\n\n更好的性能：Vue 3 在性能方面进行了许多优化，包括更快的渲染速度和更小的包体积。它引入了基于 Proxy 的响应式系统，使得响应式数据的追踪和更新更高效，同时也提高了虚拟 DOM 渲染的性能。\n\n更好的开发体验：Vue 3 提供了一些新的特性和语法糖，例如 Composition API、setup 函数等，可以帮助开发者组织和重用组件逻辑，提高代码的可读性和可维护性。另外，它还提供了更多的 TypeScript 支持，包括类型推断和类型声明。\n\n更好的生态系统：随着时间的推移，Vue 3 生态系统会不断壮大，支持的库和插件会越来越多。而 Vue 2 的生态系统虽然依然庞大，但未来的新特性和更新可能会更多地集中在 Vue 3 上。\n\n\n当然，对于一些特定情况，如已经有一个 Vue 2 的项目或依赖某个 Vue 2 的第三方库，可能需要权衡利弊再做选择。但从长远来看，Vue 3 将是更好的选择，它提供了更多的新特性、更好的性能和开发体验，以及更好的生态支持。\nvue3可以搭配哪些库使用首先是vue全家桶了：   \n\nvueRouter\nvuex/pinia\nelement plus\naxios\nvite\ntypescript\nvue cli\n\n以上技术栈☝️应该是当下绝大多数企业家项目的选择了。还有搭配第三方UI组件库的一些UI框架,比如以下这些。孰优孰劣，大家可以自己去分辨，根据自己的项目需要来选择就可以了\n\nAnt Design of Vue \nnaive UI\n  primevue\n  headlessui\n  vuetify\n  quasar\n  radix-vue\n  nuxtui\n  anu-vue\n  vuestic\n  daisyui\n\n​    \n","slug":"vue/再遇vue之vue3新特性","date":"2023-03-15T02:46:35.000Z","categories_index":"vue","tags_index":"vue","author_index":"前端少年汪"},{"id":"fe95ebe795da542cb5396a487283045c","title":"python爬虫超清桌面壁纸","content":"前言\n\n\n\n\n\n\n\n\n这篇文章，来爬好看的电脑壁纸。还是使用python来进行爬虫。感觉使用python爬很方便。为什么又写爬虫呢，因为我又发现了一个好看的免费的壁纸网站。\n\n目标网站：https://desk.3gbizhi.com/我是打算获取首页18种类型的所有壁纸。\n\n思路\n获取18种类型的url和图片总数量\n处理分页，遍历获取，遍历18个url下的每张缩略图片的详情url\n获取图片详情页面的图片的url或者下载链接\n\n\n代码获取18种类型的url和图片总数量 \nimport requests\nfrom bs4 import BeautifulSoup\n\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;\n                  &#39;Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36 &#39;\n&#125;\n\n\n# 获取18种类型的url和图片总数量\ndef getHome(home_url):\n    res &#x3D; requests.get(home_url, headers&#x3D;headers).text\n    soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;)\n    type_item &#x3D; soup.find(class_&#x3D;&#39;r&#39;).find_all(&#39;a&#39;)\n\n    pic_list &#x3D; []  # 18种壁纸类型的url和数量\n    for (i, element) in enumerate(type_item):\n        string &#x3D; element.text\n        parts &#x3D; string.strip().split(&#39;\\n&#39;)\n        if len(parts) &#x3D;&#x3D; 2:\n            name, count &#x3D; parts[0], parts[1].strip(&#39;()张&#39;)\n            pic_list.append(&#123;\n                &quot;href&quot;: element.get(&#39;href&#39;),\n                &quot;type&quot;: name,\n                &quot;total_num&quot;: count,\n            &#125;)\n    print(pic_list)\n    return pic_list\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    base_url &#x3D; &#39;https:&#x2F;&#x2F;desk.3gbizhi.com&#x2F;&#39;\n    getHome(base_url)\n\n\n遍历18个url获取每张缩略图片的详情urldef getTypePage(type_list):\n    all &#x3D; []\n    for (i, item) in enumerate(type_list):\n        try:\n            # if i &#x3D;&#x3D; 1:\n                type_detail_url &#x3D; []\n                print(i, item[&#39;type&#39;])\n                page &#x3D; int(item.get(&#39;total_num&#39;) &#x2F; 24) + 1\n                for pageItem in range(1, page + 1):\n                    print(&#39;第一页&#39;, pageItem)\n                    res &#x3D; requests.get(item.get(&#39;href&#39;) + &#39;&#x2F;index_&#123;&#125;.html&#39;.format(pageItem), headers&#x3D;headers).text\n                    soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;)\n                    print(item.get(&#39;href&#39;) + &#39;&#x2F;index_&#123;&#125;.html&#39;.format(pageItem))\n                    # 明星壁纸\n                    detail_url_list &#x3D; soup.find_all(class_&#x3D;&#39;box_black&#39;)\n                    for (vi, v) in enumerate(detail_url_list):\n                        pic_det_url &#x3D; v.find(class_&#x3D;&#39;desk imgw&#39;).get(&#39;href&#39;)\n                        pic_det_title &#x3D; v.find(class_&#x3D;&#39;title&#39;).text\n                        # print(vi, pic_det_url, pic_det_title)\n                        type_detail_url.append(&#123;\n                            &#39;url&#39;: pic_det_url,\n                            &#39;title&#39;: pic_det_title,\n                        &#125;)\n                print(len(type_detail_url))\n                all.append(&#123;item[&#39;type&#39;]: type_detail_url&#125;)\n\n        except Exception as e:\n            print(e)\n    print(all)\n\n\n获取详情页面里面的图片\n先说思路，把获取到的18种类型的缩略图遍历，先遍历类型再遍历类型里面的缩略图。获取图片详情里面的图片的src地址即可，然后调用写好的图片下载方法就可以把图片下载到本地了\n直接上代码\ndef getDetail(all):\n    for (i, item) in enumerate(all):\n        for (son, el) in enumerate(item):\n            try:\n                res &#x3D; requests.get(el.get(&#39;url&#39;), headers&#x3D;headers).text\n                soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;).find(class_&#x3D;&#39;wallphotos&#39;).find(&#39;img&#39;).get(&#39;src&#39;)\n                print(&#39;第&#123;&#125;第&#123;&#125;张开始下载...&#39;.format(i+1, son), soup)\n                download_img(soup,son)\n            except Exception as e:\n                print(e)\n\n\n以上就是，整个的壁纸爬虫过程了，代码不过百行，是不是感觉很简单。不过我爬取的不是真正的原图，哈哈哈偷了一下懒，真正的原图要获取下载按钮里面的下载链接。这个网站做了一些反扒机制，要获取原图链接是需要点击下载按钮之后才会返回，而且还需要登录。这个稍微麻烦一些，我下期再介绍如何反扒，欲知后事如何，请听下回分解…\n最后给出全部完整代码\n完整代码import os\n\nimport requests\nfrom bs4 import BeautifulSoup\n\nheaders &#x3D; &#123;\n    &#39;user-agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;\n                  &#39;Chrome&#x2F;106.0.0.0 Safari&#x2F;537.36 &#39;\n&#125;\n# 存放下载图片的文件夹名称\nnew_folder &#x3D; &#39;img&#39;\n# 获取当前目录\ncurrent_dir &#x3D; os.getcwd()\n\n# 新文件夹的名称\n# new_folder &#x3D; &#39;img_&#123;&#125;&#39;.format(type_list[type_index])  # 创建新文件夹\nif not os.path.exists(new_folder):\n    os.mkdir(os.path.join(current_dir, new_folder))\n\n\ndef download_img(img_src, i):\n    &quot;&quot;&quot;\n    图片下载\n    :param img_src: 图片的src\n    :param i: 序号\n    :return: void\n    &quot;&quot;&quot;\n    with open(&#39;.&#x2F;&#123;&#125;&#x2F;&#123;&#125;-&#123;&#125;&#39;.format(new_folder, i, img_src.split(&#39;&#x2F;&#39;)[-1]), &#39;wb&#39;) as f:\n        f.write(requests.get(img_src).content)\n    print(i, img_src, &#39;下载完成&#39;)\n\n\ndef get_soup(url):\n    return BeautifulSoup(requests.get(url, headers&#x3D;headers).text, &#39;html.parser&#39;)\n\n\n# 获取18种类型的url和图片总数量\ndef getHome(home_url):\n    try:\n        res &#x3D; requests.get(home_url, headers&#x3D;headers).text\n        soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;)\n        type_item &#x3D; soup.find(class_&#x3D;&#39;r&#39;).find_all(&#39;a&#39;)\n\n        pic_list &#x3D; []  # 18种壁纸类型的url和数量\n        for (i, element) in enumerate(type_item):\n            string &#x3D; element.text\n            parts &#x3D; string.strip().split(&#39;\\n&#39;)\n            if len(parts) &#x3D;&#x3D; 2:\n                name, count &#x3D; parts[0], parts[1].strip(&#39;()张&#39;)\n                pic_list.append(&#123;\n                    &quot;href&quot;: element.get(&#39;href&#39;),\n                    &quot;type&quot;: name,\n                    &quot;total_num&quot;: int(count),\n                &#125;)\n        # print(pic_list[0])\n        return pic_list\n    except Exception as e:\n        print(e)\n\n\ndef getTypePage(type_list):\n    all &#x3D; []\n    for (i, item) in enumerate(type_list):\n        try:\n            if i &#x3D;&#x3D; 1:\n                type_detail_url &#x3D; []\n                print(i, item[&#39;type&#39;])\n                page &#x3D; int(item.get(&#39;total_num&#39;) &#x2F; 24) + 1\n                for pageItem in range(1, page + 1):\n                    print(&#39;第一页&#39;, pageItem)\n                    res &#x3D; requests.get(item.get(&#39;href&#39;) + &#39;&#x2F;index_&#123;&#125;.html&#39;.format(pageItem), headers&#x3D;headers).text\n                    soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;)\n                    print(item.get(&#39;href&#39;) + &#39;&#x2F;index_&#123;&#125;.html&#39;.format(pageItem))\n                    # 明星壁纸\n                    detail_url_list &#x3D; soup.find_all(class_&#x3D;&#39;box_black&#39;)\n                    for (vi, v) in enumerate(detail_url_list):\n                        pic_det_url &#x3D; v.find(class_&#x3D;&#39;desk imgw&#39;).get(&#39;href&#39;)\n                        pic_det_title &#x3D; v.find(class_&#x3D;&#39;title&#39;).text\n                        # print(vi, pic_det_url, pic_det_title)\n                        type_detail_url.append(&#123;\n                            &#39;url&#39;: pic_det_url,\n                            &#39;title&#39;: pic_det_title,\n                        &#125;)\n                # print(len(type_detail_url))\n                # all.append(&#123;item[&#39;type&#39;]: type_detail_url&#125;)\n                all.append(type_detail_url)\n\n        except Exception as e:\n            print(e)\n    # print(all)\n    return all\n\n\ndef getDetail(all):\n    for (i, item) in enumerate(all):\n        for (son, el) in enumerate(item):\n            try:\n                res &#x3D; requests.get(el.get(&#39;url&#39;), headers&#x3D;headers).text\n                soup &#x3D; BeautifulSoup(res, &#39;html.parser&#39;).find(class_&#x3D;&#39;wallphotos&#39;).find(&#39;img&#39;).get(&#39;src&#39;)\n                print(&#39;第&#123;&#125;页第&#123;&#125;张开始下载...&#39;.format(i + 1, son), soup)\n                download_img(soup, son)\n            except Exception as e:\n                print(e)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    base_url &#x3D; &#39;https:&#x2F;&#x2F;desk.3gbizhi.com&#x2F;&#39;\n    pic_lists &#x3D; getHome(base_url)\n    all1 &#x3D; getTypePage(pic_lists)\n    getDetail(all1)\n\n放几张壁纸给大家看看，欣赏一下(虽软不是原图)\n\n\n\n","slug":"python/python爬虫超清桌面壁纸","date":"2023-03-13T02:46:35.000Z","categories_index":"python","tags_index":"爬虫","author_index":"前端少年汪"},{"id":"3140e76ccb52a413540ef6b8d667bcb4","title":"Gin入门教程：从零开始学习Go语言Web框架","content":"\n\n\n\n\n\n\n\n\n在Go语言的Web开发领域，Gin框架无疑是一个备受关注的轻量级框架。它具有快速、高效、易用等特点，非常适合用于构建Web应用程序。本篇博客将带领大家从零开始学习Gin框架，包括安装、基本用法和常用功能等内容。Gin 是一个用 Go 语言编写的 Web 框架，它提供了快速构建高性能 Web 应用程序的工具和框架。下面是 Gin 框架的一些特点和功能\n\n高性能： Gin 框架基于 Radix 树路由匹配算法，性能优秀，可以处理大量并发请求。\n\n中间件支持： Gin 框架内置了丰富的中间件支持，包括 Logger、Recovery 等常用中间件，同时也支持自定义中间件来扩展框架功能。\n\n路由功能： Gin 框架提供了灵活简洁的路由定义方式，支持参数化路由、RESTful 风格的路由定义以及路由组等功能。\n\nJSON 解析与绑定： Gin 框架提供了对 JSON 数据的解析和绑定功能，可以方便地处理接收和返回 JSON 格式的数据。\n\n模板渲染： Gin 框架支持使用 HTML 模板进行视图渲染，可以方便地构建 Web 页面。\n\n错误处理： Gin 框架提供了统一的错误处理机制，可以方便地处理各种错误情况。\n\n验证与绑定： Gin 框架内置了参数验证和绑定功能，可以方便地验证和绑定 HTTP 请求的参数。\n\n插件系统： Gin 框架支持插件系统，可以通过插件扩展框架的功能。\n\n\n小试牛刀\n安装Gin框架\n\n首先，我们需要安装Gin框架。在Go语言的环境下，可以通过以下命令来安装Gin：\ngo get -u github.com&#x2F;gin-gonic&#x2F;gin\n\n\n创建第一个Gin应用\n\n接下来，我们将创建一个简单的Gin应用程序。首先，创建一个名为main.go的文件，并在其中编写以下代码：\npackage main\n\nimport &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\nfunc main() &#123;\n    r :&#x3D; gin.Default()\n    r.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n        c.String(200, &quot;Hello, Gin!&quot;)\n    &#125;)\n    r.Run(&quot;:8080&quot;)\n&#125;\n\n在上面的代码中，我们首先导入了Gin框架的包，然后创建了一个默认的Gin引擎，并定义了一个路由，最后启动了Gin应用程序。\n\n常用功能\n\n除了基本的路由功能外，Gin框架还提供了许多常用的功能，如中间件、参数解析、日志记录等。下面是一个使用中间件和参数解析的示例：\npackage main\n\nimport (\n    &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n    &quot;net&#x2F;http&quot;\n)\n\nfunc main() &#123;\n    r :&#x3D; gin.Default()\n\n    r.Use(gin.Logger())\n    r.Use(gin.Recovery())\n\n    r.GET(&quot;&#x2F;hello&quot;, func(c *gin.Context) &#123;\n        name :&#x3D; c.Query(&quot;name&quot;)\n        c.JSON(http.StatusOK, gin.H&#123;&quot;message&quot;: &quot;Hello, &quot; + name&#125;)\n    &#125;)\n\n    r.Run(&quot;:8080&quot;)\n&#125;\n\n在上面的示例中，我们首先使用了Logger和Recovery中间件，然后定义了一个带有参数解析的路由，最后启动了Gin应用程序。\n详细教程步骤1.  安装和配置 Gin 框架\n  介绍如何使用 Go 的包管理工具安装 Gin\n  配置 Gin 框架的基本设置，如路由、中间件等\n\n2.  路由和请求处理\n  Gin 框架提供了简洁的路由定义方式，支持参数化路由和 RESTful 风格的路由\n  如何处理 GET、POST、PUT 等不同类型的 HTTP 请求\n  探索 Gin 框架的中间件机制，实现请求前后的处理逻辑\n\n3.  模板渲染和静态文件\n  Gin 框架支持使用 HTML 模板进行视图渲染，展示动态生成的内容\n  如何配置和使用模板引擎\n  在 Gin 框架中提供静态文件服务，如 CSS、JavaScript 等\n\n4.  JSON 解析和绑定\n  Gin 框架内置了对 JSON 数据的解析和绑定功能\n  如何处理接收和返回 JSON 格式的数据\n  使用结构体绑定请求参数，简化数据处理过程\n\n5.  错误处理和日志记录\n  Gin 框架提供了统一的错误处理机制，方便处理各种错误情况\n  如何自定义错误处理函数，增强用户体验\n  使用 Gin 框架的日志功能，记录应用程序运行状态和调试信息\n\n6.  部署和扩展\n  介绍如何将 Gin 应用程序部署到生产环境\n  探索 Gin 框架的插件系统，扩展框架的功能\n  总结 Gin 框架的优点和适用场景\n\n\n1.  安装和配置 Gin 框架\n安装 Go 编程语言：首先，你需要安装 Go 编程语言。可以从官方网站（https://golang.org/）下载适合你操作系统的安装包，并按照官方文档进行安装。\n\n创建一个 Go 项目：在你选择的目录下，创建一个新的文件夹作为你的项目的根目录，并进入该文件夹。\n\n初始化 Go 模块：在项目根目录下执行以下命令来初始化 Go 模块：\n go mod init &lt;module-name&gt;\n\n 这将会创建一个 go.mod 文件，用于管理项目的依赖。\n\n安装 Gin 框架：在项目根目录下执行以下命令来安装 Gin 框架：\n go get -u github.com&#x2F;gin-gonic&#x2F;gin\n\n 这将会安装最新版本的 Gin 框架及其依赖。\n\n创建并运行一个简单的 Gin 应用程序：在项目根目录下创建一个名为 main.go 的文件，并写入以下代码：\n package main\n\nimport &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\nfunc main() &#123;\n    router :&#x3D; gin.Default()\n\n    router.GET(&quot;&#x2F;&quot;, func(c *gin.Context) &#123;\n        c.JSON(200, gin.H&#123;\n            &quot;message&quot;: &quot;Hello, Gin!&quot;,\n        &#125;)\n    &#125;)\n\n    router.Run(&quot;:8080&quot;)\n&#125;\n运行应用程序：在项目根目录下执行以下命令来运行应用程序：\n go run main.go\n\n 应用程序将会在本地的 8080 端口上运行。\n\n\n在这个简单的示例中，我们创建了一个使用 Gin 框架的 HTTP 服务器，并定义了一个简单的路由处理函数来返回 JSON 格式的响应。\n这样，你就成功安装和配置了 Gin 框架，并创建并运行了一个简单的 Gin 应用程序。你可以通过访问 http://localhost:8080 来查看应用程序的输出。\n2. 路由定义和处理：package main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; GET 请求处理\n\trouter.GET(&quot;&#x2F;hello&quot;, func(c *gin.Context) &#123;\n\t\tc.JSON(200, gin.H&#123;\n\t\t\t&quot;message&quot;: &quot;Hello, World!&quot;,\n\t\t&#125;)\n\t&#125;)\n\n\t&#x2F;&#x2F; POST 请求处理\n\trouter.POST(&quot;&#x2F;users&quot;, func(c *gin.Context) &#123;\n\t\tvar user User\n\t\tif err :&#x3D; c.ShouldBindJSON(&amp;user); err !&#x3D; nil &#123;\n\t\t\tc.JSON(400, gin.H&#123;\n\t\t\t\t&quot;error&quot;: err.Error(),\n\t\t\t&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 处理接收到的用户数据\n\t\t&#x2F;&#x2F; ...\n\n\t\tc.JSON(200, gin.H&#123;\n\t\t\t&quot;message&quot;: &quot;User created successfully&quot;,\n\t\t&#125;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n参数化路由和路由组：package main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 参数化路由\n\trouter.GET(&quot;&#x2F;users&#x2F;:id&quot;, func(c *gin.Context) &#123;\n\t\tid :&#x3D; c.Param(&quot;id&quot;)\n\t\tc.String(200, &quot;User ID: %s&quot;, id)\n\t&#125;)\n\n\t&#x2F;&#x2F; 路由组\n\tv1 :&#x3D; router.Group(&quot;&#x2F;api&#x2F;v1&quot;)\n\t&#123;\n\t\tv1.GET(&quot;&#x2F;users&quot;, func(c *gin.Context) &#123;\n\t\t\tc.String(200, &quot;List of users&quot;)\n\t\t&#125;)\n\t\tv1.POST(&quot;&#x2F;users&quot;, func(c *gin.Context) &#123;\n\t\t\tc.String(200, &quot;Create a user&quot;)\n\t\t&#125;)\n\t\tv1.PUT(&quot;&#x2F;users&#x2F;:id&quot;, func(c *gin.Context) &#123;\n\t\t\tid :&#x3D; c.Param(&quot;id&quot;)\n\t\t\tc.String(200, &quot;Update user with ID: %s&quot;, id)\n\t\t&#125;)\n\t\tv1.DELETE(&quot;&#x2F;users&#x2F;:id&quot;, func(c *gin.Context) &#123;\n\t\t\tid :&#x3D; c.Param(&quot;id&quot;)\n\t\t\tc.String(200, &quot;Delete user with ID: %s&quot;, id)\n\t\t&#125;)\n\t&#125;\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n这些代码示例展示了如何使用 Gin 框架定义路由和处理请求，包括 GET 和 POST 请求的处理、参数化路由以及路由组的使用。 \n3. 模板渲染和静态文件1. 模板渲染：Gin 框架内置了对多种模板引擎的支持，包括 HTML 模板引擎、Ace 模板引擎等。你可以通过 gin.Default() 方法创建一个默认的路由组，并使用 LoadHTMLGlob 方法来加载模板文件。以下是一个简单的示例：\n \npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;net&#x2F;http&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 加载模板文件\n\trouter.LoadHTMLGlob(&quot;templates&#x2F;*&quot;)\n\n\t&#x2F;&#x2F; 定义路由处理函数，渲染模板\n\trouter.GET(&quot;&#x2F;hello&quot;, func(c *gin.Context) &#123;\n\t\tc.HTML(http.StatusOK, &quot;hello.tmpl&quot;, gin.H&#123;\n\t\t\t&quot;title&quot;: &quot;Hello, Gin!&quot;,\n\t\t&#125;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们首先使用 LoadHTMLGlob 方法加载了位于 “templates” 目录下的所有模板文件。然后，在 “/hello” 路由处理函数中，我们使用 c.HTML 方法渲染了名为 “hello.tmpl” 的模板，并传递了一个包含标题信息的数据。\n2. 静态文件服务： \npackage main\n\nimport &quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 从相对路径 &quot;assets&quot; 提供静态文件\n\trouter.Static(&quot;&#x2F;static&quot;, &quot;.&#x2F;assets&quot;)\n\n\t&#x2F;&#x2F; 从绝对路径 &quot;&#x2F;tmp&quot; 提供静态文件\n\trouter.StaticFS(&quot;&#x2F;static2&quot;, http.Dir(&quot;&#x2F;tmp&quot;))\n\n\t&#x2F;&#x2F; 提供单个静态文件\n\trouter.StaticFile(&quot;&#x2F;favicon.ico&quot;, &quot;.&#x2F;resources&#x2F;favicon.ico&quot;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n这个示例展示了如何在 Gin 框架中提供静态文件服务，可以方便地将静态资源文件（如图片、样式表、脚本等）提供给客户端。\n4. JSON 解析与绑定：package main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n)\n\ntype User struct &#123;\n\tUsername string &#96;json:&quot;username&quot;&#96;\n\tPassword string &#96;json:&quot;password&quot;&#96;\n&#125;\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\trouter.POST(&quot;&#x2F;login&quot;, func(c *gin.Context) &#123;\n\t\tvar user User\n\t\tif err :&#x3D; c.ShouldBindJSON(&amp;user); err !&#x3D; nil &#123;\n\t\t\tc.JSON(400, gin.H&#123;&quot;error&quot;: err.Error()&#125;)\n\t\t\treturn\n\t\t&#125;\n\n\t\t&#x2F;&#x2F; 根据用户输入的用户名和密码进行验证\n\t\t&#x2F;&#x2F; ...\n\n\t\tc.JSON(200, gin.H&#123;&quot;message&quot;: &quot;Login successful&quot;&#125;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n这个示例演示了如何接收 JSON 格式的请求体，并将其绑定到结构体中进行处理。\n这些代码示例展示了 Gin 框架中各种功能的具体使用方法，包括中间件、JSON 解析与绑定等。 \n5. 错误处理和日志记录1.自定义错误处理函数Gin 框架允许你注册全局的中间件来处理错误。你可以创建一个中间件函数来捕获处理程序中的错误，并返回自定义的错误响应。以下是一个简单的示例：\n \npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;net&#x2F;http&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.Default()\n\n\t&#x2F;&#x2F; 自定义全局中间件处理错误\n\trouter.Use(func(c *gin.Context) &#123;\n\t\tc.Next()\n\n\t\t&#x2F;&#x2F; 检查是否有发生错误\n\t\tif len(c.Errors) &gt; 0 &#123;\n\t\t\t&#x2F;&#x2F; 自定义错误处理\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H&#123;&quot;error&quot;: &quot;服务器内部错误&quot;&#125;)\n\t\t&#125;\n\t&#125;)\n\n\trouter.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n\t\t&#x2F;&#x2F; 模拟处理过程中发生错误\n\t\tc.Error(gin.Error&#123;Err: errors.New(&quot;处理过程中发生错误&quot;)&#125;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们创建了一个全局中间件函数来检查处理过程中是否有错误发生，如果有错误则返回自定义的错误响应。在路由处理函数中，我们通过 c.Error 方法模拟了一个处理过程中发生的错误。\n2.使用 Gin 框架的日志功能Gin 框架默认集成了日志功能，你可以直接使用 gin.Default() 方法创建的默认路由组来记录日志。以下是一个示例：\n \npackage main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;os&quot;\n)\n\nfunc main() &#123;\n\t&#x2F;&#x2F; 将日志输出到文件\n\tf, _ :&#x3D; os.Create(&quot;gin.log&quot;)\n\tgin.DefaultWriter &#x3D; io.MultiWriter(f, os.Stdout)\n\n\trouter :&#x3D; gin.Default()\n\n\trouter.GET(&quot;&#x2F;ping&quot;, func(c *gin.Context) &#123;\n\t\tc.String(http.StatusOK, &quot;pong&quot;)\n\t&#125;)\n\n\trouter.Run(&quot;:8080&quot;)\n&#125;\n\n在这个示例中，我们将日志输出到文件 “gin.log” 中，并使用 io.MultiWriter 来同时输出到文件和标准输出。Gin 框架会自动记录请求的详细信息以及处理时间等日志内容。\n6.部署和扩展1.部署到生产环境将 Gin 应用程序部署到生产环境通常涉及以下步骤：\n\n编译应用程序：首先，你需要将 Gin 应用程序编译为可执行文件。你可以使用 Go 的内置工具或者其他构建工具来完成这个步骤。\n\n配置服务器：选择一个适合的服务器作为部署目标，比如 Nginx 或 Apache。配置服务器以便它可以与你的 Gin 应用程序进行交互，并且可以处理静态文件、负载均衡等。\n\n设置环境变量：在生产环境中，你可能需要设置不同的环境变量来配置应用程序的行为，比如数据库连接信息、日志级别等。\n\n启动应用程序：将编译好的应用程序部署到服务器上，并启动它。你可以使用类似 systemd 或 Supervisor 的工具来管理应用程序的运行。\n\n监控和日志：配置监控系统和日志记录，以便及时发现问题并进行故障排除。\n\n\n以上是部署 Gin 应用程序到生产环境的一般步骤，当然具体的步骤会根据你的实际情况而有所不同。\n2.插件系统和扩展功能Gin 框架本身并没有官方支持的插件系统，但你可以通过 Go 语言的包管理系统来引入第三方库以扩展框架的功能。比如，你可以使用第三方的中间件来增加额外的功能，或者使用其他与 Gin 框架兼容的库来扩展路由、验证、日志等方面的功能。\n3.Gin 框架的优点和适用场景Gin 框架具有以下优点：\n\n轻量级快速：Gin 框架性能优异，适合构建高性能的 Web 应用程序。\n易学易用：Gin 框架的 API 设计简洁清晰，容易上手。\n丰富的中间件支持：Gin 提供了丰富的中间件支持，可以轻松实现各种功能扩展。\n\n适用场景包括但不限于：\n\n构建高性能的 Web 服务\n快速开发原型或中小型 Web 应用\n对性能要求较高的后端服务package main\n\nimport (\n\t&quot;github.com&#x2F;gin-gonic&#x2F;gin&quot;\n\t&quot;net&#x2F;http&quot;\n)\n\nfunc main() &#123;\n\trouter :&#x3D; gin.New()\n\n\t&#x2F;&#x2F; 添加中间件来记录请求日志\n\trouter.Use(gin.Logger())\n\n\t&#x2F;&#x2F; 定义路由处理函数\n\trouter.GET(&quot;&#x2F;hello&quot;, func(c *gin.Context) &#123;\n\t\tc.String(http.StatusOK, &quot;Hello, Gin!&quot;)\n\t&#125;)\n\n\t&#x2F;&#x2F; 部署到生产环境时，可以设置监听地址和端口\n\trouter.Run(&quot;:8000&quot;)\n&#125;\n\n在这个示例中，我们创建了一个新的 gin.Engine 实例，并使用 Use 方法添加了 gin.Logger() 中间件，用于记录请求日志。然后定义了一个简单的 “/hello” 路由处理函数，用于返回 “Hello, Gin!”。\n对于部署到生产环境的步骤，你需要编译这个应用程序，并将编译好的可执行文件部署到服务器上。你还需要配置服务器以便它可以与 Gin 应用程序进行交互，并设置监听地址和端口。总的来说，Gin 框架适合构建对性能要求较高、同时需要保持开发效率的 Web 应用程序。\n总结总的来说，Gin 框架具有轻量级、高性能、易用的特点，适合用于构建 Web 服务和 RESTful API。它的设计理念是简洁而高效，使得开发人员可以专注于业务逻辑的实现而不必花费过多精力在框架本身\n通过本篇博客的介绍，相信大家已经对Gin框架有了一定的了解。Gin框架的轻量、高效和易用性使得它成为Go语言Web开发的不错选择。希望本篇博客能够帮助大家快速入门Gin框架，并在实际项目中应用起来。\n我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：链接\n","slug":"go/Gin入门教程：从零开始学习Go语言Web框架","date":"2023-03-01T02:14:26.000Z","categories_index":"go","tags_index":"gin go","author_index":"前端少年汪"},{"id":"4ec1a2110135da03fdd6a951884bb497","title":"如何使用node的http模块部署前端build包","content":"创建简单的静态文件服务器：使用Node.js和HTTP模块在Web开发中，经常需要搭建一个能够提供静态文件访问的服务器。无论是用于本地开发调试，还是用于部署网站，这都是一个常见的需求。本篇文章将介绍如何使用Node.js和其内置的HTTP模块来创建一个简单的静态文件服务器。\n准备工作首先，确保你已经安装了Node.js环境。如果没有安装，可以到Node.js官网（https://nodejs.org/）下载并安装最新版本。\n代码实现接下来，我们将通过以下代码来创建一个简单的静态文件服务器：\nconst http &#x3D; require(&#39;http&#39;);\nconst fs &#x3D; require(&#39;fs&#39;);\nconst path &#x3D; require(&#39;path&#39;);\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 省略上面提到的代码，详见下文\n&#125;);\n\nconst port &#x3D; process.env.PORT || &#39;3030&#39;;\nserver.listen(port, () &#x3D;&gt; &#123;\n    console.log(&#96;Server running at http:&#x2F;&#x2F;localhost:$&#123;port&#125;&#x2F;&#96;);\n&#125;);\n\n代码解释：我们首先导入了Node.js内置的http、fs和path模块，分别用于创建HTTP服务器、读取文件和处理文件路径。然后使用http.createServer方法创建了一个HTTP服务器，并传入了一个回调函数处理请求和响应。接着定义了服务器监听的端口号，并通过server.listen方法来启动服务器。\n接下来，我们需要完善回调函数中的逻辑，使其能够根据请求的路径返回相应的静态文件内容。以下是完整的代码：\n&#x2F;&#x2F; 上面提到的回调函数\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    let filePath &#x3D; &#39;.&#39; + req.url;\n    if (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;&#39;) &#123;\n        filePath &#x3D; &#39;.&#x2F;index.html&#39;;\n    &#125;\n\n    &#x2F;&#x2F; 省略文件类型判断和读取文件的部分，详见下文\n&#125;);\n\n&#x2F;&#x2F; 省略端口设置和服务器启动的部分\n\n在上面的代码中，我们根据请求的URL构造了文件路径filePath，并设置了默认的文件路径为&#39;./index.html&#39;。接下来，我们需要根据文件的扩展名来确定其Content-Type，并读取文件内容，然后将文件内容作为响应返回给客户端。具体的文件类型判断和读取文件的部分如下：\n&#x2F;&#x2F; 文件类型判断和读取文件的部分\nconst extname &#x3D; String(path.extname(filePath)).toLowerCase();\nconst contentType &#x3D; &#123;\n    &#39;.html&#39;: &#39;text&#x2F;html&#39;,\n    &#39;.js&#39;: &#39;text&#x2F;javascript&#39;,\n    &#x2F;&#x2F; ... 其他文件类型的Content-Type\n&#125;[extname] || &#39;application&#x2F;octet-stream&#39;;\n\nfs.readFile(filePath, function (error, content) &#123;\n    if (error) &#123;\n        if (error.code &#x3D;&#x3D;&#x3D; &#39;ENOENT&#39;) &#123; &#x2F;&#x2F; 文件不存在\n            fs.readFile(&#39;.&#x2F;404.html&#39;, function (error, content) &#123;\n                res.writeHead(404, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);\n                res.end(content, &#39;utf-8&#39;);\n            &#125;);\n        &#125; else &#123; &#x2F;&#x2F; 其他错误\n            res.writeHead(500);\n            res.end(&#39;Sorry, check with the site admin for error: &#39; + error.code + &#39; ..\\n&#39;);\n            res.end();\n        &#125;\n    &#125; else &#123; &#x2F;&#x2F; 文件存在\n        res.writeHead(200, &#123;&#39;Content-Type&#39;: contentType&#125;);\n        res.end(content, &#39;utf-8&#39;);\n    &#125;\n&#125;);\n\n在上面的代码中，我们首先通过path.extname方法获取文件的扩展名，然后根据扩展名确定其Content-Type，并使用fs.readFile方法读取文件内容。如果读取文件出现错误，我们会返回相应的状态码和错误信息；如果文件存在，则根据Content-Type设置响应头，并将文件内容返回给客户端。\n运行服务器保存以上代码到一个文件（比如server.js），然后打开命令行，进入文件所在目录，运行以下命令启动服务器：\nnode server.js\n\n此时，服务器会在默认端口3030上启动，你可以打开浏览器访问http://localhost:3030/来查看效果。如果需要修改端口，可以通过设置环境变量PORT来改变监听的端口号，比如：\nPORT&#x3D;8080 node server.js\n\n总结通过本篇文章，我们学习了如何使用Node.js和HTTP模块来创建一个简单的静态文件服务器。这个服务器可以用于提供HTML、CSS、JavaScript等静态文件，在开发调试和部署网站时非常有用。希望这篇文章能够帮助你更好地理解Node.js的HTTP模块以及静态文件服务器的实现原理。\n完整代码const http &#x3D; require(&#39;http&#39;);  &#x2F;&#x2F; 导入内置的 http 模块\nconst fs &#x3D; require(&#39;fs&#39;);  &#x2F;&#x2F; 导入内置的文件系统模块\nconst path &#x3D; require(&#39;path&#39;);  &#x2F;&#x2F; 导入内置的路径处理模块\n\nconst server &#x3D; http.createServer((req, res) &#x3D;&gt; &#123;\n    let filePath &#x3D; &#39;.&#39; + req.url;  &#x2F;&#x2F; 构造文件路径，以当前目录为根目录\n    if (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;&#39;) &#123;  &#x2F;&#x2F; 如果文件路径为根路径\n        filePath &#x3D; &#39;.&#x2F;index.html&#39;;  &#x2F;&#x2F; 默认返回 index.html 文件\n    &#125;\n\n    const extname &#x3D; String(path.extname(filePath)).toLowerCase();  &#x2F;&#x2F; 获取文件的扩展名并转换为小写\n    const contentType &#x3D; &#123;  &#x2F;&#x2F; 定义不同文件类型对应的 Content-Type\n        &#39;.html&#39;: &#39;text&#x2F;html&#39;,\n        &#39;.js&#39;: &#39;text&#x2F;javascript&#39;,\n        &#39;.css&#39;: &#39;text&#x2F;css&#39;,\n        &#39;.json&#39;: &#39;application&#x2F;json&#39;,\n        &#39;.png&#39;: &#39;image&#x2F;png&#39;,\n        &#39;.jpg&#39;: &#39;image&#x2F;jpg&#39;,\n        &#39;.gif&#39;: &#39;image&#x2F;gif&#39;,\n        &#39;.svg&#39;: &#39;image&#x2F;svg+xml&#39;,\n        &#39;.wav&#39;: &#39;audio&#x2F;wav&#39;,\n        &#39;.mp4&#39;: &#39;video&#x2F;mp4&#39;,\n        &#39;.woff&#39;: &#39;application&#x2F;font-woff&#39;,\n        &#39;.ttf&#39;: &#39;application&#x2F;font-ttf&#39;,\n        &#39;.eot&#39;: &#39;application&#x2F;vnd.ms-fontobject&#39;,\n        &#39;.otf&#39;: &#39;application&#x2F;font-otf&#39;,\n        &#39;.wasm&#39;: &#39;application&#x2F;wasm&#39;\n    &#125;[extname] || &#39;application&#x2F;octet-stream&#39;;  &#x2F;&#x2F; 如果找不到对应的 Content-Type，默认使用 application&#x2F;octet-stream\n\n    fs.readFile(filePath, function (error, content) &#123;  &#x2F;&#x2F; 读取文件内容的回调函数\n        if (error) &#123;  &#x2F;&#x2F; 如果读取文件出现错误\n            if (error.code &#x3D;&#x3D;&#x3D; &#39;ENOENT&#39;) &#123;  &#x2F;&#x2F; 如果文件不存在\n                fs.readFile(&#39;.&#x2F;404.html&#39;, function (error, content) &#123;  &#x2F;&#x2F; 读取 404.html 文件\n                    res.writeHead(404, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);  &#x2F;&#x2F; 返回状态码和 Content-Type\n                    res.end(content, &#39;utf-8&#39;);  &#x2F;&#x2F; 返回文件内容\n                &#125;);\n            &#125; else &#123;  &#x2F;&#x2F; 其他错误\n                res.writeHead(500);  &#x2F;&#x2F; 返回状态码 500\n                res.end(&#39;Sorry, check with the site admin for error: &#39; + error.code + &#39; ..\\n&#39;);  &#x2F;&#x2F; 返回错误信息\n                res.end();  &#x2F;&#x2F; 结束响应\n            &#125;\n        &#125; else &#123;  &#x2F;&#x2F; 如果文件存在\n            res.writeHead(200, &#123;&#39;Content-Type&#39;: contentType&#125;);  &#x2F;&#x2F; 返回状态码和对应的 Content-Type\n            res.end(content, &#39;utf-8&#39;);  &#x2F;&#x2F; 返回文件内容\n        &#125;\n    &#125;);\n\n&#125;);\n\nconst port &#x3D; process.env.PORT || &#39;3030&#39;;  &#x2F;&#x2F; 设置服务器监听的端口号，默认为 3030\nserver.listen(port, () &#x3D;&gt; &#123;\n    console.log(&#96;Server running at http:&#x2F;&#x2F;localhost:$&#123;port&#125;&#x2F;&#96;);  &#x2F;&#x2F; 在控制台输出服务器启动信息\n&#125;);\n\n注意运行server.js文件，需要把文件放的build目录里面。如果想要放到build目录外面则要更改这里build的目录设置\nlet filePath &#x3D; &#39;.&#x2F;build&#39; + req.url;\nif (filePath &#x3D;&#x3D;&#x3D; &#39;.&#x2F;build&#x2F;&#39;) &#123;\n    filePath &#x3D; &#39;.&#x2F;build&#x2F;index.html&#39;;\n&#125;","slug":"http/如何使用node的http模块部署前端build包","date":"2023-02-10T14:46:35.000Z","categories_index":"运维","tags_index":"运维 前端部署 node","author_index":"前端少年汪"},{"id":"cc1bedd8e44831bc22e0a5fe2a764356","title":"Nuxt.js，Next.js，Nest.js傻傻分不清？","content":"三者区别Nuxt.js和Next.js都是服务端渲染框架(SSR)，属于前端框架,Nest.js则是node框架,属于后端框架。\n虽然名字看起来都很像但是确实不一样的框架。其中Nuxt.js是vue的ssr框架，Next.js是react的ssr框架\n都是比vue和react更上层的前端框架\n\n \n\n       \n\n\n\n\n\n​     \nSSR框架先搞清楚什么是服务端渲染\n服务端渲染（Server-Side Rendering，简称 SSR）是一种将网页内容在服务器端动态生成并发送给客户端的技术。传统的客户端渲染（Client-Side Rendering，简称 CSR）是在客户端浏览器中使用 JavaScript 动态生成页面内容。\n在传统的客户端渲染中，浏览器首先下载一个空的 HTML 页面，然后通过 JavaScript 请求数据并生成页面内容。这种方式的优点是可以提供更丰富的交互和动态效果，但也存在一些缺点。例如，搜索引擎爬虫可能无法正确解析和索引页面内容，导致 SEO（搜索引擎优化）问题。同时，初始加载时用户可能会看到空白的页面或者出现闪烁的内容。\n相比之下，服务端渲染通过在服务器上预先生成完整的 HTML 页面，将其发送给客户端浏览器。这样，浏览器在接收到页面时就能够立即显示完整的内容，而不需要等待 JavaScript 的下载和执行。这样可以提高页面的加载速度和首次渲染速度，并且对于搜索引擎爬虫来说更容易解析和索引页面内容，有利于 SEO。\n服务端渲染的实现方式通常涉及使用服务器端框架（如Node.js、Java、Python等）来处理请求，并在服务器上生成完整的 HTML 页面。服务器端框架可以使用模板引擎或者直接在后端代码中生成 HTML。一旦生成完整的 HTML 页面，服务器将其发送给客户端浏览器，浏览器接收到后即可直接显示页面内容。\n需要注意的是，服务端渲染不是完全取代客户端渲染，而是根据需求和场景选择合适的渲染方式。一些页面或组件可能更适合使用客户端渲染，以提供更好的交互和动态效果。而对于需要更好的首次加载速度和 SEO 的页面，服务端渲染则是一个有价值的选择。\nNuxtNuxt是什么\n\n\n\n\n\n\n\n\nNuxt is an open source framework that makes web development intuitive and powerful.  Create performant and production-grade full-stack web apps and websites with confidence.   \n\n\n\n\n\n\n\n\n\nNuxt是一个开源框架，它使Web开发变得直观和强大。自信地创建高性能和生产级全栈Web应用程序和网站。\n使用Nuxt的条件\n  Node.js - v16.10.0 或更高版本\n  文本编辑器 - 我们推荐使用 Visual Studio Code 并安装 Volar 扩展\n  终端 - 用于运行 Nuxt 命令创建项目并且运行\n\nnpx nuxi@latest init &lt;project-name&gt;\n\ncd project-name\n\nnpm i\n\nnpm run dev\n\n\n\n\n这就创建项目之后的初始化页面了。\n下面我们就来看看nuxt的特性和原理\nnuxt基本上是由vue2，webpack，babel这三个构成的\n\nNuxt.js 集成了以下组件/框架，用于开发完整而强大的 Web 应用：\n\n  Vue 2\n  Vue-Router\n  Vuex (当配置了 Vuex 状态树配置项 时才会引入)\n  Vue 服务器端渲染 (排除使用 mode: &#39;spa&#39;)\n  Vue-Meta\n\n压缩并 gzip 后，总代码大小为：57kb （如果使用了 Vuex 特性的话为 60kb）。\n另外，Nuxt.js 使用 Webpack 和 vue-loader 、 babel-loader 来处理代码的自动化构建工作（如打包、代码分层、压缩等等）。\n特性\n  基于 Vue.js\n  自动代码分层\n  服务端渲染\n  强大的路由功能，支持异步数据\n  静态文件服务\n  ES2015+ 语法支持\n  打包和压缩 JS 和 CSS\n  HTML 头部标签管理\n  本地开发支持热加载\n  集成 ESLint\n  支持各种样式预处理器： SASS、LESS、 Stylus 等等\n  支持 HTTP/2 推送工作流程下图阐述了 Nuxt.js 应用一个完整的服务器请求到渲染（或用户通过 &lt;nuxt-link&gt; 切换路由渲染页面）的流程\n\n\n服务端渲染(通过 SSR)可以使用Nuxt.js作为框架来处理项目的所有 UI 呈现。\n启动时nuxt，它将启动具有热更新加载的开发服务器，并且Vue 服务器端渲染配置为自动为服务器呈现应用程序。\n目录结构\n├── README.md                \n├── components\n├── dist\n├── jest.config.js\n├── node_modules\n├── nuxt.config.js\n├── package.json\n├── pages\n├── plugins\n├── static\n├── store\n├── test\n├── tree.txt\n└── yarn.lock\n\nnuxt的配置文件在nuxt.config.js文件中\nexport default &#123;\n  &#x2F;&#x2F; Global page headers: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-head\n  head: &#123;\n    title: &#39;nuxt-demo&#39;,\n    htmlAttrs: &#123;\n      lang: &#39;en&#39;\n    &#125;,\n    meta: [\n      &#123; charset: &#39;utf-8&#39; &#125;,\n      &#123; name: &#39;viewport&#39;, content: &#39;width&#x3D;device-width, initial-scale&#x3D;1&#39; &#125;,\n      &#123; hid: &#39;description&#39;, name: &#39;description&#39;, content: &#39;&#39; &#125;,\n      &#123; name: &#39;format-detection&#39;, content: &#39;telephone&#x3D;no&#39; &#125;\n    ],\n    link: [\n      &#123; rel: &#39;icon&#39;, type: &#39;image&#x2F;x-icon&#39;, href: &#39;&#x2F;favicon.ico&#39; &#125;\n    ]\n  &#125;,\n\n  &#x2F;&#x2F; Global CSS: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-css\n  css: [\n    &#39;ant-design-vue&#x2F;dist&#x2F;antd.css&#39;\n  ],\n\n  &#x2F;&#x2F; Plugins to run before rendering page: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-plugins\n  plugins: [\n    &#39;@&#x2F;plugins&#x2F;antd-ui&#39;\n  ],\n\n  &#x2F;&#x2F; Auto import components: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-components\n  components: true,\n\n  &#x2F;&#x2F; Modules for dev and build (recommended): https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-modules\n  buildModules: [\n  ],\n\n  &#x2F;&#x2F; Modules: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-modules\n  modules: [\n  ],\n\n  &#x2F;&#x2F; Build Configuration: https:&#x2F;&#x2F;go.nuxtjs.dev&#x2F;config-build\n  build: &#123;\n  &#125;\n&#125;\n\n这里主要讲一下nuxt的路由，Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。\n要在页面之间使用路由，我们建议使用&lt;nuxt-link&gt; 标签。假设 pages 的目录结构如下：\npages&#x2F;\n--| user&#x2F;\n-----| index.vue\n-----| one.vue\n--| index.vue\n\n那么，Nuxt.js 自动生成的路由配置如下：\nrouter: &#123;\n  routes: [\n    &#123;\n      name: &#39;index&#39;,\n      path: &#39;&#x2F;&#39;,\n      component: &#39;pages&#x2F;index.vue&#39;\n    &#125;,\n    &#123;\n      name: &#39;user&#39;,\n      path: &#39;&#x2F;user&#39;,\n      component: &#39;pages&#x2F;user&#x2F;index.vue&#39;\n    &#125;,\n    &#123;\n      name: &#39;user-one&#39;,\n      path: &#39;&#x2F;user&#x2F;one&#39;,\n      component: &#39;pages&#x2F;user&#x2F;one.vue&#39;\n    &#125;\n  ]\n&#125;\n还有其他的路由方式，比如动态路由，路由参数校验，嵌套路由和动态嵌套路由等等，可以查看nuxt的路由文档\nNext\n\n\n\n\n\n\n\n\nNext.js is a React framework for building full-stack web applications. You use React Components to build user interfaces, and Next.js for additional features and optimizations.Under the hood, Next.js also abstracts and automatically configures tooling needed for React, like bundling, compiling, and more. This allows you to focus on building your application instead of spending time with configuration.Whether you’re an individual developer or part of a larger team, Next.js can help you build interactive, dynamic, and fast React applications.\n\n\n\n\n\n\n\n\n\nJs是一个用于构建全栈Web应用程序的React ssr框架。您可以使用Reaction组件来构建用户界面，使用Next.js来实现其他功能和优化。在幕后，Next.js还抽象并自动配置Reaction所需的工具，如绑定、编译等。这使您可以专注于构建应用程序，而不是花费时间进行配置。无论您是个人开发人员还是更大团队的一员，Next.js都可以帮助您构建交互式、动态和快速反应的应用程序。\n什么是 Next.js？Next.js 是一个开源的 React 框架，用于构建服务器渲染（SSR）和静态生成（SSG）的应用程序。它结合了 React 的声明性和灵活性以及服务器端渲染的性能优势，使得构建高性能的应用变得更加简单。\n主要特性\n服务器渲染和静态生成：Next.js 支持服务器渲染和静态生成两种方式。服务器渲染可以提供更快的首次加载时间和更好的 SEO。静态生成则可以预先生成页面，并在每个请求之前提供响应，从而具有出色的性能。\n\n热模块替换：Next.js 支持热模块替换（HMR），在开发过程中，您可以实时更新代码并立即看到变化，无需手动刷新页面。\n\n自动代码拆分：Next.js 可以根据页面和组件的需求自动拆分代码，只加载当前页面所需的代码，从而提高性能和加载速度。\n\n路由系统：Next.js 提供了简单而强大的路由系统，可以轻松地定义页面之间的导航关系，并支持动态路由、嵌套路由等功能。\n\nCSS 模块支持：Next.js 内置了对 CSS 模块的支持，使得组件级别的样式隔离和管理变得更加简单。\n\n\n如何开始使用 Next.js？要开始使用 Next.js，您可以按照以下步骤进行：\n\n创建新项目：使用命令行工具，在您选择的目录中创建一个新的 Next.js 项目。\n\nnpx create-next-app my-app\n\n\n定义页面：在 pages 目录下创建您的页面文件，每个文件将映射到一个路由。\n\n&#x2F;&#x2F; pages&#x2F;index.js\nfunction HomePage() &#123;\n  return &lt;h1&gt;Hello, Next.js!&lt;&#x2F;h1&gt;;\n&#125;\n\nexport default HomePage;\n\n\n编写组件：在页面文件中编写 React 组件，可以使用 JSX 语法和任何其他 React 功能。\n\n启动开发服务器：运行开发命令，启动 Next.js 开发服务器，并访问 http://localhost:3000 查看您的应用程序。\n\n\nnpm run dev\n\n5.构建和部署：当您准备好部署应用程序时，使用构建命令生成优化的生产版本，并将其部署到您选择的托管平台上。\n结论Next.js 是一个强大而灵活的框架，为 React 开发者提供了构建高性能应用程序的便利性。它的服务器渲染和静态生成功能、热模块替换和自动代码拆分等特性使得开发过程更加高效和愉快。如果您正在寻找一种简单而强大的方式来构建 React 应用程序，不妨试试 Next.js！\nnode框架标题：入门指南：了解 Nest.js\n正文：\n在现代 Web 开发中，构建高性能的应用程序是至关重要的。Nest.js 是一个基于 TypeScript 的框架，它提供了一种简单而强大的方式来构建可扩展和模块化的应用程序。本文将介绍 Nest.js 的基本概念和特性，并提供代码示例，帮助您快速入门。\n什么是 Nest.js？Nest.js 是一个基于 TypeScript 的框架，用于构建可扩展和模块化的服务器端应用程序。它结合了 Angular 的依赖注入和模块化、Express 的灵活性和 Node.js 的性能优势，使得构建高性能的应用变得更加简单。\n主要特性\n基于 TypeScript：Nest.js 使用 TypeScript 编写，可以利用静态类型检查和强类型约束来提高代码质量和开发效率。\n\n依赖注入：Nest.js 提供了 Angular 风格的依赖注入机制，使得组件之间的协作和解耦变得更加简单。\n\n模块化：Nest.js 支持模块化编程，可以将应用程序拆分成多个可重用的模块，从而提高代码的可维护性和可扩展性。\n\n路由系统：Nest.js 提供了强大的路由系统，可以轻松地定义 API 路由和请求处理程序，并支持中间件和管道等功能。\n\n支持多种数据库：Nest.js 支持多种数据库，包括 MongoDB、MySQL、PostgreSQL 等，可以轻松地与数据库进行交互。\n\n\n如何开始使用 Nest.js？要开始使用 Nest.js，您可以按照以下步骤进行：\n\n创建新项目：使用命令行工具，在您选择的目录中创建一个新的 Nest.js 项目。\n\n$ npm i -g @nestjs&#x2F;cli\n$ nest new project-name\n\n\n定义控制器：在 src 目录下创建您的控制器文件，每个文件将映射到一个路由。\n\nimport &#123; Controller, Get &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Controller(&#39;cats&#39;)\nexport class CatsController &#123;\n  @Get()\n  findAll(): string &#123;\n    return &#39;This action returns all cats&#39;;\n  &#125;\n&#125;\n\n\n定义模块：在 src 目录下创建您的模块文件，用于组织和管理应用程序中的组件。\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; CatsController &#125; from &#39;.&#x2F;cats.controller&#39;;\n\n@Module(&#123;\n  controllers: [CatsController],\n&#125;)\nexport class AppModule &#123;&#125;\n\n\n启动应用程序：运行启动命令，启动 Nest.js 应用程序，并访问 http://localhost:3000/cats 查看您的应用程序。\n\n$ npm run start\n\n使用nest写增删改查要使用 Nest.js 编写增删改查（CRUD）接口，您可以按照以下步骤进行操作：\n\n创建控制器：使用 Nest CLI 创建一个控制器文件，该文件将包含处理请求的方法。\n\n$ nest generate controller cats\n\n上述命令将在 src 目录下生成一个名为 cats.controller.ts 的控制器文件。\n\n定义路由和请求处理程序：在控制器文件中，使用装饰器和方法来定义路由和请求处理程序。以下是一个示例，展示了如何创建一个简单的 CRUD 接口：\n\nimport &#123; Controller, Get, Post, Put, Delete, Body, Param &#125; from &#39;@nestjs&#x2F;common&#39;;\n\n@Controller(&#39;cats&#39;)\nexport class CatsController &#123;\n  @Get()\n  findAll(): string &#123;\n    return &#39;This action returns all cats&#39;;\n  &#125;\n\n  @Get(&#39;:id&#39;)\n  findOne(@Param(&#39;id&#39;) id: string): string &#123;\n    return &#96;This action returns cat $&#123;id&#125;&#96;;\n  &#125;\n\n  @Post()\n  create(@Body() catData: any): string &#123;\n    return &#96;This action creates a new cat with the following data: $&#123;JSON.stringify(catData)&#125;&#96;;\n  &#125;\n\n  @Put(&#39;:id&#39;)\n  update(@Param(&#39;id&#39;) id: string, @Body() catData: any): string &#123;\n    return &#96;This action updates cat $&#123;id&#125; with the following data: $&#123;JSON.stringify(catData)&#125;&#96;;\n  &#125;\n\n  @Delete(&#39;:id&#39;)\n  remove(@Param(&#39;id&#39;) id: string): string &#123;\n    return &#96;This action removes cat $&#123;id&#125;&#96;;\n  &#125;\n&#125;\n\n上述代码创建了以下路由和请求处理程序：\n\nGET /cats：返回所有猫的信息。\nGET /cats/:id：根据提供的 ID 返回特定猫的信息。\nPOST /cats：创建一个新的猫，使用请求体中提供的数据。\nPUT /cats/:id：更新具有提供的 ID 的猫的信息，使用请求体中提供的数据。\nDELETE /cats/:id：删除具有提供的 ID 的猫。\n\n\n注册控制器：在模块文件中，将控制器注册到相应的模块中。您可以使用装饰器 @Module 和 controllers 属性来完成这一步骤。\n\nimport &#123; Module &#125; from &#39;@nestjs&#x2F;common&#39;;\nimport &#123; CatsController &#125; from &#39;.&#x2F;cats.controller&#39;;\n\n@Module(&#123;\n  controllers: [CatsController],\n&#125;)\nexport class AppModule &#123;&#125;\n\n上述代码将 CatsController 注册到 AppModule 模块中。\n\n启动应用程序：使用命令启动 Nest.js 应用程序。\n\n$ npm run start\n\n现在，您可以通过发送不同的 HTTP 请求（GET、POST、PUT、DELETE）到相应的路由来测试增删改查接口。\n这只是一个简单的示例，您可以根据需要扩展和定制接口的功能。Nest.js 还提供了更多的装饰器和功能，如请求体验证、异常处理、数据库集成等，以满足不同场景下的需求。\n结论Nest.js 是一个强大而灵活的框架，为 TypeScript 开发者提供了构建可扩展和模块化应用程序的便利性。它的依赖注入、模块化和路由系统等特性使得开发过程更加高效和愉快。如果你正在寻找一种简单而强大的方式来构建服务器端应用程序，不妨试试 Nest.js！\n总结以上就是对Nuxt.js，Next.js，Nest.js这三个框架的一个最简单的介绍了。主要是让大家知道这三个框架虽然名字很像，但是使用方法和应用场景却是不一样的，各自用于不同的用途和场景。 \n\nNuxt.js：\n\nNuxt.js 是一个基于 Vue.js 的通用应用框架，用于构建服务器渲染的 Vue.js 应用程序。\n它提供了一些默认配置和约定，使得开发者可以快速搭建 SSR（服务器端渲染）应用，以提供更好的 SEO（搜索引擎优化）和性能。\nNuxt.js 还集成了 Vue 路由器和 Vuex 状态管理，使得开发复杂的前端应用变得更加简单。\n\n\nNext.js：\n\nNext.js 是一个基于 React 的通用应用框架，用于构建服务器渲染的 React 应用程序。\n它提供了一些默认配置和约定，使得开发者可以快速搭建 SSR 应用，并且具有出色的性能和开发体验。\nNext.js 支持静态生成和服务器端渲染，可以根据页面的需求选择最佳的渲染方式。\n\n\nNest.js：\n\nNest.js 是一个用于构建高效、可扩展的服务器端应用程序的渐进式 Node.js 框架。\n它结合了 TypeScript（或 JavaScript）和面向对象编程的概念，使得开发者可以使用类、装饰器和依赖注入等技术来构建可维护和可测试的应用。\nNest.js 基于模块化的架构设计，提供了丰富的功能和插件，包括路由管理、中间件支持、数据库集成等。\n\n\n\n简而言之：\n\nNuxt.js 和 Next.js 都是用于构建服务器渲染应用的框架，分别基于 Vue.js 和 React。\nNuxt.js 适用于构建 Vue.js 应用程序，提供了默认的配置和约定，使得开发 SSR 应用更加简单。\nNext.js 适用于构建 React 应用程序，具有出色的性能和开发体验，并支持静态生成和服务器端渲染。\nNest.js 是一个用于构建 Node.js 服务器端应用的框架，结合了 TypeScript 和面向对象编程的概念，提供了模块化的架构设计和丰富的功能。\n\n根据我们的的需求和技术栈选择适合的框架将有助于更高效地开发应用程序。\n","slug":"node/Nuxt.js，Next.js，Nest.js傻傻分不清","date":"2023-02-02T02:46:35.000Z","categories_index":"node","tags_index":"Nuxt.js Next.js Nest.js","author_index":"前端少年汪"},{"id":"b4366d883a819ef373341f33c0b751ef","title":"回首过去2022，展望未来2023","content":"\n\n\n\n\n\n\n\n\n📒 让我们站在以年为节点的时间线上，看看2022一年时间做了什么、未来2023还能做什么\n\n年度回顾\n\n\n\n\n\n\n\n\n整体回顾本年度大概做了哪些事。\n\n关键词：稳健成长，险中求稳\n\n\n\n\n\n\n\n\n给自己一个贴切的年度关键词。这就像一本书的目录，能够让你快速想起之后的事情。\n\n  2022年可以说是疫情的最后一年也是很艰难的一年（对于打工人来说），随时都有被裁员的风险\n  还好我撑过来了，正所谓沉舟侧畔千帆，病树前头万木春。只要稳住，做好自己的事情就行了\n  随着疫情封控的消失，it行业我相信也会慢慢的回暖的。所以2023 年的目标是继续保持对技术的热情，保持持续学习，同时也要多观察，学习其它与技术无关的一些事物，经验，格局，看待事物的观点角度等等…\n\n1.学习成长\n\n\n\n\n\n\n\n\n描述本年度学习的成长或变化。\n\n2022年的学习成长或者变化总体来说，不是很大，还是在已经掌握的基础上继续深耕。\n\n前端方向上，对react技术栈的熟悉和了解程度，更深一步了。同时也阅读了几本相关的react技术栈的书籍(虽然是快速的阅读)，但是收获也是不小的，学到了以前只会运用而不懂原理的技术知识。  而vue技术栈，由于工作中一直使用的是react技术栈，导致几乎没有怎么去学习vue的相关知识，以前vue2的技术都有一些遗忘了，vue发展太快了，以至于我都有点跟不上脚步了，还好我也在茶余饭后去阅读一些大佬的技术博客，去碎片化的学习一些新技术，偶尔也逛逛官网学习一下vue3的新语法，与vue2有很大的不同，包括setup语法糖，新的双向数据绑定原理，vue中使用hooks等等，让我目不暇接，我知道纸上得来终觉浅，绝知此事要躬行这些技术点，我还得去键盘上敲一敲才行。  而在前端基础技术上，我主要是阅读一些经典的书籍，配合自己工作中的实践去提升，我主要看javaScript高级程序设计第3和第4版，犀牛书，忍者🥷秘籍等等这些书籍，还有去逛博客和论坛，这是我主要的学习方式，同时，在摸鱼的时候也会研究一下优秀框架和库的源码，看看大佬是怎么写代码的，主要还是学习编程的思想。在基础技术上，我还得继续努力，总感觉自己学的越多，不懂的就越多。  总而言之，在前端方向上 ，我还是继续保持现有的节奏，现有的技术热情，持续学习新技术，深耕！\n\n在后端方向上，以go方向为主，然后还学习了python的相关技术栈。后端和前端有很大的不同，主业是和数据做交互和处理，难度也更大，学习的方式主要是以看书看视频结合部分业务开发和自己实践。我感觉自己的实践还是有点少，很多技术掌握的不牢固，还是一知半解的样子。所以在2023年，要把学习重点放在实践上，而不是纸上谈兵。要多敲代码，多去碰壁，解决问题。  新的一年还是以Golang方向为主，看情况兼顾学习其它语言，然后还需要深入学习一下数据库方面的知识，还有中间件，网络协议，docker部署等等。。。所以后端的技术学习任务还是比较重且多的。  包括不限于以下几个方面：\n\n语言基础\norm框架\nweb框架\ngrpc框架\n中间件\nLinux，docker部署\n网络协议，http，grpc\n应用场景\n算法\n设计模式\n\n\n\n综上所述，2023年，又将是快乐的一年，还需要做很多事情，希望能如我所愿🙏\n2.体验突破\n\n\n\n\n\n\n\n\n描述本年度在心态，体验，生活和工作经验的成长或变化。\n\n  2022年，我的感受是压抑，苦中作乐！生活还算平淡和平稳，工作也算是马马虎虎吧，疫情的反反复复让人不禁烦恼，每天从做核酸，查健康码。。。到慢慢习惯。。。还好终于在2022年底，这些都过去了。\n  2023的愿望是能够多出去走走，多看看风景，被疫情三年压抑的太久了，心态都一直紧绷，如今终于能够放松一下了。一有时间，就来一趟说走就走的旅行✈️吧，不犹豫。在年轻的时候不多出去看看世界，还等什么时候呢？\n  2022年在工作中一直保持着之前做好自己的事情。冷静，做好每一个功能和需求。在2023年我希望自己能够对自己的要求更加严格，不管是对于项目还是对于自己的技术，都应该更加严格，代码质量，风格，扩展性等等，都应该比之前更加高质量了，不然也对不起我这三年工作经验了。。。不能再得过且过了（代码和人有一个能跑就行了）\n\n3.休闲娱乐描述本年度在休闲娱乐的成长或变化。\n\n  2022年哪有什么娱乐啊，无非就是在暂时没有疫情的情况下在武汉逛逛gai，楚河汉gai，东湖，然后就没有了，我的2022年的休闲娱乐不能说没有，只能说是“贫瘠”\n  在武汉待了差不多两年，感觉并没有什么好玩儿的地方，或者是我自己不太会发掘？有没有小伙伴安利一下好玩儿的地方？\n\n4.工作事业\n\n\n\n\n\n\n\n\n描述本年度在工作事业上的成长或变化。\n\n  哈哈这个感觉没啥好说的，工作上，cv大法更加娴熟了\n  摸鱼技巧🦑也提高了不少\n  和项目经理battle的技能增长了不少。。。\n  提高了写代码的速度和质量\n  积累了不少职场小tips\n  工作经验又多了一年了\n\n5.家庭生活\n\n\n\n\n\n\n\n\n描述本年度在家庭生活的成长或变化。\n\n  感觉这个也没有什么好说的，继续维护好和女朋友的关系\n  多常回家看看\n  多和父母家人打打电话\n\n6.身心健康\n\n\n\n\n\n\n\n\n描述本年度在身体健康的成长或变化。\n\n  除了得了新冠以外就没有什么病了\n  然后在2023年打算开始健身了，目前还没有制定健身计划\n  增肌增重是首要的，唉，太瘦了老是被人说\n  不知道各位小伙伴有没有什么健身的建议，本人在这个领域还是小白\n\n7.收支理财\n\n\n\n\n\n\n\n\n描述本年度在收支理财的成长或变化。\n\n  收入除了工资和接私活以外就没有其他的了，2023年打算拓展一下收入的渠道，比如自媒体，基金，直播，拍短视频，公众号等等\n  支出的话，无非就是衣食住行等等，除了3月份买了个mac算是大支出以外，其他的就都没什么较大的支出了\n  在新的一年打算好好研究一下理财方面的知识，好让钱生钱，不能只拿死工资了\n\n8.人际社交\n\n\n\n\n\n\n\n\n描述本年度在人际社交的成长或变化。\n\n  我个人觉得，朋友不必太多，特别是那种萍水相逢的。所谓君子之交淡如水，生活中绝大多数朋友与自己都是擦肩而过，只要身边始终有几个知心的朋友就足矣，不会因为不联系就淡了，而是随时可以约着一起玩耍，并且志同道合的\n  所以在2022年我认识新的朋友并不是很多，有现实中的，比如同事，或者是朋友的朋友等等，当然也有网络中的，这些都时不时的聊聊天，我觉得这样挺好的\n  新的一年还是继续保持吧，不卑不亢不强求，顺其自然。\n\nEnd：总结与期待\n\n\n\n\n\n\n\n\n给自己的今年立一些Flag(按照先后顺序的优先级排列)：\n\n  健身\n  go后端技术栈的学习\n  前端学习\n  每周一篇博客的输出\n  每月一个视频输出\n  运营好自己的自媒体账号\n  目标：全网粉丝达到1w+\n\n2022年的✅Flag完成情况\n不得不说是有点惭愧呀，扪心自问去年的技术只是完成了一半而已，这还没有立多少flag。\n2023年要好好加油了🤟🚀\n\n","slug":"年终总结/回首过去2022，展望未来2023","date":"2023-02-01T02:14:26.000Z","categories_index":"年终总结","tags_index":"生活","author_index":"前端少年汪"},{"id":"a92e00d13c8bb716cf5322fe53a36bc0","title":"electron入门实战","content":"\n前言\n\n\n\n\n\n\n\n\n我们在学习某一种技术之前，得先问几个问题：\n\n  是什么？\n  干什么？\n  优缺点？\n  怎么用？\n\n当我们明白了以上几个问题之后，那就大概率算是基本掌握了这个技术，后面再要深入就要经过大量的项目实践和源码原理的研究了。\n我本人也是做个好几个基于electron+react的项目了。在做electron项目过程中也是踩了不少坑，学习了不少关于electron的知识。这篇文章主要是介绍electron基本概念和入门级的实践。\n本文将从以下几个方面讲述electron的入门实践：\n\n什么是Electron\n\n 架构组成\n 底层技术\n\n\n Electron的应用场景\n\n Electron的优缺点\n\n如何使用Electron\n\n 创建项目\n\n\n 有哪些好用的cli脚手架\n\n\n什么是Electron这里借用官方的一句话：\n\n\n\n\n\n\n\n\n\nElectron是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入 Chromium 和 Node.js 到 二进制的 Electron 允许 保持一个 JavaScript 代码代码库并创建 在Windows上运行的跨平台应用 macOS和Linux——不需要本地开发 经验。\n架构组成一图胜千言，简而言之Electron就等于谷歌浏览器+node+系统原生APIs\n\n  Chromium 为 Electron 提供强大的 UI 渲染能力，由于 Chromium 本身跨平台，因此无需考虑代码的兼容性。最重要的是，可以使用前端三板斧进行 Electron 开发。\n  Chromium 并不具备原生 GUI 的操作能力，因此 Electron 内部集成 Node.js，编写 UI 的同时也能够调用操作系统的底层 API，例如 path、fs、crypto 等模块。\n  Native API 为 Electron 提供原生系统的 GUI 支持，借此 Electron 可以调用原生应用程序接口。\n\n\n总结起来，Chromium 负责页面 UI 渲染，Node.js 负责业务逻辑，Native API 则提供原生能力和跨平台\n底层技术Chromium 的多进程模式主要由三部分组成: 浏览器端(Browser)、渲染器端(Render)、浏览器与渲染器的通信方式(IPC)\n1.浏览器进程\n浏览器进程 Browser 只有一个，当 Chrome 打开时，进程启动。浏览器为每个渲染进程维护对应的 RenderProcessHost，负责浏览器与渲染器的交互。RenderViewHost 则是与 RenderView 对象进行交互，渲染网页的内容。浏览器与渲染器通过 IPC 进行通信。\n2.渲染进程管理\n每个渲染进程都有一个全局 RenderProcess 对象，可以管理其与父浏览器进程之间的通信，并维护其全局状态。\n3.view 管理\n每个渲染器可以维护多个 RenderView 对象，当新开标签页或弹出窗口后，渲染进程就会创建一个 RenderView，RenderView 对象与它在浏览器进程中对应的 RenderViewHost 和 Webkit 嵌入层通信，渲染出网页网页内容(这里是我们日常主要关注的地方)。\nElectron的应用场景Electron 的应用场景非常广泛，以下是一些常见的 Electron 应用场景：\n\n 桌面应用程序开发：Electron 提供了丰富的 API 和工具，使开发者能够使用 HTML、CSS 和 JavaScript 构建功能强大的桌面应用程序。这种跨平台的能力使得开发者可以在 Windows、macOS 和 Linux 等操作系统上构建一次代码，多平台运行。\n 跨平台的编辑器和开发工具：许多流行的代码编辑器和开发工具，如 Visual Studio Code、Atom 和 Slack，都是使用 Electron 构建的。Electron 提供了强大的扩展性和定制化能力，使得开发者能够创建适用于各种编程语言和开发环境的工具。\n 桌面通讯工具：Electron 可以用于构建各种类型的桌面通讯工具，如聊天应用、视频会议工具和 VoIP（Voice over IP）应用。通过利用 Chromium 的 WebRTC 技术，Electron 应用程序可以实现实时音视频通讯和数据传输。\n 桌面音乐和媒体播放器：Electron 可以用于构建音乐播放器、媒体管理工具和多媒体应用程序。通过结合 Node.js 的能力，开发者可以轻松地处理音频和视频文件、实现播放列表和音频可视化等功能。\n 桌面游戏：Electron 提供了强大的图形渲染能力和硬件加速支持，使得开发者可以构建桌面游戏应用程序。通过结合 HTML5、Canvas 和 WebGL 技术，开发者可以创建高性能的游戏，并利用 Electron 的跨平台特性将其发布到不同的操作系统上。\n\n总之，Electron 的应用场景非常广泛，适用于各种类型的桌面应用程序开发，包括编辑器、开发工具、通讯工具、音乐播放器、媒体应用和游戏等。它的跨平台特性和丰富的功能使得开发者能够快速构建出功能丰富、可扩展的桌面应用程序。\nElectron的优缺点优点：\n 跨平台支持：Electron 可以在多种操作系统上运行，包括 Windows、macOS 和 Linux 等。这使得开发者可以使用一套代码构建适用于不同平台的应用程序。\n 强大的扩展性：Electron 提供了丰富的 API 和工具，使得开发者可以轻松地扩展和定制应用程序的功能。此外，Electron 还支持各种第三方插件和库，使得开发者能够快速实现复杂的功能。\n 易于开发和调试：Electron 使用 HTML、CSS 和 JavaScript 进行开发，这些技术是广泛使用的前端开发技术。这使得开发者可以使用熟悉的技术栈进行开发，并且可以利用浏览器的调试工具进行调试。\n 高性能和硬件加速：Electron 基于 Chromium 构建，具有强大的图形渲染能力和硬件加速支持。这使得开发者可以构建高性能的应用程序，并且可以利用 GPU 加速来提高图形渲染性能。\n 社区活跃：Electron 拥有庞大的社区支持，这意味着开发者可以轻松地获取文档、示例代码和技术支持。此外，Electron 还有许多第三方插件和库可供选择，可以帮助开发者更快地构建应用程序。\n\n缺点：\n 内存占用高：Electron 应用程序通常需要占用大量的内存，这可能会导致性能问题和用户体验问题。\n 安全问题：由于 Electron 应用程序使用了 Chromium 的渲染引擎，因此可能存在一些安全问题，如 XSS 攻击和跨站点脚本攻击等。\n 文件大小较大：Electron 应用程序通常比传统的本地应用程序更大，这可能会导致下载和安装时间较长。\n 更新管理困难：由于 Electron 应用程序需要更新整个应用程序包，因此更新管理可能会比较困难，尤其是在用户数据存储和应用程序配置方面。\n\n总之， 开发者需要根据自己的需求和应用场景来选择是否使用该框架。如果 需要构建跨平台的应用程序，并且需要快速迭代和定制化功能，那么 Electron 可能是一个不错的选择。\n如何使用Electron当然是先安装啦\nnpm install --save-dev electron\n\nyarn add --dev electron\n\n创建项目然后用npm创建工程化项目\nnpm init \n\n添加脚本命令\n&#123;\n  &quot;scripts&quot;: &#123;\n    &quot;start&quot;: &quot;electron .&quot;\n  &#125;\n&#125;\n\n创建main.js\nconst &#123; app, BrowserWindow &#125; &#x3D; require(&#39;electron&#39;)\nconst path &#x3D; require(&#39;node:path&#39;)\n\nconst createWindow &#x3D; () &#x3D;&gt; &#123;\n    const mainWindow &#x3D; new BrowserWindow(&#123;\n        width: 800,\n        height: 600,\n        webPreferences: &#123;\n            preload: path.join(__dirname, &#39;preload.js&#39;)\n        &#125;\n    &#125;)\n\n    &#x2F;&#x2F; 加载 index.html\n    mainWindow.loadFile(&#39;index.html&#39;)\n\n    &#x2F;&#x2F; 打开开发工具\n    &#x2F;&#x2F; mainWindow.webContents.openDevTools()\n&#125;\n\n&#x2F;&#x2F; 这段程序将会在 Electron 结束初始化\n&#x2F;&#x2F; 和创建浏览器窗口的时候调用\n&#x2F;&#x2F; 部分 API 在 ready 事件触发后才能使用。\napp.whenReady().then(() &#x3D;&gt; &#123;\n    createWindow()\n\n    app.on(&#39;activate&#39;, () &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 在 macOS 系统内, 如果没有已开启的应用窗口\n        &#x2F;&#x2F; 点击托盘图标时通常会重新创建一个新窗口\n        if (BrowserWindow.getAllWindows().length &#x3D;&#x3D;&#x3D; 0) createWindow()\n    &#125;)\n&#125;)\n\n&#x2F;&#x2F; 除了 macOS 外，当所有窗口都被关闭的时候退出程序。 因此, 通常\n&#x2F;&#x2F; 对应用程序和它们的菜单栏来说应该时刻保持激活状态, \n&#x2F;&#x2F; 直到用户使用 Cmd + Q 明确退出\napp.on(&#39;window-all-closed&#39;, () &#x3D;&gt; &#123;\n    if (process.platform !&#x3D;&#x3D; &#39;darwin&#39;) app.quit()\n&#125;)\n\n&#x2F;&#x2F; 在当前文件中你可以引入所有的主进程代码\n&#x2F;&#x2F; 也可以拆分成几个文件，然后用 require 导入。\n\n有哪些好用的cli脚手架以下是几个常用的 Electron 脚手架，可以帮助快速开始 Electron 应用程序的开发：\n\n Electron Forge：Electron Forge 是一个功能强大的命令行工具和脚手架，可以帮助 初始化、构建和打包 Electron 应用程序。它提供了一套简单的命令行接口，使得创建和管理 Electron 项目变得更加容易。\n Electron React Boilerplate：这是一个基于 Electron 和 React 的脚手架项目，提供了一个现代化的开发环境和项目结构。它集成了许多常用的工具和库，如 Webpack、Babel、Redux 等，使得开发 Electron 应用程序变得更加高效和便捷。\n Electron Vue：如果 喜欢使用 Vue.js 进行开发，那么 Electron Vue 是一个不错的选择。它提供了一个基于 Vue.js 的 Electron 开发模板，集成了许多常用的工具和插件，如 Vue Router、Vuex 等，使得开发 Electron 应用程序与 Vue.js 更加无缝衔接。\n Electron-Boilerplate：这是一个简单而灵活的 Electron 脚手架，提供了一个基本的项目结构和开发工作流程。它没有过多的集成和预设，适合那些希望从头开始构建自己的 Electron 应用程序的开发者。\n Electron-React-Boilerplate：这是一个基于 Electron 和 React 的脚手架项目，提供了一个完整的开发环境和项目结构。它集成了许多常用的工具和库，如 Webpack、Babel、React Router 等，使得开发 Electron 应用程序变得更加高效和便捷。\n\n这些脚手架都有活跃的社区支持和文档， 可以根据自己的需求选择最适合 的脚手架进行开发。无论 是使用原生 JavaScript、React、Vue.js 还是其他前端框架，都可以找到相应的 Electron 脚手架来帮助 快速启动项目。\n","slug":"跨平台/electron入门实战","date":"2023-01-10T17:46:35.000Z","categories_index":"electron","tags_index":"electron","author_index":"前端少年汪"},{"id":"67e534ae18855eb1a7fe1ada975d8605","title":"深入理解Redux数据更新机制：数据流管理的核心原理","content":"前言在现代的前端开发中，数据管理是一个至关重要的问题。随着应用程序的复杂性不断增加，我们需要一种有效的方式来管理数据的流动和更新。Redux作为一个流行的状态管理库，提供了一种简洁而强大的数据更新机制，成为了许多开发者的首选。\n本文将深入探讨Redux的数据更新机制，帮助读者更好地理解Redux的工作原理并应用于实际项目中。Redux是一个非常流行的JavaScript状态管理库，它可以帮助我们更好地组织和管理React应用程序中的数据流。本文将介绍Redux的数据更新机制，并讨论如何使用它来管理应用程序中的状态。\nRedux的基本概念在深入Redux的数据更新机制之前，让我们先来了解一下Redux的基本概念。Redux的核心概念包括：\n\nState：应用程序中存储数据的地方，它是一个对象，包含整个应用程序的状态。\nAction：定义应用程序中发生的操作的对象，它是一个简单的JavaScript对象，包含一个type属性和一些其他数据。\nReducer：Redux中管理state的函数，每个reducer负责处理一个特定的部分的state，并返回一个新的state。\nStore：Redux中的核心对象，它负责保存整个应用程序的state，并提供一些方法来访问和更新state。\n\n关键概念接下来，我们将重点介绍Redux数据更新机制的两个关键概念：纯函数和不可变性。\n纯函数纯函数是指一个函数的输出只依赖于输入，而不受外部状态的影响。在Redux中，reducer就是一个纯函数，它接收当前的state和一个action作为参数，然后返回一个新的state。由于reducer是纯函数，所以我们可以轻松地测试和调试它，而且可以方便地组合多个reducer来处理复杂的数据更新逻辑。\n不可变性不可变性是指数据一旦创建就不能被修改。在Redux中，我们通过创建新的state对象来实现不可变性。当一个action触发数据更新时，reducer会返回一个全新的state对象，而不是直接修改原来的state。这种不可变性的做法有助于我们追踪数据的变化，避免出现意外的副作用，同时也提高了性能。\n数据更新机制Redux的数据更新机制遵循以下步骤：\n\n应用程序触发一个action。\nStore将该action转发给所有已注册的Reducer。\n每个Reducer都检查是否与该action相匹配。\n如果Reducer匹配该action，则它会使用该action更新相应的state，并返回一个新的state。\nStore使用新的state替换旧的state，以便在应用程序中进行更新。\n\n让我们看一下这个过程在代码中是如何实现的。首先，我们需要定义一些action和reducer。\n&#x2F;&#x2F; Action\nconst incrementCounter &#x3D; () &#x3D;&gt; &#123;\n  return &#123;\n    type: &#39;INCREMENT_COUNTER&#39;,\n    payload: &#123;\n      value: 1\n    &#125;\n  &#125;;\n&#125;;\n\n&#x2F;&#x2F; Reducer\nconst counterReducer &#x3D; (state &#x3D; &#123; count: 0 &#125;, action) &#x3D;&gt; &#123;\n  switch (action.type) &#123;\n    case &#39;INCREMENT_COUNTER&#39;:\n      return &#123;\n        ...state,\n        count: state.count + action.payload.value\n      &#125;;\n    default:\n      return state;\n  &#125;\n&#125;;\n\n在上述代码中，我们定义了一个名为incrementCounter的action和一个名为counterReducer的reducer。incrementCounter用于增加计数器的值，counterReducer用于处理与计数器相关的state更新。\n接下来，我们需要创建一个Store，并将Reducer注册到Store中。\nimport &#123; createStore, combineReducers &#125; from &#39;redux&#39;;\n\nconst rootReducer &#x3D; combineReducers(&#123;\n  counter: counterReducer\n&#125;);\n\nconst store &#x3D; createStore(rootReducer);\n\n在上述代码中，我们使用combineReducers函数将counterReducer合并为一个根reducer，并使用createStore函数创建一个Store，该Store使用根reducer作为参数。\n最后，我们可以在应用程序中分发一个action，以触发state的更新。\nstore.dispatch(incrementCounter());\n\n在上述代码中，我们使用store.dispatch函数分发一个incrementCounter action，该action将触发counterReducer来更新与计数器相关的state。\n通过上述步骤，我们就完成了Redux的数据更新机制。当我们需要更新应用程序中的state时，只需分发一个与该state相关的action即可。\nRedux的数据流是单向的，从store开始，通过dispatch一个action来触发数据的更新，然后通过reducer来更新store中的数据。这个过程是可预测和可控的，使得我们能够更好地管理应用程序的状态。\n在实际应用中，我们可以通过使用Redux提供的辅助函数来简化数据更新的过程。比如，我们可以使用combineReducers函数来合并多个reducer，使用connect函数来将组件和store连接起来，使用dispatch函数来触发数据的更新。\n此外，Redux还提供了中间件机制，可以在数据更新的过程中添加额外的逻辑。中间件可以用来处理异步操作、日志记录、错误处理等。通过使用中间件，我们可以更好地控制数据的流动，提高应用程序的可维护性和可扩展性。\nconnect在React和Redux应用程序中，react-redux库提供了一个名为connect的高阶函数，用于连接React组件与Redux的Store。通过使用connect函数，我们可以方便地将Redux中的状态 (state) 和动作 (actions) 绑定到React组件的属性 (props) 上。\nconnect函数的基本语法如下：\nconnect(mapStateToProps, mapDispatchToProps)(Component);\n\n其中，mapStateToProps 和 mapDispatchToProps 是两个可选的参数，它们分别用于指定将Redux状态映射到组件的属性上，以及将Redux动作映射到组件的属性上。Component 是要连接的React组件。\n让我们更详细地了解connect函数的两个参数：\n\nmapStateToProps：这是一个函数，它接收Redux的state作为参数，并返回一个对象，该对象描述了要映射到组件属性上的状态。在这个函数中，我们可以选择性地筛选和转换Redux的state，以适应组件的需求。例如：\nconst mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;\n  return &#123;\n    count: state.counter.count,\n    todos: state.todos.items\n  &#125;;\n&#125;;\n\n在上述代码中，mapStateToProps 函数映射了 Redux 的 counter 状态下的 count 属性和 todos 状态下的 items 属性到组件的属性上。\n\nmapDispatchToProps：这也是一个函数，它接收一个 dispatch 参数，并返回一个对象，该对象描述了要映射到组件属性上的动作。dispatch 是 Redux Store 的一个方法，用于分发动作。在 mapDispatchToProps 中，我们可以将动作包装成回调函数或者直接将它们分发到 Redux。例如：\nimport &#123; incrementCounter, addTodo &#125; from &#39;.&#x2F;actions&#39;;\n\nconst mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;\n  return &#123;\n    increment: () &#x3D;&gt; dispatch(incrementCounter()),\n    addTodo: (text) &#x3D;&gt; dispatch(addTodo(text))\n  &#125;;\n&#125;;\n\n在上述代码中，mapDispatchToProps 函数映射了 incrementCounter 和 addTodo 动作到组件的属性上，以便在组件中可以通过调用 this.props.increment() 和 this.props.addTodo() 来分发这两个动作。\n\n\n通过使用 connect 函数，我们可以将 Redux 的状态和动作与 React 组件连接起来：\nimport &#123; connect &#125; from &#39;react-redux&#39;;\nimport &#123; incrementCounter, addTodo &#125; from &#39;.&#x2F;actions&#39;;\nimport MyComponent from &#39;.&#x2F;MyComponent&#39;;\n\nconst mapStateToProps &#x3D; (state) &#x3D;&gt; &#123;\n  return &#123;\n    count: state.counter.count,\n    todos: state.todos.items\n  &#125;;\n&#125;;\n\nconst mapDispatchToProps &#x3D; (dispatch) &#x3D;&gt; &#123;\n  return &#123;\n    increment: () &#x3D;&gt; dispatch(incrementCounter()),\n    addTodo: (text) &#x3D;&gt; dispatch(addTodo(text))\n  &#125;;\n&#125;;\n\nexport default connect(mapStateToProps, mapDispatchToProps)(MyComponent);\n\n在上述代码中，我们首先导入 connect 函数和动作 (actions)，然后定义 mapStateToProps 和 mapDispatchToProps 函数。最后，我们使用 connect 函数将 Redux 的状态和动作连接到 MyComponent 组件上，并通过 export default 导出连接后的组件。\n通过以上步骤，我们就可以在 MyComponent 组件中通过 this.props.count 和 this.props.todos 访问 Redux 的状态，并且可以通过 this.props.increment() 和 this.props.addTodo(text) 分发 Redux 的动作。\n connect 函数是 react-redux 库中用于连接 React 组件与 Redux 的核心函数。它通过将 Redux 的状态和动作映射到组件属性上，使得我们可以方便地在组件中访问和分发 Redux 的数据和操作。这样，我们可以更好地利用 Redux 管理 React 应用程序的状态和数据流。\n总结Redux的数据更新机制是非常简单和直接的，它通过action、reducer和Store这些核心概念来实现。当我们分发一个action时，Redux会自动将该action转发给所有已注册的reducer，并使用新的state替换旧的state，从而实现应用程序中的数据更新。通过Redux的数据更新机制，我们可以更好地管理React应用程序中的状态，提高代码的可维护性和可扩展性。\n","slug":"react/深入理解Redux数据更新机制：数据流管理的核心原理","date":"2023-01-10T14:46:35.000Z","categories_index":"react","tags_index":"react redux","author_index":"前端少年汪"},{"id":"06bcbca25b590a41890b9b1b71d4205b","title":"一文带你了解跨域的前因后果和解决方案","content":"\n什么是跨域在了解跨域之前，我们必须要了解一下同源策略。跨域问题其实就是浏览器的同源策略造成的。\n同源策略同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：协议、端口号、域名必须一致。\n\n\n\n\n\n\n\n\n\n跨源资源共享（[CORS]，或通俗地译为跨域资源共享）是一种基于 [HTTP] 头的机制，该机制通过允许服务器标示除了它自己以外的其他[源] （域、协议或端口），使得浏览器允许这些源访问加载自己的资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的“预检”请求。在预检中，浏览器发送的头中标示有 HTTP 方法和真实请求中会用到的头。\n为什么会产生跨域下表给出了与 URL http://wmq.com/dir/page.html 的源进行对比的示例:\n\n\n\nURL\n是否跨域\n原因\n\n\n\nhttp://wmq.com/dir/page.html\n同源\n完全相同\n\n\nhttp://wmq.com/dir/inner/another.html\n同源\n只有路径不同\n\n\nhttps://wmq.com/secure.html\n跨域\n协议不同\n\n\nhttp://wmq.com:81/dir/etc.html\n跨域\n端口不同 ( http:// 默认端口是80)\n\n\nhttp://news.company.com/dir/other.html\n跨域\n主机不同\n\n\n同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。\n同源政策主要限制了三个方面：\n\n  当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。\n  当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。\n  当前域下 ajax 无法发送跨域请求。\n\n源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。\n有哪些解决跨域的办法CORS CORS: 通过设置服务器端的响应头来允许跨域请求。这需要在服务器端进行配置，以允许特定的来源访问资源。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：\nconst express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);\n\n减少OPTIONS请求次数在跨域请求中，浏览器会自动处理一些非简单请求的预检流程，这包括”预检请求”（也被称为CORS预检请求）和”OPTIONS请求”。预检请求是发起一个HTTP OPTIONS请求到服务器，以确认目标资源是否支持跨域。这种机制是为了兼容同源策略而产生的，但有时这种额外的请求会导致性能问题。\n为了减少这种非必要的 OPTIONS 请求次数，可以采取以下几种方法：\n配置服务器: 对服务器进行配置以允许来自特定来源的跨域请求。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS响应头：\nconst express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);\n\n    \n\n在这个例子中，我们添加了一个新的响应头Access-Control-Allow-Methods，其中包含了GET, POST, PUT, DELETE等简单请求方法，这样浏览器对于简单跨域请求就不会再发送预检请求了。\nCORS中Cookie相关问题在CORS中，Cookie是一个重要的安全特性。如果服务器端设置了允许跨域请求的响应头，那么客户端就可以在跨域请求中携带Cookie。但是，如果服务器端没有设置允许跨域请求的响应头，那么客户端就无法在跨域请求中携带Cookie。\n为了解决这个问题，可以在服务器端设置允许跨域请求的响应头，以允许客户端携带Cookie。例如，在Node.js的Express框架中，可以使用以下代码来设置CORS：\nconst express &#x3D; require(&#39;express&#39;);\nconst app &#x3D; express();\n\napp.use((req, res, next) &#x3D;&gt; &#123;\n  res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;); &#x2F;&#x2F; 允许所有来源访问\n  res.header(&#39;Access-Control-Allow-Headers&#39;, &#39;Origin, X-Requested-With, Content-Type, Accept, Cookie&#39;); &#x2F;&#x2F; 允许的请求头\n  res.header(&#39;Access-Control-Allow-Methods&#39;, &#39;GET, POST, PUT, DELETE, OPTIONS&#39;); &#x2F;&#x2F; 允许的请求方法\n  next();\n&#125;);\n\n&#x2F;&#x2F; 其他路由和中间件\n\napp.listen(3000, () &#x3D;&gt; &#123;\n  console.log(&#39;Server is running on port 3000&#39;);\n&#125;);\n\n\n在这个例子中，我们添加了一个新的响应头Access-Control-Allow-Headers，其中包含了Cookie。这样，客户端就可以在跨域请求中携带Cookie了。\n也就是说上面两个问题的解决方法是一样的，都是通过在服务端设置添加一个新的响应头Access-Control-Allow-Headers\nJSONPjsonp的原理就是利用&lt;script&gt;标签没有跨域限制，通过&lt;script&gt;标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。\n1）原生JS实现：\n&lt;script&gt;\n    var script &#x3D; document.createElement(&#39;script&#39;);\n    script.type &#x3D; &#39;text&#x2F;javascript&#39;;\n    &#x2F;&#x2F; 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数\n    script.src &#x3D; &#39;http:&#x2F;&#x2F;www.domain1.com:8080&#x2F;login?user&#x3D;admin&amp;callback&#x3D;handleCallback&#39;;\n    document.head.appendChild(script);\n    &#x2F;&#x2F; 回调执行函数\n    function handleCallback(res) &#123;\n        alert(JSON.stringify(res));\n    &#125;\n &lt;&#x2F;script&gt;\n\n服务端返回如下（返回时即执行全局函数）：\nhandleCallback(&#123;&quot;success&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)\n\n2）Vue axios实现：\nthis.$http &#x3D; axios;\nthis.$http.jsonp(&#39;http:&#x2F;&#x2F;www.domain2.com:8080&#x2F;login&#39;, &#123;\n    params: &#123;&#125;,\n    jsonp: &#39;handleCallback&#39;\n&#125;).then((res) &#x3D;&gt; &#123;\n    console.log(res); \n&#125;)\n\n后端node.js代码：\nvar querystring &#x3D; require(&#39;querystring&#39;);\nvar http &#x3D; require(&#39;http&#39;);\nvar server &#x3D; http.createServer();\nserver.on(&#39;request&#39;, function(req, res) &#123;\n    var params &#x3D; querystring.parse(req.url.split(&#39;?&#39;)[1]);\n    var fn &#x3D; params.callback;\n    &#x2F;&#x2F; jsonp返回设置\n    res.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;javascript&#39; &#125;);\n    res.write(fn + &#39;(&#39; + JSON.stringify(params) + &#39;)&#39;);\n    res.end();\n&#125;);\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n\nJSONP的缺点：\n\n  具有局限性， 仅支持get方法\n  不安全，可能会遭受XSS攻击\n\npostMessage 跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：\n\n  页面和其打开的新窗口的数据传递\n  多窗口之间消息传递\n  页面与嵌套的iframe消息传递\n  上面三个场景的跨域数据传递\n\n用法：postMessage(data,origin)方法接受两个参数：\n\n  data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。\n  origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。\n\n1）a.html：(domain1.com/a.html)\n&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;       \n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    iframe.onload &#x3D; function() &#123;\n        var data &#x3D; &#123;\n            name: &#39;aym&#39;\n        &#125;;\n        &#x2F;&#x2F; 向domain2传送跨域数据\n        iframe.contentWindow.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain2.com&#39;);\n    &#125;;\n    &#x2F;&#x2F; 接受domain2返回数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain2 ---&gt; &#39; + e.data);\n    &#125;, false);\n&lt;&#x2F;script&gt;\n\n2）b.html：(domain2.com/b.html)\n&lt;script&gt;\n    &#x2F;&#x2F; 接收domain1的数据\n    window.addEventListener(&#39;message&#39;, function(e) &#123;\n        alert(&#39;data from domain1 ---&gt; &#39; + e.data);\n        var data &#x3D; JSON.parse(e.data);\n        if (data) &#123;\n            data.number &#x3D; 16;\n            &#x2F;&#x2F; 处理后再发回domain1\n            window.parent.postMessage(JSON.stringify(data), &#39;http:&#x2F;&#x2F;www.domain1.com&#39;);\n        &#125;\n    &#125;, false);\n&lt;&#x2F;script&gt;\n\nnginx代理跨域nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。\n1）nginx配置解决iconfont跨域\n浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\nlocation &#x2F; &#123;\n  add_header Access-Control-Allow-Origin *;\n&#125;\n\n2）nginx反向代理接口跨域\n跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。\n实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。\nnginx具体配置：\n#proxy服务器\nserver &#123;\n    listen       81;\n    server_name  www.domain1.com;\n    location &#x2F; &#123;\n        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    &#125;\n&#125;\n\nnodejs 中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。\n1）非vue框架的跨域\n使用node + express + http-proxy-middleware搭建一个proxy服务器。\n\n  前端代码：\n\nvar xhr &#x3D; new XMLHttpRequest();\n&#x2F;&#x2F; 前端开关：浏览器是否读写cookie\nxhr.withCredentials &#x3D; true;\n&#x2F;&#x2F; 访问http-proxy-middleware代理服务器\nxhr.open(&#39;get&#39;, &#39;http:&#x2F;&#x2F;www.domain1.com:3000&#x2F;login?user&#x3D;admin&#39;, true);\nxhr.send();\n\n\n  中间件服务器代码：\n\nvar express &#x3D; require(&#39;express&#39;);\nvar proxy &#x3D; require(&#39;http-proxy-middleware&#39;);\nvar app &#x3D; express();\napp.use(&#39;&#x2F;&#39;, proxy(&#123;\n    &#x2F;&#x2F; 代理跨域目标接口\n    target: &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;,\n    changeOrigin: true,\n    &#x2F;&#x2F; 修改响应头信息，实现跨域并允许带cookie\n    onProxyRes: function(proxyRes, req, res) &#123;\n        res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;http:&#x2F;&#x2F;www.domain1.com&#39;);\n        res.header(&#39;Access-Control-Allow-Credentials&#39;, &#39;true&#39;);\n    &#125;,\n    &#x2F;&#x2F; 修改响应信息中的cookie域名\n    cookieDomainRewrite: &#39;www.domain1.com&#39;  &#x2F;&#x2F; 可以为false，表示不修改\n&#125;));\napp.listen(3000);\nconsole.log(&#39;Proxy server is listen at port 3000...&#39;);\n\n2）vue框架的跨域\nnode + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。\nwebpack.config.js部分配置：\nmodule.exports &#x3D; &#123;\n    entry: &#123;&#125;,\n    module: &#123;&#125;,\n    ...\n    devServer: &#123;\n        historyApiFallback: true,\n        proxy: [&#123;\n            context: &#39;&#x2F;login&#39;,\n            target: &#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;,  &#x2F;&#x2F; 代理跨域目标接口\n            changeOrigin: true,\n            secure: false,  &#x2F;&#x2F; 当代理某些https服务报错时用\n            cookieDomainRewrite: &#39;www.domain1.com&#39;  &#x2F;&#x2F; 可以为false，表示不修改\n        &#125;],\n        noInfo: true\n    &#125;\n&#125;\n\ndocument.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。\n1）父窗口：(domain.com/a.html)\n&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;child.domain.com&#x2F;b.html&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    document.domain &#x3D; &#39;domain.com&#39;;\n    var user &#x3D; &#39;admin&#39;;\n&lt;&#x2F;script&gt;\n\n1）子窗口：(child.domain.com/a.html)\n&lt;script&gt;\n    document.domain &#x3D; &#39;domain.com&#39;;\n    &#x2F;&#x2F; 获取父窗口中变量\n    console.log(&#39;get js data from parent ---&gt; &#39; + window.parent.user);\n&lt;&#x2F;script&gt;\n\nlocation.hash + iframe跨域实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。\n具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。\n1）a.html：(domain1.com/a.html)\n&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 向b.html传hash值\n    setTimeout(function() &#123;\n        iframe.src &#x3D; iframe.src + &#39;#user&#x3D;admin&#39;;\n    &#125;, 1000);\n    \n    &#x2F;&#x2F; 开放给同域c.html的回调方法\n    function onCallback(res) &#123;\n        alert(&#39;data from c.html ---&gt; &#39; + res);\n    &#125;\n&lt;&#x2F;script&gt;\n\n2）b.html：(.domain2.com/b.html)\n&lt;iframe id&#x3D;&quot;iframe&quot; src&#x3D;&quot;http:&#x2F;&#x2F;www.domain1.com&#x2F;c.html&quot; style&#x3D;&quot;display:none;&quot;&gt;&lt;&#x2F;iframe&gt;\n&lt;script&gt;\n    var iframe &#x3D; document.getElementById(&#39;iframe&#39;);\n    &#x2F;&#x2F; 监听a.html传来的hash值，再传给c.html\n    window.onhashchange &#x3D; function () &#123;\n        iframe.src &#x3D; iframe.src + location.hash;\n    &#125;;\n&lt;&#x2F;script&gt;\n\n3）c.html：(http://www.domain1.com/c.html)\n&lt;script&gt;\n    &#x2F;&#x2F; 监听b.html传来的hash值\n    window.onhashchange &#x3D; function () &#123;\n        &#x2F;&#x2F; 再通过操作同域a.html的js回调，将结果传回\n        window.parent.parent.onCallback(&#39;hello: &#39; + location.hash.replace(&#39;#user&#x3D;&#39;, &#39;&#39;));\n    &#125;;\n&lt;&#x2F;script&gt;\n\nwindow.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n1）a.html：(domain1.com/a.html)\nvar proxy &#x3D; function(url, callback) &#123;\n    var state &#x3D; 0;\n    var iframe &#x3D; document.createElement(&#39;iframe&#39;);\n    &#x2F;&#x2F; 加载跨域页面\n    iframe.src &#x3D; url;\n    &#x2F;&#x2F; onload事件会触发2次，第1次加载跨域页，并留存数据于window.name\n    iframe.onload &#x3D; function() &#123;\n        if (state &#x3D;&#x3D;&#x3D; 1) &#123;\n            &#x2F;&#x2F; 第2次onload(同域proxy页)成功后，读取同域window.name中数据\n            callback(iframe.contentWindow.name);\n            destoryFrame();\n        &#125; else if (state &#x3D;&#x3D;&#x3D; 0) &#123;\n            &#x2F;&#x2F; 第1次onload(跨域页)成功后，切换到同域代理页面\n            iframe.contentWindow.location &#x3D; &#39;http:&#x2F;&#x2F;www.domain1.com&#x2F;proxy.html&#39;;\n            state &#x3D; 1;\n        &#125;\n    &#125;;\n    document.body.appendChild(iframe);\n    &#x2F;&#x2F; 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）\n    function destoryFrame() &#123;\n        iframe.contentWindow.document.write(&#39;&#39;);\n        iframe.contentWindow.close();\n        document.body.removeChild(iframe);\n    &#125;\n&#125;;\n&#x2F;&#x2F; 请求跨域b页面数据\nproxy(&#39;http:&#x2F;&#x2F;www.domain2.com&#x2F;b.html&#39;, function(data)&#123;\n    alert(data);\n&#125;);\n\n2）proxy.html：(domain1.com/proxy.html)\n中间代理页，与a.html同域，内容为空即可。\n3）b.html：(domain2.com/b.html)\n&lt;script&gt;\n    window.name &#x3D; &#39;This is domain2 data!&#39;;\n&lt;&#x2F;script&gt;\n\n通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。\nWebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。\n原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。\n1）前端代码：\n&lt;div&gt;user input：&lt;input type&#x3D;&quot;text&quot;&gt;&lt;&#x2F;div&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;socket.io&#x2F;2.2.0&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\nvar socket &#x3D; io(&#39;http:&#x2F;&#x2F;www.domain2.com:8080&#39;);\n&#x2F;&#x2F; 连接成功处理\nsocket.on(&#39;connect&#39;, function() &#123;\n    &#x2F;&#x2F; 监听服务端消息\n    socket.on(&#39;message&#39;, function(msg) &#123;\n        console.log(&#39;data from server: ---&gt; &#39; + msg); \n    &#125;);\n    &#x2F;&#x2F; 监听服务端关闭\n    socket.on(&#39;disconnect&#39;, function() &#123; \n        console.log(&#39;Server socket has closed.&#39;); \n    &#125;);\n&#125;);\ndocument.getElementsByTagName(&#39;input&#39;)[0].onblur &#x3D; function() &#123;\n    socket.send(this.value);\n&#125;;\n&lt;&#x2F;script&gt;\n\nNodejs socket后台：var http &#x3D; require(&#39;http&#39;);\nvar socket &#x3D; require(&#39;socket.io&#39;);\n&#x2F;&#x2F; 启http服务\nvar server &#x3D; http.createServer(function(req, res) &#123;\n    res.writeHead(200, &#123;\n        &#39;Content-type&#39;: &#39;text&#x2F;html&#39;\n    &#125;);\n    res.end();\n&#125;);\nserver.listen(&#39;8080&#39;);\nconsole.log(&#39;Server is running at port 8080...&#39;);\n&#x2F;&#x2F; 监听socket连接\nsocket.listen(server).on(&#39;connection&#39;, function(client) &#123;\n    &#x2F;&#x2F; 接收信息\n    client.on(&#39;message&#39;, function(msg) &#123;\n        client.send(&#39;hello：&#39; + msg);\n        console.log(&#39;data from client: ---&gt; &#39; + msg);\n    &#125;);\n    &#x2F;&#x2F; 断开处理\n    client.on(&#39;disconnect&#39;, function() &#123;\n        console.log(&#39;Client socket has closed.&#39;); \n    &#125;);\n&#125;);\n\n总结以上就是一些为什么会产生跨域和一些解决跨域的方法。\n","slug":"js/一文带你了解跨域的前因后果和解决方案","date":"2023-01-04T14:46:35.000Z","categories_index":"跨域,前端","tags_index":"浏览器 跨域","author_index":"前端少年汪"},{"id":"83d359dd0111440bbb3e9ab60e3adbe5","title":"如何实现一个WebComponent组件","content":"\n\n\n\n\n\n\n\n\n作为开发者，我们都知道尽可能多的重用代码是一个好主意。这对于自定义标记结构来说通常不是那么容易 — 想想复杂的 HTML（以及相关的样式和脚本），有时你不得不写代码来呈现自定义 UI 控件，并且如果你不小心的话，多次使用它们会使你的页面变得一团糟。\n什么是Web Conmponent组件Web Component 是一套不同的用于构建可重用并封装化的组件化技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 web 应用中使用它们。它是由一组标准规范组成的。其中最重要的规范包括 Custom Elements、Shadow DOM、HTML Templates 和 HTML Imports。\nWeb Components 旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。以下参考MDN文档:\n\n  Custom element（自定义元素） ：一组 JavaScript API，允许你定义 custom elements 及其行为，然后可以在你的用户界面中按照需要使用它们。\n  Shadow DOM（影子 DOM） ：一组 JavaScript API，用于将封装的“影子”DOM 树附加到元素（与主文档 DOM 分开呈现）并控制其关联的功能。通过这种方式，你可以保持元素的功能私有，这样它们就可以被脚本化和样式化，而不用担心与文档的其他部分发生冲突。\n  HTML template（HTML 模板）：  &lt;template&gt;  和 &lt;slot&gt; 元素使你可以编写不在呈现页面中显示的标记模板。然后它们可以作为自定义元素结构的基础被多次重用。\n\n如何创建并且使用web组件的详细步骤和方法当创建一个 Web Component 组件时，需要执行以下详细步骤：\n\n创建组件类：\n\n  使用 JavaScript 或 TypeScript 创建一个类来定义你的组件。\n  组件类应该继承自 HTMLElement 或其子类。这样可以确保你的组件拥有所有标准的 DOM 元素功能和属性。\n\n\n定义组件模板：\n\n  使用 HTML 和 CSS 来定义组件的外观和布局。\n  可以在组件类中通过 innerHTML 或 template 属性设置组件的模板。\n  模板可以包含任何常规的 HTML、CSS 和 JavaScript 代码，用于构建组件的结构和样式。\n\n\n添加生命周期方法：\n\n  生命周期方法是在组件生命周期的不同阶段被调用的特殊方法。\n\n常用的生命周期方法包括：\n\n  connectedCallback()：当组件被插入到文档中时调用。可以在此方法中执行初始化操作，如添加事件监听器或进行初始渲染。\n  disconnectedCallback()：当组件从文档中移除时调用。可以在此方法中进行清理操作，如移除事件监听器或释放资源。\n  attributeChangedCallback(attributeName, oldValue, newValue)：当组件的属性值发生变化时调用。可以在此方法中处理属性变化的逻辑。\n\n\n\n\n实现组件功能：\n\n  在组件类中添加方法和属性，实现组件的功能。\n  可以使用 JavaScript 或其他库/框架来增强组件的行为。例如，你可以添加事件处理程序、数据绑定逻辑、动态更新组件等。\n\n\n注册组件：\n\n  使用 customElements.define 方法将组件类注册为一个自定义元素。\n  通过调用 customElements.define(tagName, componentClass)，将组件类映射到特定的标签名称。\n  这样，当在 HTML 页面中使用该标签时，浏览器会自动创建组件的实例并进行渲染。\n\n\n使用组件：\n\n  在 HTML 文档中使用组件标签，即可在页面中实例化和展示组件。\n  在标签中可以添加属性，这些属性可以在组件类中通过 attributeChangedCallback() 方法进行捕获和处理。\n\n\n\n  我这里实现了一个最简单的web Component组件的例子:\n  \n&#x2F;&#x2F; 创建组件类\nclass MyComponent extends HTMLElement &#123;\n    constructor() &#123;\n        super();\n    &#125;\n\n    connectedCallback() &#123;\n        this.innerHTML &#x3D; &#96;\n      &lt;div&gt;\n        &lt;h1&gt;Hello, Web Component!&lt;&#x2F;h1&gt;\n      &lt;&#x2F;div&gt;\n    &#96;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 注册组件\ncustomElements.define(&#39;my-component&#39;, MyComponent);\n \n  &lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;my-component&gt;&lt;&#x2F;my-component&gt;\n&lt;script src&#x3D;&quot;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n总结Web Component 的优势在于提高了前端开发的模块化程度、可维护性和可重用性。它使得开发者能够更加专注于组件级别的开发，减少了整体页面的复杂度，同时也为跨团队协作和组件库的构建提供了更好的支持。总的来说，Web Component 是现代前端开发中非常重要的一环，有助于构建更加灵活、可靠和可维护的 Web 应用。\n","slug":"js/如何实现一个WebComponent组件","date":"2022-11-04T14:46:35.000Z","categories_index":"前端,js,html","tags_index":"web组件","author_index":"前端少年汪"},{"id":"a7e01fb13cc6c5d9b1c60619ae2f3415","title":"一个基于vite构建的vue3+pinia+ts+elementUI plus的初始化开箱即用的项目模版","content":"前言vue3如今已经成为默认版本了，相信大多数公司已经全面拥抱vue3了。\n而Vite作为新一代的新型前端构建工具，使用它能够显著提升前端开发体验。\n什么是Vite这里借用官方的介绍：\n\n  一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。\n  一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。\n\nVite的优势\n  开箱即用\n  具备插件API和JS API\n\n\n\n\n  高度的可扩展性\n  热更新\n\n\n\n\n  高效，快速\n\n搭建第一个 Vite 项目兼容性注意\nVite 需要 Node.js 版本 &gt;= 12.0.0。然而，有些模板需要依赖更高的 Node 版本才能正常运行，当你的包管理器发出警告时，请注意升级你的 Node 版本。\nNPM:\nnpm create vite@latest\nnpm create @vitejs&#x2F;app \nnpm init vite@latest\nnpm init @vitejs&#x2F;app \n\n\nYarn:\nyarn create vite\n\n\n创建Vite项目的命令有很多，大同小异，但是我推荐使用 yarn的方式，谁用谁知道，命令简洁，速度更快，当然也有其它的方式，可以看一下官网的推荐方式，这个选择自己喜欢的就好了\n# npm 6.x\nnpm create vite@latest my-vue-app --template vue\n\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app -- --template vue\n\n初始化好之后的目录：\n│  ├─public # 静态资源目录\n│  │      favicon.ico \n│  │\n│  ├─src\n│  │  │  App.vue # 入口vue文件\n│  │  │  main.ts # 入口文件\n│  │  ├─assets # 资源文件目录\n│  │  │      logo.png\n│  │  │\n│  │  └─components # 组件文件目录\n│  │         HelloWorld.vue\n│  │\n│  │ .gitignore\n│  │ index.html # Vite项目的入口文件 \n│  │ package.json\n│  │ README.md\n│  │ tsconfig.json # tsconfig配置文件\n│  │ vite.config.ts # vite配置文件\n\n执行：npm i或者yarn安装依赖，再执行 npm run dev 或者 yarn dev 打开浏览器输入http://localhost:3000\n即可看到\n\n这样一个vue3+vite+ts的项目初始化就完成了\n运行项目不会默认打开浏览器,需要在package.json里面 ,在vite 后面加上–open\n\n安装vue全家桶Pinia状态管理\n由于 vuex 4 对 typescript 的支持让人感到难过，所以状态管理弃用了 vuex 而采取了 pinia. pinia 的作者是 Vue 核心团队成员\n尤大好像说 pinia 可能会代替 vuex，所以请放心使用。\nPinia 与 Vuex 的区别：\n\n  id 是必要的，它将所使用 store 连接到 devtools。\n  创建方式：new Vuex.Store(…)(vuex3)，createStore(…)(vuex4)。\n\n\n\n\n  对比于 vuex3 ，state 现在是一个函数返回对象。\n  没有 mutations，不用担心，state 的变化依然记录在 devtools 中。\n\n安装 pinia\nyarn add pinia\n# or with npm\nnpm install pinia\n\nmain.ts\nimport &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\n\nconst app &#x3D; createApp(App)\napp.use(createPinia())\ncreateApp(App).mount(&#39;#app&#39;)\n\n新建store文件夹，新建index.ts\nimport &#123;defineStore&#125; from &#39;pinia&#39;\n\nexport const useStore &#x3D; defineStore(&#39;storeId&#39;, &#123;\n    state: () &#x3D;&gt; &#123;\n        return &#123;\n            counter: 0,\n            name: &#39;Eduardo&#39;,\n            isAdmin: true,\n        &#125;\n    &#125;,\n&#125;)\n\n组件内使用\n&lt;script setup lang&#x3D;&quot;ts&quot;&gt;\nimport HelloWorld from &#39;.&#x2F;components&#x2F;Hello&#39;\nimport &#123;useStore&#125; from &quot;@&#x2F;store&#x2F;store&quot;;\nimport &#123;index&#125; from &quot;@&#x2F;types&quot;;\n\nconst store:index &#x3D; useStore()\nconsole.log(useStore().$state)\n\n\n&lt;&#x2F;script&gt;\n\n&lt;template&gt;\n  &lt;div&gt;&#123;&#123; store.name &#125;&#125;&lt;&#x2F;div&gt;\n  &lt;HelloWorld&#x2F;&gt;\n&lt;&#x2F;template&gt;\n\ngetters 用法介绍Pinia 中的 getter 与 Vuex 中的 getter 、组件中的计算属性具有相同的功能\n\nactions这里与 Vuex 有极大的不同，Pinia 仅提供了一种方法来定义如何更改状态的规则，放弃 mutations 只依靠 Actions，这是一项重大的改变。\nPinia 让 Actions 更加的灵活：\n\n  可以通过组件或其他 action 调用\n  可以从其他 store 的 action 中调用\n\n\n\n\n  直接在 store 实例上调用\n  支持同步或异步\n\n\n\n\n  有任意数量的参数\n  可以包含有关如何更改状态的逻辑（也就是 vuex 的 mutations 的作用）\n\n\n\n\n  可以 $patch 方法直接更改状态属性\n\nVueRouteryarn add vue-router@4在 src 文件下新增 router 文件夹 =&gt; router.ts 文件,内容如下:\nimport &#123;createRouter, createWebHistory, RouteRecordRaw&#125; from &#39;vue-router&#39;\n\nconst routes: RouteRecordRaw[] &#x3D; [\n    &#123;\n        path: &#39;&#x2F;&#39;,\n        name: &#39;Login&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;pages&#x2F;login&#x2F;Login.vue&#39;), &#x2F;&#x2F; 注意这里要带上 文件后缀.vue\n    &#125;,\n]\n\nconst router &#x3D; createRouter(&#123;\n    history: createWebHistory(),\n    routes,\n&#125;)\n\nexport default router\n\n修改入口文件 mian.ts :\nimport &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\nimport router from &quot;@&#x2F;router&#x2F;router&quot;;\n\nconst app &#x3D; createApp(App)\napp.use(createPinia()).use(router)\n\napp.mount(&#39;#app&#39;)\n\n\n到这里路由的基础配置已经完成了,更多配置信息可以查看 vue-router 官方文档:\nvue-router: https://next.router.vuejs.org/zh/guide/\nvue-router4.x 支持 typescript，配置路由的类型是 RouteRecordRaw，这里 meta 可以让我们有更多的发挥空间，这里提供一些参考\n\n  title:string; 页面标题，通常必选。\n  icon?:string; 图标，一般配合菜单使用。\n\n\n\n\n  auth?:boolean; 是否需要登录权限。\n  ignoreAuth?:boolean; 是否忽略权限。\n\n\n\n\n  roles?:RoleEnum[]; 可以访问的角色\n  keepAlive?:boolean; 是否开启页面缓存\n\n\n\n\n  hideMenu?:boolean; 有些路由我们并不想在菜单中显示，比如某些编辑页面。\n  order?:number; 菜单排序。\n\n\n\n\n  frameUrl?:string; 嵌套外链。\n\nElement-ui plus\nElement Plus 目前还处于快速开发迭代中。目前使用2.0.1版可以结合vite-plugin-style-import插件按需加载样式。 unplugin-vue-components 按需自动导入组件 使用 Element Plus组件时可以直接使用\n# 选择一个你喜欢的包管理器\n\n# NPM\n$ npm install element-plus --save\n\n# Yarn\n$ yarn add element-plus\n\n# pnpm\n$ pnpm install element-plus\n\nmain.ts\nimport &#123;createApp&#125; from &#39;vue&#39;\nimport App from &#39;.&#x2F;App.vue&#39;\nimport &#123;createPinia&#125; from &#39;pinia&#39;\nimport router from &#39;.&#x2F;router&#x2F;router&#39;\nimport ElementPlus from &#39;element-plus&#39;\nimport &#39;element-plus&#x2F;dist&#x2F;index.css&#39;\n\nconst app &#x3D; createApp(App)\napp\n    .use(createPinia())\n    .use(router)\n    .use(ElementPlus, &#123;size: &#39;small&#39;, zIndex: 3000&#125;)\n\napp.mount(&#39;#app&#39;)\n\n\n\n\nAxios封装# 安装 axios \nyarn add axios \n# 安装 nprogress 用于请求 loading \n# 也可以根据项目需求自定义其它 loading yarn add nprogress \n# 类型声明，或者添加一个包含 &#96;declare module &#39;nprogress&#39; yarn add @types&#x2F;nprogress --dev\n\n实际使用中可以根据项目修改，比如RESTful api中可以自行添加put和delete请求,ResType也可以根据后端的通用返回值动态的去修改\n新增 http文件夹，http下新增 Http.ts 文件以及 api 文件夹:\n\nhttp.ts\nimport axios, &#123;AxiosError, AxiosRequestConfig, AxiosResponse&#125; from &quot;axios&quot;;\nimport NProgress from &#39;nprogress&#39;\nimport &#123;Message&#125; from &#39;@element-plus&#x2F;icons-vue&#39;\n\ninterface ResType&lt;T&gt; &#123;\n    code: number\n    data?: T\n    msg: string\n    err?: string\n&#125;\n\ninterface Http &#123;\n    get&lt;T&gt;(url: string, params?: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    post&lt;T&gt;(url: string, params?: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    upload&lt;T&gt;(url: string, params: unknown): Promise&lt;ResType&lt;T&gt;&gt;\n\n    download(url: string): void\n&#125;\n\n&#x2F;&#x2F; 设置请求头和请求路径\naxios.defaults.baseURL &#x3D; &#39;&#x2F;api&#39;\naxios.defaults.timeout &#x3D; 10000\naxios.defaults.headers.post[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;json;charset&#x3D;UTF-8&#39;\n\n&#x2F;&#x2F;请求拦截器\naxios.interceptors.request.use(\n    (config: AxiosRequestConfig) &#x3D;&gt; &#123;\n        const token &#x3D; window.sessionStorage.getItem(&#39;token&#39;)\n        if (token) &#123;\n            &#x2F;&#x2F; @ts-ignore\n            config.headers.token &#x3D; token\n        &#125;\n        return config\n    &#125;,\n    (error: Error) &#x3D;&gt; &#123;\n        return error\n    &#125;\n)\n&#x2F;&#x2F; 响应拦截\naxios.interceptors.response.use(\n    (res: AxiosResponse) &#x3D;&gt; &#123;\n        &#x2F;&#x2F;发请求前做的一些处理，数据转化，配置请求头，设置token,设置loading等，根据需求去添加\n        switch (res.data.code) &#123;\n            case 111:\n                sessionStorage.setItem(&#39;token&#39;, &#39;&#39;);\n                return res\n            case 200:\n                return JSON.stringify(res.data)\n            default :\n                return\n        &#125;\n    &#125;,\n    (error: AxiosError) &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 接收到异常响应的处理开始\n        if (error &amp;&amp; error.response) &#123;\n            &#x2F;&#x2F; 1.公共错误处理\n            &#x2F;&#x2F; 2.根据响应码具体处理\n            switch (error.response.status) &#123;\n                case 400:\n                    error.message &#x3D; &#39;错误请求&#39;\n                    break;\n                case 401:\n                    error.message &#x3D; &#39;未授权，请重新登录&#39;\n                    break;\n                case 403:\n                    error.message &#x3D; &#39;拒绝访问&#39;\n                    break;\n                case 404:\n                    error.message &#x3D; &#39;请求错误,未找到该资源&#39;\n                    window.location.href &#x3D; &quot;&#x2F;NotFound&quot;\n                    break;\n                case 405:\n                    error.message &#x3D; &#39;请求方法未允许&#39;\n                    break;\n                case 408:\n                    error.message &#x3D; &#39;请求超时&#39;\n                    break;\n                case 500:\n                    error.message &#x3D; &#39;服务器端出错&#39;\n                    break;\n                case 501:\n                    error.message &#x3D; &#39;网络未实现&#39;\n                    break;\n                case 502:\n                    error.message &#x3D; &#39;网络错误&#39;\n                    break;\n                case 503:\n                    error.message &#x3D; &#39;服务不可用&#39;\n                    break;\n                case 504:\n                    error.message &#x3D; &#39;网络超时&#39;\n                    break;\n                case 505:\n                    error.message &#x3D; &#39;http版本不支持该请求&#39;\n                    break;\n                default:\n                    error.message &#x3D; &#96;连接错误$&#123;error.response.status&#125;&#96;\n            &#125;\n        &#125; else &#123;\n            &#x2F;&#x2F; 超时处理\n            if (JSON.stringify(error).includes(&#39;timeout&#39;)) &#123;\n                Message.error(&#39;服务器响应超时，请刷新当前页&#39;)\n            &#125;\n            Message.error(&#39;连接服务器失败&#39;)\n        &#125;\n        Message.error(error.message)\n        &#x2F;&#x2F;处理结束\n        &#x2F;&#x2F;如果不需要错误处理，以上的处理过程都可省略\n        return Promise.resolve(error.response)\n    &#125;\n)\n\nconst Http: Http &#x3D; &#123;\n    get(url, params) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .get(url, &#123;params&#125;)\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    post(url, params) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .post(url, JSON.stringify(params))\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    upload(url, file) &#123;\n        return new Promise((resolve, reject) &#x3D;&gt; &#123;\n            NProgress.start()\n            axios\n                .post(url, file, &#123;\n                    headers: &#123;&#39;Content-Type&#39;: &#39;multipart&#x2F;form-data&#39;&#125;,\n                &#125;)\n                .then((res) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    resolve(res.data)\n                &#125;)\n                .catch((err) &#x3D;&gt; &#123;\n                    NProgress.done()\n                    reject(err.data)\n                &#125;)\n        &#125;)\n    &#125;,\n    download(url) &#123;\n        const iframe &#x3D; document.createElement(&#39;iframe&#39;)\n        iframe.style.display &#x3D; &#39;none&#39;\n        iframe.src &#x3D; url\n        iframe.onload &#x3D; function () &#123;\n            document.body.removeChild(iframe)\n        &#125;\n        document.body.appendChild(iframe)\n    &#125;,\n&#125;\n\nexport default Http;\n\n在http文件夹下创建api文件夹用于统一存放接口文件,统一管理api\nhttp/api/login.ts\n\nimport http from &quot;@&#x2F;http&#x2F;Http&quot;;\n\nexport async function login(data: &#123; userName: string, password: string &#125;) &#123;\n    return http.post(&#96;&#x2F;login&#96;, data)\n&#125;\n\n至此,一个简单地请求封装完成了!!!!\n除了自己手动封装 axios ,这里还推荐一个 vue3 的请求库: VueRequest,非常好用,下面来看看 VueRequest有哪些比较好用的功能吧!!!\n\n  所有数据都具有响应式\n  轮询请求\n\n\n\n\n  自动处理错误重试\n  内置请求缓存\n\n\n\n\n  节流请求与防抖请求\n  聚焦页面时自动重新请求\n\n\n\n\n  ⚙️ 强大的分页扩展以及加载更多扩展\n  完全使用 Typescript 编写，具有强大的类型提示\n\n\n\n\n  ⚡️ 兼容 Vite\n  轻量化\n\n\n\n\n  开箱即用\n\n\ntsx支持首先需要安装官方维护的vite插件@vitejs/plugin-vue-jsx,这个插件其实核心还是@vue/babel-plugin-jsx,只是在这个插件上封装了一层供vite插件调用。所以关于vue的jsx语法规范可以直接参看@vue/babel-plugin-jsx,文档链接如下，建议大家可以先读一遍语法规范。官方写得比较详细，后续我也会结合实际讲解一下大部分规范的用法，vue jsx语法规范。\n$ npm install @vitejs&#x2F;plugin-vue-jsx -D\n#or \n$ yarn add @vitejs&#x2F;plugin-vue-jsx -D \n\n安装完之后在vite.config.ts进行插件使用，代码如下：\nimport &#123; defineConfig &#125; from &quot;vite&quot;;\nimport vue from &quot;@vitejs&#x2F;plugin-vue&quot;;\nimport vueJsx from &quot;@vitejs&#x2F;plugin-vue-jsx&quot;;\n\nexport default defineConfig(&#123;\n  plugins: [\n    vue(),\n    vueJsx() &#x2F;&#x2F;插件使用\n  ],\n&#125;);\n\n环境变量配置vite 提供了两种模式：具有开发服务器的开发模式（development）和生产模式（production）\n项目根目录新建: .env.development\nNODE_ENV=development VITE_APP_WEB_URL= &#39;YOUR WEB URL&#39;\n项目根目录新建: .env.production\nNODE_ENV=production VITE_APP_WEB_URL= &#39;YOUR WEB URL&#39;\n组件中使用：\nconsole.log(import.meta.env.VITE_APP_WEB_URL)\n配置 package.json:\n打包区分开发环境和生产环境\n&quot;build:dev&quot;: &quot;vite build --mode development&quot;,\n&quot;build:pro&quot;: &quot;vite build --mode production&quot;,\nVite 常用基础配置基础配置运行 代理 和 打包 配置\n&#x2F;&#x2F;配置代理\n    server: &#123;\n        host: &#39;0.0.0.0&#39;,\n        port: 3000,\n        open: true,\n        https: false,\n        proxy: &#123;&#125;\n    &#125;,\n      \n      &#x2F;&#x2F; 生产环境打包配置\n    &#x2F;&#x2F;去除 console debugger\n    build: &#123;\n        terserOptions: &#123;\n            compress: &#123;\n                drop_console: true,\n                drop_debugger: true,\n            &#125;,\n        &#125;,\n    &#125;,\n\n生产环境生成 .gz 文件开启 gzip 可以极大的压缩静态资源，对页面加载的速度起到了显著的作用。\\\n使用 vite-plugin-compression 可以 gzip 或 brotli 的方式来压缩资源，这一步需要服务器端的配合，vite 只能帮你打包出 .gz 文件。此插件使用简单，你甚至无需配置参数，引入即可。\n# 安装 yarn add --dev vite-plugin-compression\nplugins 中添加：\n import viteCompression from &#39;vite-plugin-compression&#39;\n\n&#x2F;&#x2F;配置插件\n    plugins: [\n        vue(),\n        vueJsx(),\n        viteCompression(&#123;\n            verbose: true,\n            disable: false,\n            threshold: 10240,\n            algorithm: &#39;gzip&#39;,\n            ext: &#39;.gz&#39;,\n        &#125;),\n    ],\n\n\n最终 vite.config.tsimport &#123;defineConfig&#125; from &#39;vite&#39;\nimport vue from &#39;@vitejs&#x2F;plugin-vue&#39;\nimport vueJsx from &#39;@vitejs&#x2F;plugin-vue-jsx&#39;\nimport * as path from &quot;path&quot;\nimport viteCompression from &#39;vite-plugin-compression&#39;\n\nexport default defineConfig(&#123;\n    base: &#39;.&#x2F;&#39;, &#x2F;&#x2F;打包路径\n\n    &#x2F;&#x2F;配置插件\n    plugins: [\n        vue(),\n        vueJsx(),\n        viteCompression(&#123;\n            verbose: true,\n            disable: false,\n            threshold: 10240,\n            algorithm: &#39;gzip&#39;,\n            ext: &#39;.gz&#39;,\n        &#125;),\n    ],\n    &#x2F;&#x2F;配置路径别名\n    resolve: &#123;\n        alias: &#123;\n            &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),\n        &#125;,\n    &#125;,\n    &#x2F;&#x2F;配置代理\n    server: &#123;\n        host: &#39;0.0.0.0&#39;,\n        port: 3000,\n        open: true,\n        https: false,\n        proxy: &#123;&#125;\n    &#125;,\n\n    &#x2F;&#x2F; 生产环境打包配置\n    &#x2F;&#x2F;去除 console debugger\n    build: &#123;\n        terserOptions: &#123;\n            compress: &#123;\n                drop_console: true,\n                drop_debugger: true,\n            &#125;,\n        &#125;,\n    &#125;,\n&#125;)\n\n常用插件可以查看官方文档：https://vitejs.cn/plugins/\\\n\n  @vitejs/plugin-vue 提供 Vue 3 单文件组件支持\n  @vitejs/plugin-vue-jsx 提供 Vue 3 JSX 支持（通过 专用的 Babel 转换插件）\n\n\n\n\n  @vitejs/plugin-legacy 为打包后的文件提供传统浏览器兼容性支持\n  unplugin-vue-components 组件的按需自动导入\n\n\n\n\n  vite-plugin-compression 使用 gzip 或者 brotli 来压缩资源\n\n非常推荐使用的 hooks 库因为vue3.x和react hooks真的很像，所以就称为 hooks\\\nVueUse：https://vueuse.org/\n\n看到这个库的第一眼，让我立马想到了 react 的 ahooks\nVueUse 是一个基于 Composition API 的实用函数集合。通俗的来说，这就是一个工具函数包，它可以帮助你快速实现一些常见的功能，免得你自己去写，解决重复的工作内容。以及进行了基于 Composition API 的封装。让你在 vue3 中更加得心应手。\n想要入手 vue3 的小伙伴，赶快学习起来吧！！！\n最后给大家奉上仓库地址吧：https://gitee.com/frontendBoy_wang/vite-vue3-ts-pinia-element_plus-template.git\n写在最后公众号：前端少年汪\n专注分享 web 前端相关技术文章、视频教程资源、热点资讯等，如果喜欢我的分享，给 点一个赞 或者 ➕关注 都是对我最大的支持。\n","slug":"vue/一个基于vite构建的vue3+pinia+ts+elementUI plus的初始化开箱即用的项目模版","date":"2022-10-08T15:14:01.000Z","categories_index":"前端","tags_index":"vue JS","author_index":"前端少年汪"},{"id":"5dcbffe5ec49005d84a364d2e66ecd0a","title":"打工人面试避坑指南","content":"\n\n\n\n\n\n\n\n\n找工作如同西游取经，一波三折，九九八十一难，处处是坑啊。\n工作内容(1)具体做什么其实这个部分，在之前的面试环节很多同学可能已经问过，这里的话其实可以再详细问问，比如具体负责什么业务线的工作，主要的工作内容是什么，会先从哪方面的工作入手等等，可以再具体详细地问一问HR。\n(2)工作时间问清楚具体的上下班时间，是否双休，以及加班强度等。(这个部分一般一开始HR就会告诉你，并且我发现如果是双休的企业会特别强调以下自己双休，HR也怕你不来，在谈offer环节请大胆问，只有了解清楚才能避免双方出现不愉快的情况)\n对于加班情况，大家可以大胆问，没关系，一般企业都会说不怎么加班，只有在项目很紧急的时候才会加班，但现在工作嘛，怎么可能不加班，加多加少的区别，你可以侧面问问自己部门的人平时一般都是几点离开公司的。\n钱的部分\n\n\n\n\n\n\n\n\n到了谈钱的部分啦，出来打工的，谁不是为了赚钱呢。虽然我不鼓励在对比offer的时候以钱作为决定性参照标准，但钱肯定很重要，并且我发现相比小企业，大企业更会给你一个值得的高价，有时候企业对你的重视程度其实从薪资水平也能看出来。\n(1)基本薪资劳动者基本工资是根据劳动合同约定或国家及企业规章制度规定的工资标准计算的工资，也称标准工资。在一般情况下，基本工资是职工劳动报酬的主要部分。简单来说，基本工资一般就是我们每月的工资，这些会在offer中直接写出，即月薪多少，这一部门收入相对稳定，是员工工作稳定性的基础，是员工安全感的保证。注意，有的人的月薪结构是底薪+绩效，但就我拿到的offer的情况，很多情况下HR会说绩效是为了激励，实际上基本所有人都能够拿满，如果HR所说属实，那么虽然是底薪+绩效，但实际上就等于我们比较稳定的基本工资部分。因为岗位的性质不同，有些岗位比较看绩效，工资结构中绩效占比比较大，并且浮动性强，那么这部分收入就是不稳定的，那么应该把你的底薪看作基本工资。不同的底薪，在缴纳五险一金时会存在差距，这一点后面再说。\n(2）年终奖关于年终奖属于福利的部分，一定要问清楚，一般情况下，快消类岗位都是13薪，也就是一年发13个月的工资，多出来的一个月就相当于发给你的年终奖。不过有些公司也可能会说根据公司经营情况发放，一定要问清楚是不是保底会发一个月，情况好的时候会更多，还是情况不好的时候不会发年终奖，并且可以问一下HR，和你情况类似的员工(岗位相同，同为校招生等)一般第一年能够拿到多少年终奖。\n(3）绩效及其评定薪资结构中有绩效组成的同学，请问清楚绩效的评定标准，并且可以问一问与你类似员工的绩效达成情况，以及，绩效是怎么计算的，比如绩效有一个基础的数额，根据你的绩效评级不同，基础数额乘以一个不同的系数，就是你的最终绩效等等计算方法。\n(4）涨薪机制or晋升机制这一部分非常重要，可能你在刚工作的时候工资比你的同学高，但是因为你的同学涨薪比你快而很快超过你。对于涨薪机制，有的公司会存在普调，比如每年涨薪10%，即不管怎么样都可以涨，有的则需要评级晋升才可以，如果通过考核，则可以涨薪10%-30%不等。大部分情况下，涨薪都是需要评级和晋升的，但是要注意，每个公司每年评级和晋升的时间是固定的，有的公司是一年一次晋升机会，有的是两次晋升机会，一般来说，一年两次晋升机会的公司更好。在这一部分，你可以问一下HR，以往进入的新员工，第一次晋升的成功率，或者多久才能普升一级，并且晋升成功之后的涨薪幅度是多少。\n(5）试用期试用期是指包括在劳动合同期限内，用人单位对劳动者是否合格进行考核，劳动者对用人单位是否符合自己要求也进行考核的期限，这是一种双方双向选择的表现。那么试用期多长呢?\n\n\n\n\n\n\n\n\n\n《中华人民共和国劳动合同法》规定:劳动合同期限三个月以上不满一年的，试用期不得超过一个月;劳动合同期限一年以上不满三年的，试用期不得超过二个月;三年以上固定期限和无固定期限的劳动合同，试用期不得超过六个月。\n同一用人单位与同一劳动者只能约定一次试用期。以完成一定工作任务为期限的劳动合同或者劳动合同期限不满三个月的，不得约定试用期。看完了《劳动法》的规定，对于试用期超出时间的offer，我觉得大家要勇敢说不，不能被当作廉价劳动力，这是违法行为!此外，注意!试用期内不给你交社保的公司也是垃圾公司，一定要远离，切记切记。\n个人成长空间(1)培训体系—般情况，越大的公司会有越完善的培训体系给到校招生。有的公司对校招生有一段专门的培训期，一个月左右，为了让学生能够更快地过渡到工作状态。另一种比较常见的是轮岗机制，一般是针对管培生，可能会根据你的实际情况去到三个或三个以上的部门轮岗工作，一般会在一个部门工作三个月或者更长的时间，轮岗完成大概需要一到两年的时间。一般来说，轮岗完成后会给你再定岗定薪。对于这一部分，需要问清楚的有:定岗的标准，薪资变化情况(比如有可能出现降薪情况吗?）等。\n福利待遇(1)五险一金五险一金的缴纳要重点说一说。五险一金是指用人单位给予劳动者的几种保障性待遇的合称，包括养老保险、医疗保险、失业保险、工伤保险和生育保险，及住房公积金。只要是正规的公司，都会给员工缴纳五险一金，但根据缴纳基数的不同，同样的工资，不同的公司很可能跟你缴纳的金额不同。五险一金有一个缴纳基数和缴纳比例公司和个人都需要缴纳，但公司缴纳的数目要远远大于个人缴纳的。缴纳金额=缴纳基数*缴纳比例。\nA.缴纳基数首先是缴纳基数，按照规定，五险金的缴纳基数一般是根据员工上一年月平均工资的60%—300%之间来核定的，具体表现为:上一年月平均工资高于当地上年底职工平均工资300%及以上的，五险一金缴纳基数按照月平均工资的300%计算;上一年月平均工资低于当地上年底职工平均工资60%及以下的，五险一金缴纳基数按照月平均工资的60%计算;上一年月平均工资在当地上年底职工平均工资60%—300%之间的，按照实际工资申报五险一金缴纳基数。但是，有些公司为了少为员工缴纳五险一金，会把五险一金的缴纳基数定为当地平均工资最低的那一档，或者是降一些。\n所以，当公司跟你说缴纳五险一金时，一定要问清楚是不是按照实际工资全额缴纳，如果不是，缴纳基数是多少?我周围的一些朋友就在这个上面踩过坑，大家谈offer时一定要留个心眼。\nB.缴纳比例然后是缴纳比例，就五险而言，按照国家规定缴纳，一般缴纳比例是固定的，而公积金公司一般会交5%-12%，比较常见的有5%、8%和12%三档。因为五险的缴纳比例固定，所以缴纳基数越高，公司会为你交更多的五险，举个例子，假如你税前月薪10000，公司要为你缴纳3210元(这一部分不算在工资中，为公司额外缴纳的)，而个人需要缴纳1020元(从个人工资扣除后扣税)。这里需要注意一个坑，如果公司所应用的缴纳基数低，你需要缴纳的社保金额也会降低，每个月的到手工资会高，但长远来看，其实你是吃亏的，因为社保其实也是一种投资，公司省下了更多应该为你交的钱。\nC.公积金公积金全称住房公积金，可应用于租房、买房等有关的场景，如果实在没有这些应用场景，住房公积金之后也可以取出来使用。如果是有买房需求的同学，住房公积金可以申请到最低贷款利率的房贷，而公积金账户的金额会影响到你买房时能够贷款的金额数。\n上面提到过，企业在缴纳公积金时可以选择5%-12%，很多私企在缴纳公积金时都选择的5%，相对来说大一点的企业可能会缴纳的多一点，国企、事业单位、公务员都是按照12%来缴纳的。一般来说，公司缴纳5%，个人也相应的要缴纳5%，如果有买房需求，想多交公积金的，可以提高个人的缴纳比例，公司还是按照原有的比例缴纳。\n(2）年假年假这部分是指除了国家法定节假日之外的带薪假期，一般正规大公司都会有年假，只是年假时间不等。在谈offer时需要问清楚是否有年假?年假多长时间?需要注意的是，有些公司年假不是一入职就有，而是需要工作满—年才有年假，一定要问清楚。\n(3）加班是否有福利这一部分需要询问加班的强度，以及加班是否有福利补贴，一般来说会有调休或者双倍加班工资。如果是调休的话需要问清楚是不是一比一调休，有的公司压榨员工，加班一天只给半天的调休假。而双倍加班费的话，可以问一下怎么发放。\n(4）补贴—般会有交通补贴、餐饮补贴、通讯补贴、住房补贴等。这些补贴一般不会都有，并且不同的岗位补贴不同，比如总需要在外跑的销售类岗位会有交通补贴，需要问清楚具体的金额以及发放方式。还有的公司会给出差补助，如果岗位经常需要出差也可以询问。\n(5）其他其他的福利比如每年的公司团建、公司体检，这些一般正规的大公司都会有。还有一些比较核心的技术岗会有期权等等，这一部分就比较灵活了，具体谈的时候，因为是吸引人才的优势，HR一般都会重点介绍。\n违约金现在有一些企业当学生确定接受offer时，因为企业招一个合适的人的成本其实很高，为了“圈住”学生，会在与学生签订三方协议(国内学生)或者两方协议(国外学生)规定违约金，有些违约金会是一个月的月薪，不同的公司可能违约金不同。\n对于学生来说，其实这是很不平等的条约。虽然，网上有人说，就算你毁约，态度好一点，一般企业不会为难你一个学生，但是为了避免麻烦和纠纷，在面对有违约金的offer时请一定要慎重考惠接不接受。参考的条件除了上面说的4条内容外，可以咨询一下身边的亲戚朋友，还可以上网搜索公司相关内容，明显觉得是坑的就不要去了。\n最后，希望所有人都能够避过大坑，收到满意的offer。不过，没有任何工作是完美的，在比较offer时，一定要清楚自己最看重的部分是什么，其他地方可以适当让步\n","slug":"面试/2022年金三银四面试避坑指南","date":"2022-09-22T18:34:26.000Z","categories_index":"面试","tags_index":"工作 面试 避坑","author_index":"前端少年汪"},{"id":"6ecd8aae6917fc1ba607fbebaa53d4e0","title":"2021年终总结","content":"\n\n\n\n\n\n\n\n\n2021年对于我来说是平凡又跌宕起伏的一年，有快乐有不甘，有进步有懈怠。下面就工作，技术成长，生活和对未来的期望做一个总结吧!希望在2022年会有不一样的惊喜。也希望自己立下的flag能够一一兑现.加油🐱‍💻🎈🎈🎈\n\n工作对工作，对未来有诸多想象和期待。希望自己能够大展拳脚。古人曰：”夫英雄者，胸怀大志，腹有良谋，有包藏宇宙之机，吞吐天地之志者也”我虽没有多么大的志向，但求今天的的自己比昨天有进步，明天比今天有进步。好了，不废话了。先反思一下今年两次找工作的经历吧。我前前后后总共面试了十多家公司吧，拿到了6个offer，两次跳槽经历。第一次跳槽是从之前的公司辞职后的。。思量再三，还是想换个环境。辞职之后首先是制作简历然后就在boss直聘上开始疯狂投简历，就开始了面试之旅。基本上是按照一天3个面试的样子。然后在拿到第三个offer以后就开始选择哪个offer的性价比高一些。最后选择了一家还不错的。待遇对于之前还算不错的。在这家公司待了3个月临近转正的时候，我提出了辞职。具体理由先不讲（卖个关子，以后专门写一篇面试找工作的文章详述）。到了10月份。我又重新制作简历，开始了 海投。这次比上次要快很多。同样也是拿到了3个offer，也没有上次面试奔波的那么累，都是通过线上面试的。最终入职了现在这家公司。总体来说，工作上还是比较顺利的，尽管有一些小波折，尽管找工作的过程有些累，但是回过头来看，所有的一切都是值得的！\n\n技术前端技术进一步得到锻炼，基本上都是提前完成客户提出的功能需求。能够按照客户的要求去实现UI，页面交互，数据渲染。react技术也提高了，能够自主封装组件和函数，代码风格更加规范了.学到了socket,http封装,UDP/TCP等后端的一些技术等等,也学习了一些node后端的知识.还有研究了JS的一些原理性的知识,JS的代码执行机制,异步任务和同步任务,异步执行队列,深拷贝,浅拷贝,防抖节流等等.总之学到的新知识还不算很多,但是是在实际项目中用到的.理解的还是比较深刻.前端这一块儿,后面肯定会继续学习下去,追求前端前沿技术潮流.但是后面可能会主攻Golang后端方向了.因为对自己的职业生涯规划,还是希望能够做后端,能够更加深入,走得更远,站在巨人的肩膀上触摸到更高的天花板吧.\n生活生活方面,我本人在工作之余没什么事情,到处游玩,然后就是喜欢逛各种博客论坛和社区.后面自己也想通过写博客这种方式来锻炼自己的写作能力,并且督促自己不断学习新的技术.先立个flag:2022年开始,每周产出一篇高质量的博客.然后看情况.每月出一期视频.培养自己的自律意识吧.\n未来对于未来,虽然心里是有目标,但是不知道为啥还是会有迷茫感.或近期,或远期. 2022年,希望会是稳定前进的一年,希望自己的技术能够更加精进.在前端技术领域,我想自己做一个个人的博客项目.前后端全部由自己一个人独立完成.再就是把还没有学习的vue3的知识体系也全部学完,做一个完整的项目.因为选择工作中都是用的react技术栈,所以vue技术栈都忘记的差不多了,技术这个东西,你不用就会很快忘记.所以需要不断的回顾复习才能记得牢固.再就是希望自己能够坚持这些好的习惯.\n\n给自己立下的flag\n 个人博客项目\n vue3技术栈学习\n Golang后端技术栈的学习\n 每周一篇高质量博客,每月一期视频\n 做自己的自媒体账号.把微信公众号,B站,抖音,知乎账号等都运营起来\n\n希望明年2023年的自己再看这篇博客能够骄傲的说我完成了,问心无愧了!加油就🐱‍🚀🐱‍🏍😎\n","slug":"年终总结/2021年终总结","date":"2022-09-22T16:51:08.000Z","categories_index":"工作感悟","tags_index":"工作感悟 生活","author_index":"前端少年汪"},{"id":"961c6d07c2537724e77c6edda1ef4e41","title":"2022年金三银四面试葵花宝典(你不知道的面试技巧，建议收藏转发)","content":"\n\n\n\n\n\n\n\n\n大家好，我是前端少年汪，每周更新一篇高质量博客。喜欢我的小伙伴可以点一波关注。我的公众号号：前端少年汪。里面会分享一些学习资料和技术心得。谢谢！😁\n年末春初，金三银四。是的，又到了一年一度的跳槽找工作的时间了。是不是有很多小伙伴已经在蠢蠢欲动了？准备摩拳擦掌，大干一场！在此之际，我特地写一篇文章来细数一下找工作的整个过程和其中的注意事项。\n分析自我\n首先，在找工作之前，要好好的剖析一下自己。找准自身的定位和技术职级，自己几年工作经验，掌握了哪些技术栈，当前城市大概可以拿多少工资等等之类的，都要好好扪心自问一下。提前称一称自己有多少斤两。到时候面试也不至于手足无措，四门天黑。争取做到不打无准备的仗！\n我的技术栈作为一个互联网人，一个程序员。技术是首当其冲的，你的技术有多牛就意味着你可以拿多少工资。对于程序员的专业技能其实就是技术栈，对于⾃⼰的技术栈如何描述是个很难的问题，⽐如什么算是精通？什么算是了解？什么是熟悉？\n就拿前端来说，需要掌握的东西还是蛮多的。HTML,CSS,JS这些咱就不说了，这是基础，但是基础要必须牢固，不能一知半解。其中JS是重点。然后就是Vue,React前端框架，Ag咱就不说了，goole好像对其停止维护了，不太建议学这个。\n\nHTML/HTML5\nCSS/CSS3\nJS，ES6\nVue全家桶\nReact及其相关技术栈等\n前端性能优化，前端安全\n工程化，组件化\nTypescript\nnode\n前端设计模式\n\n这些都还只是冰山一角而已，没有深入其中某一项去展开聊。当然也不是说要完全掌握，达到精通的地步。那就太逆天了。只要可以熟练使用，并且了解其中的一些原理即可，达到企业级要求。独立开发没问题。\n我的核心竞争力\n什么是核心竞争力，通俗点讲就是个人独有的特点。不是普遍性的。就是说，在某一技术领域，你可以达到精通的地步，比其他大多数要强，这就是你的核心竞争力。比如前端，你精通JS，或者算法，架构等等，后端，你精通数据库，redis，微服务等等。那这样你在面试和谈薪资的时候腰杆子就可以硬一点了。\n准备简历简历是你进⼊⾯试的敲⻔砖，也是留给意向公司的第⼀印象，所以这个很重要，必须在这上⾯做⾜了⽂章，⼀份优秀的⾯试简历是整个⾯试成败的重中之重，我们要认真准备简历才能保证简历不被刷掉。\n简历大纲结构清晰花几分钟了解一下word/wps的大纲模式，“章、节、条、款、例”，在大纲模式下，先把简历文档按这样的层级编排一下。\n具体内容少而精确发挥你上学时写作文的能力，言简意赅甚至咬文嚼字地把重点描述清楚。精通的技术写成熟悉，熟悉的写成了解\n简历通常有这⼏部分构成:\n基本资料\n专业技能\n⼯作经历\n项⽬经历\n教育背景\n\n简历模版万事开头难，简历的编写如果从头开始需要浪费很多时间，其实最快速也最聪明的办法就是先找⼀份还不错的简历模板，之后只需要填写信息即可。\n简历模板的选择很讲究，有些简历基本不看内容就会被刷掉，这些简历⼀般会对⾯试官进⾏视觉攻击，让简历给⾯试官的第⼀印象就是反感。\n有两种令人反感的简历模板:\n\n⼀种是经典简历模板，真是堪称经典，配⾊⽐较魔幻，加上表格类的简历属于low到底端的简历类型，基本上扫⼀眼就扔了，这种简历只需要3秒钟就能被⾯试官扔到垃圾堆；\n另⼀种是设计感⼗⾜的简历模板，这种简历设计感⼗⾜，这五颜六⾊的配⾊能亮瞎⾯试官的双眼，这种花⾥胡哨的简历同样也是3秒钟沉到垃圾堆底部的简历。\n\n以上两类简历模板堪称⾯试官杀⼿，只要⽤了上述两类模板，绝对连让⾯试官看第⼆眼的兴趣都没有。⾯试官筛简历要的是⾼效、清晰、内容突出，不管是HR还是技术⾯试官都想在最快速的情况下看到有效信息，你眼中所谓的『视觉效果』在别⼈眼⾥就是『视觉噪⾳』或者『视觉垃圾』，严重影响看简历的⼼情和寻找有效信息的速度。\n个人信息个⼈信息部分主要包括姓名、电话、电子邮箱、求职意向，当然这四个是必填的，其它的都是选填，填好了是加分项，否则很可能减分。\n接下来才是重点：\n\n博客：如果准备⼀个基本没有更新的博客或者没有任何贡献的github，那么给⾯试官⼀种为了放上去⽽放上去的感觉，这基本上就是在跟⾯试官说『这个候选⼈平时根本没有总结提炼的习惯』，所以如果有⻓期维护的github或者博客⼀定要放上去，质量好的话会⾮常有⽤，如果没有千万别放。\n学历：如果你的学历是专科、⾼中毕业之类的，还写在简历头部强调⼀遍，这就增加了简历被刷的⼏率，如果是研究⽣或者985211学历可以写，突出⼀下学历优势，本科学历在技术⾯试领域基本上敲⻔砖级别的，没必要写。\n年龄：如果是⼤龄程序员，尤其是还在求⼀份低端岗位的时候千万别写，⼀个⼤龄程序员在求职⼀个中低端岗位，说明这些年基本原地踏步，还不能加班，到这⾥基本上此简历就凉了⼀半了。\n照⽚：形象优秀的可以贴，尤其是形象优秀的⼥程序媛，其它的最好不要贴，如果要贴的话，最好是贴那种PS过的⾮常职业的证件照。\n\n精通某类技术，别表现得太得意自满在中国，往往是谦受益、满招损。因为总有比我们技术更好的考官，当我们表现出自信满满的时候，绝大多数考官往往会想要挫一下我们的锐气，试探一下我们的技术上限，所以往往会挑我们最自信的领域出题，而且题目难度和我们表现出的自信成正比。如果一个难题回答得不好，往往会前功尽弃，给很大的负面评分。所以，对自己精通的技术，不妨谦虚一点写成熟悉，这样回答考官的技术问题，反而能给对方意外惊喜。同理，只是熟悉的技术，写成了解，少一些节外生枝的麻烦。如果只是了解的技术，干脆就别写了。不然随便问几个稍微有点点深度的问题却答不上来，会让考官认为我们的简历写得太浮夸，从而对我们的印象大打折扣。\n关于对技术技能的描述有很多种，这⾥只讲三种的了解、熟悉、精通：\n\n了解：使⽤过某⼀项技术，能在别⼈指导下完成⼯作，但不能胜任复杂⼯作，也不能独⽴解决问题。\n熟悉：⼤量运⽤过的某⼀项技术，能独⽴完成⼯作，且能独⽴完成有⼀定复杂度的⼯作，在技术的应⽤层⾯不会有太⼤问题，甚⾄理解⼀点原理。\n精通：不仅可以运⽤某⼀⻔技术完成复杂项⽬，⽽且理解这项技术背后的原理，可以对此技术进⾏⼆次开发，甚⾄本身就是技术源码的贡献者。\n\n以Vue框架为例，如果可以⽤vue写简单的⻚⾯，单独完成某⼏个⻚⾯的开发，但是⽆法脱离公司脚⼿架⼯作，也⽆法独⽴从0完成⼀个有⼀定复杂度的项⽬，只能称之为了解。\n如果有⼤量运⽤vue的经验，有从0独⽴完成⼀定复杂度项⽬的能⼒，可以完全脱离脚⼿架进⾏开发，且对vue的原理有⼀定的了解，可以称之为熟悉。\n如果⽤vue完成过复杂度很⾼的项⽬，⽽且⾮常熟悉vue的原理，是vue源码的主要贡献者，亦或者根据vue源码进⾏过魔改（⽐如mpvue），可以称得上精通。\n那么有两个坑是候选⼈经常犯的，杂和精，这种两个坑⼤量集中在应届⽣和刚毕业没两年的新⼿身上，其主要特点是急于表现⾃我、对技术深度与⼴度出现⽆知⽽导致的过度⾃信。\n⾸先说杂，⽐如要应聘⼀个Java后端，⽼⽼实实把⾃⼰的java技术栈写好就⾏了，强调⼀下⾃⼰擅⻓什么即可，最好专精某领域⽐如⾼并发、⾼可⽤等。这时⼀些简历⾮要给⾃⼰加戏，⾃⼰会的不会的⼀股脑往上堆，什么逆向、密码学、图形、驱动、AI都要体现出来，越杂越好，这种简历给⼈的印象就是个什么都不懂的半吊⼦。\n再说精，⼀个刚毕业的应届⽣，出来简历就各种精通，精通Java、精通Java虚拟机、精通spring全家桶、精通kafka等等，这种简历是不会没头没脑投过来的，这种在⼤学⾥就精通各种的天才早被他的各种学⻓介绍进了⼤⼚或者外企做某某Star重点培养了，往往看到的这种也是半吊⼦。\n尽可能放上自己的博客、个人主页、开源项目链接当我们学会了总结、归纳之后，学一样东西往往是很快的。写博客、搭建个人主页，参加github开源项目，就是归纳、总结、分享的过程。在个人简历里面放上自己的博客、个人主页、开源项目链接，能让用人方更深刻地了解我们的学习方法论，让用人单位知道我们除了自己有良好的学习能力之外，还具有强大的share能力，能分享同事们很多新技能，推动整个团队的整体职业素养变得更好!\n工作经历⼯作经历本身不⽤花太多笔墨去写，⾯试官主要想看的就是每段⼯作经历的持续时间、在不同公司担任的职责如何、是否有⼤⼚的⼯作经验等。\n那么什么简历在这⾥给⾯试官减分呢？\n\n频繁跳槽：⽐如三年换了四家公司，每个公司呆的时⻓不要超过⼀年；\n常年初级岗：⽐如⼯作五六年之后依然在完成⼀些简单的项⽬开发；\n末流公司经历：在技术招聘届，⼤⼚的优先级最⾼⽐如BAT、TMD甚⾄微软、⾕歌等外企，知名度独⻆兽其次，⼀般的互联⽹公司排在第三，就是⼯作中⼩型的互联⽹公司⼀般⼤家叫不上名字，排在最后的就是外包和传统企业的经历；\n\n（1）所以，如果你有频繁跳槽的经历怎么办？在本公司⽼⽼实实等到满⼀年再跳槽。（2）如果常年初级岗怎么办？想办法晋升或者参与⼀些业界知名项⽬，再或者写⼀个有⼀定复杂度的私⼈项⽬。（3）如果有末流公司经历怎么办？如果是很久以前的末流公司经验可以直接不写，也没⼈在乎你很早之前的⼯作经历，如果你现在就在末流公司，赶紧想办法跳槽，去不了⼤⼚，去⾮知名的互联⽹公司也算是胜利⼤逃亡了。\n项目经历项⽬经历不管对于社招还是校招都是重中之重，很多时候成败就在于项⽬经历这块，⼀个普通本科可以通过优秀的项⽬经历逆袭985，⼀个⼩⼚的员⼯也可以获得⼤⼚的⾯试机会。 但是必须要说⼀下项⽬经历的编写很讲究，这是为后⾯⾯试部分铺路的绝佳机会，也是直接让你的简历扑街的重点沦陷区域。\n先来看简历中项目经历的坑。\n（1）切忌流⽔账写法项⽬经历流⽔账写法是绝⼤多数简历的通病，通篇下来就讲了⼀件事『我⼲了啥』。\n⼤部分简历却是这样的：\n\n\n\n\n\n\n\n\n\n⽤Vue、Vuex、Vue-router、axios等技术开发电商⽹站的前端部分，主要负责⾸⻚、店铺详情、商品详情、商品列表、订单详情、订单中⼼等相关⻚⾯的开发⼯作，与设计师与后端配合，可要⾼度还原设计稿。\n这个描述有什么问题？ 其实看似也没啥问题，但是这种流⽔账写法太多了，完全⽆法突出⾃⼰的优势展现⾃⼰的能⼒。项⽬经历是考察重点，⾯试官想知道候选⼈在⼀次项⽬经历中扮演的⻆⾊、负责的模块、碰到的问题、解决的思路、达成的效果以及最后的总结与沉淀。\n⽽上⾯的描述只显示了我⼲了啥，所以这种项⽬描述⼏乎是没意义的，因为对于⾯试官⽽⾔他看不到有效信息，没有有效信息的项⽬描述基本就没价值了，如果这个时候你还没有⼤⼚经历或者名校背书，基本上也就凉了。\n（2）切忌堆积项⽬堆积项⽬这种现象往往出现在没有什么优秀项⽬经历的简历身上，候选⼈企图以数量优势掩盖质量的劣势，其实往往适得其反，项⽬经历的⼀栏最好放2-3个项⽬，⾮常优秀的项⽬可能放⼀个就⾜够了，举个极端例⼦如果有⼀天尤⾬溪写简历，其实只需要在项⽬经历那些⼀⾏Vue.js作者就⾏了,当然,他并不需要投简历。\n有⼀些项⽬切忌放上去:\n\ndemo级项⽬：很多简历居然还在放⼀些仿xx官⽹的demo，这是⼗⾜的减分项，有⼀些则是东拼⻄凑抄了⼀些框架 的源码搞了个玩具项⽬，也没有任何价值。\n烂⼤街的项⽬：这种以vue技术栈的为最，由于视频⽹站的某⻔课程流⾏，导致⼤量的仿饿了么、仿qq⾳乐、仿美 团、仿去哪⼉，同样Java的同学也是仿电商⽹站、仿⼤众点评等等，⼗份简历5份⼀模⼀样的项⽬，你是⾯试官会怎么想。\n低质量的开源项⽬：⼀个⼤原则就是低star的尽量别放（除⾮是⾼质量代码的冷⻔项⽬），⻓期弃坑的也不要放，不要为了凑数量把低质量的项⽬暴露出来，好好藏着。\n\n如果只放两个项⽬，最好的搭配是⼀个公司内部挑⼤梁的项⽬和⼀个社区内的开源项⽬，后者之所以可以占据⼀席之地，是因为通过你的开源项⽬，⾯试官可以通过commit完整看到你的创造过程，⽐如⼯程化建设、commit规范、代码规范、协作⽅式、代码能⼒、沟通能⼒等等，这甚⾄⽐⾯试都有⽤，没有⽐开源项⽬更能展示你综合素质的东⻄了。\n（3）切忌放虚假项⽬⼀个项⽬做没做过只要是有经验的⾯试官⼀问便知，如果你真的靠假项⽬忽悠过了⾯试，那这个公司⼋成也有问题，⼈才把关不过硬，你可以想象你的队友都是什么⽔平，在这种公司⼤成⻓价值也不⼤。好，如果你说实在没项⽬可写了，我只能造假了，那么你应该想⼀下这多层追问。\n⽐如你说你优化了⼀个前端项⽬的⾸屏性能，降低了⽩屏时间，那么⾯试官对这个性能优化问题会进⾏深挖，来考察候选⼈的实际⽔平：\n\n你的性能优化指标是怎么确定的？平均下来时间减短了多少？\n你的性能是如何测试的？有两种主流的性能测试⽅法你是怎么选的？\n你是根据哪些指标进⾏针对性优化的？\n除了你说的这些优化⽅法还有没有想过通过xx来解决？\n你的这个优化⽅法在实际操作中碰到过什么问题吗？有没有进⼀步做过测试？\n我们假设这么⼀种情况，⽐如xxxx，你会这么进⾏优化？\n\n⾯试官多层追问的逻辑是这样的：**了解背景 -&gt; 了解⽅案 -&gt; 深挖⽅案 -&gt; 模拟场景 **\n⾸先得了解你性能优化的指标如何，接着需要了解你是这么测试的指标、再怎么进⾏针对性优化的，再接着提出⼀些其它解决⽅案考察你对优化场景的知识储备和⽅案决策能⼒，最后再模拟⼀个其它的业务场景，来考察你的技能迁移能⼒，看看是否是对某块领域有⼀定的了解，⽽不是只针对某个项⽬。\n如果要真的在⾯试现场对答如流，那么⼀定是在某⼀块领域有⼀定知识储备的⼈，不是随随便便搞个项⽬就能蒙混过关的。\n（4）合格的项⽬经历合格的项⽬经历必须要有以下⼏点：\n\n项⽬概述\n个⼈职责\n项⽬难点\n⼯作成果\n\n如果不怕字太多，还可以选择性加⼊解决⽅案、选型思路等，但是由于篇幅限制和为⾯试铺垫就不太建议写得太多。\n项⽬概述的⽬的是让⾯试官理解项⽬，不是每个⼈⾯试官都做过你的那种项⽬，所以需⼀个简述⽅便⾯试官理解。\n个⼈职责就是告诉⾯试官你在本项⽬中扮演的⻆⾊，是领导者？主导者？还是跟随者，你负责了哪些模块，承担了多⼤的⼯作量，以此来评估你在团队中的作⽤。\n项⽬难点的⽬的在于让⾯试官看到你碰到的技术难题，⽅便后续⾯试对项⽬进⾏⼀系列讨论。⼯作成果就很明显了，⾯试官需要看到你在做了上述⼯作到底达成了什么成绩，这个时候最好以数据说话，⽐如访问量、⽩屏时间等等。\n这个时候也切忌⻓篇⼤论，把技术细节都写上去，甚⾄还写了⼼路历程的都是⼤忌，⼀⽅⾯篇幅太⼤会造成视觉混乱，另⼀⽅⾯⾯试官想看到的是简历，不是技术总结，⾯试官要⾯对上百份简历没那么时间来看你⻓篇⼤论，⻓篇⼤论⼤可以在⾯试中展开。\n最好的⽅法就是⼀⾏⽂字简单得说清楚即可，反正项⽬⾯的时候会问到，到时候把准备的内容讲给⾯试官，掌握⾯试的主动权就是从项⽬经历这⼀栏中开始。\n其它（1）教育背景应届⽣可以写得更详细⼀点，⽐如绩点排名怎么样，有没有突出的科⽬，社招就不要写太多了，简单的⼊学时间、学校、专业即可，⽽且写最⾼学历即可，没必要从初中就开始写学历流⽔账，没有⼈看的。\n（2）注意事项\n⾃我评价不建议写：技术⾯试⼏乎没⼈看你的⾃我评价，连⾯试技术问题都嫌『talk is cheap show me the code』，你的⾃我评价除了占篇幅没啥⽤处，充其量算是⾯试官的⼲扰信息。\n简历封⾯千万别搞：这都是⼀些简历制作⽹站骗⽤户付费的伎俩，不仅是互联⽹⾏业，其它⾏业我也没⻅过要简历封⾯这种⽆⽤操作的。\n证书不建议写：应届⽣可以酌情考虑弄个六级证书什么的，对于社招⽽⾔，列⼀堆证书甚⾄是减分项，国内的各种证你也懂的，是有多不⾃信才沦落到靠⼀堆证书来证明⾃⼰的价值。\n千万别⽤技能图表：⾸先⽤90分、80分来评价⾃⼰的技术本身就没有什么说服⼒，也不可能这么精准，⽽且什么是90分、什么是80根本就没有⼀个公论，所以⽤⼀般的⽐较通⽤的熟悉、精通描述即可，千万别加戏，⾯试官或者HR没那么多闲⼯夫去理解你的图表，⽼⽼实实按最通⽤⾼效的⽅式描述⾃⼰的技术栈。\n简历最好⼀⻚：程序员⼜不是设计师有时候需要作品呈现，如果简历超过⼀⻚⼀定是出问题了，项⽬、技术栈描述太多太杂占据了⼤量篇幅。\n\n面试前的准备1. 利用脑图来梳理知识点对于统一校招类的面试，要重点梳理前端的所有知识点，校招面试一般是为了做人才储备，所以看的是候选人的可塑性和学习能力；对于社招类面试，则看重的是业务能力和 JD 匹配程度，所以要针对性地整理前端知识点，针对性的内容包括：项目用到的技术细节、个人技能部分需要加强或提升的常考知识点。\n所以，不仅仅简历要针对性地来写，知识点也要根据自己的经历、准备的简历、公司和职位描述来针对性地梳理。\n基础知识来自于自己平时的储备，一般对着一本系统的书籍或者自己平时的笔记过一遍即可，但是提到自己做到的项目是没有固定的复习套路的，而且围绕项目可以衍生出来各种问题，都需要了解，项目讲清楚对于候选人也特别重要。基础是固定的，任何人经过一段时间都可以学完的，但是项目经历是实打实的经验。\n对于项目的复习和准备，建议列思维导图（脑图），针对自己重点需要讲的项目，列出用到的技术点（知识点），介绍背景、项目上线后的收益以及后续优化点。这是第一层，第二层就是针对技术点（知识点）做各种发散的问题。\n注：JD（job description），是指职位描述，是其缩写。一般在招聘中，最常用到的意思就是岗位介绍和工作职责描述的意思。\n2. 收到面试邀请后的准备当有公司邀请我们去面试的时候，应该针对性地做一些功课。\n（1）了解部门和团队了解部门做的事情，团队用的技术栈，前文提到这部分信息一般从 JD 当中就可以看到，如果 JD 并没有这些信息，那么可以根据面试的部门搜索下，总会找到一些零星的信息，如果实在没有任何信息，就准备岗位需要的通用技术。\n（2）了解面试官通过邀请电话或者面试邀请邮件，可以找到面试官信息。通过这些信息查找面试官技术博客、GitHub 等，了解面试官最近关注的技术和擅长的技术，因为面试官往往会在面试的过程中问自己擅长的技术。\n投递简历投递简历也是有技巧的，首先要根据自身的情况来筛选公司和岗位。要考虑公司规模，技术栈，公司的产品，做什么领域的，公司的地点，薪资，待遇福利等等\n海投作为一个社会人来说🐵，首选的方式肯定是海投了。常见的招聘平台有BOOS直拒，前程堪忧，拉勾，猎聘，脉脉，智联等等，还有各种论坛，微信群，QQ群，公司官网等等。只要自己去慢慢找，海投的渠道还是很多的。\n内推其次就是内推了。对于已经工作几年的老油条来说🐱‍🚀，想必肯定是积累了不少人脉资源，也肯定加了不少HR小姐姐的微信了。直接发个朋友圈或者问一下就可以了。内推相对于海投来说，成功的几率还是很大的。所以，尽量找熟人内推更好，但是前提是要靠谱，同时自己也要达到对应岗位的要求才好。不然到头来，竹篮打水一场空，浪费了时间和精力不说，还弄得大家都尴尬，这就不太好了。\n面试技巧技术⾯试通常⾄少三轮:\n\n基础⾯试: 主要考察对岗位和简历中涉及到基础知识部分的提问,包括⼀部分算法和场景设计的⾯试题,这⼀⾯可能会涉及现场coding。\n项⽬⾯试: 主要考察简历中涉及的项⽬,会涉及你项⽬的相关业务知识、扮演⻆⾊、技术取舍、技术攻坚等。\nHR⾯试: 这⼀⾯通常是HR把关,主要涉及⾏为⾯试,考察候选⼈是否价值观符合公司要求、⼯作稳定性如何、沟通协作能⼒如何等。\n\n当然，对于初级岗或者校招⽣会涉及⼀轮笔试，相当多的公司会在现场⾯之前进⾏⼀轮电话⾯试，⽬的是最快速有效地把不符合要求的候选⼈筛除，对于个别需要跨部⻔协作的岗位会涉及交叉⾯试，⽐如前端候选⼈会被后端的⾯试官⾯试，⼀些有管理需求的岗位或者重要岗位可能会涉及总监⾯试或者vp⾯。\n⽽⼀个正常的技术⾯试流程(以项⽬⾯为例)分为⼤致三个部分:\n\n⾃我介绍\n项⽬(技术)考察\n向⾯试官提问\n\n那么该如何准备技术⾯试,如何在⾯试中掌握主动权呢?\n1. ⾃我介绍⼏乎所有的⾯试都是从⾃我介绍这个环节开始的，所以我们得搞清楚为什么⾃我介绍通常作为⼀个⾯试的开头。\n（1）为什么需要⾃我介绍⾸先，有⼀个很普遍的问题就是⾯试官很可能才刚拿到你的简历，他需要在你⾃我介绍的时候快速浏览你的简历，因为技术⾯试的⾯试官很多是⼀线的员⼯，⾯试候选⼈只是其⼯作中的⼀⼩部分，很多情况下是没有提前看过你的简历的。其次，⾃我介绍其实是⼀个热身，⾯试官和候选⼈其实是陌⽣⼈，⾃我介绍不管是⾯试还是其他情况下，都是两个陌⽣⼈彼此交流的起点，也是缓解候选⼈与⾯试官之间尴尬的⼀种热身⽅式。 最后，⾃我介绍是展示⾃我、引出接下来技术⾯试的引⼦，是你⾃⼰指定技术⾯试⽅向的⼀次机会。\n知道了以上原因，我们才能进⾏准备更好的⾃我介绍。\n（2）⾃我介绍的必备要素⾃我介绍归根到底是⼀个热身运动，因此切忌占⽤⼤量的篇幅，上来就把⾃⼰从出⽣的经历到⼤学像流⽔账⼀样吐出来的，往往会被没耐⼼的⾯试官打断，⽽这也暴露了候选⼈讲话缺乏重点、沟通能⼒⼀般的缺点。\n但是，⼀些关键信息是必须体现的，以下信息是必备的:\n\n个⼈信息: ⾄少要体现出⾃⼰的姓名、岗位和⼯作年限，应届⽣则必须要介绍⾃⼰的教育背景，如果⾃⼰的前东家是个⼤⼚最好提及，⾃⼰的学历是亮点最好提及，其他的什么有没有⼥朋友、是不是独⽣⼦没⼈在意，不要占⽤篇幅。这个部分重点在于你是谁？\n技术能⼒: 简要地介绍⾃⼰的技术栈，切忌把⾃⼰只是简单使⽤过，写过⼏个Demo或者看了看⽂档的所谓「技术栈」也说出来，⼀旦后⾯问到算是⾃找尴尬。这个部分的重点在于你会什么？\n技能擅⻓: 重点介绍⾃⼰擅⻓的技术，⽐如性能优化、⾼并发、系统架构设计或者是沟通协调能⼒等等，切忌夸⼤其词，要实事求是，这是之后考察的重点。这个部分重点⾃在于你擅⻓什么?\n\n（3）重点匹配岗位的技术栈你的⾯试简历可能包含了各种各样的技术栈，但是在⾃我介绍过程中需要匹配当前岗位的技术要求。就⽐如你⽬前⾯试的是移动端H5前端的开发岗位，就重点在⾃我介绍中突出⾃⼰在移动前端的经验，⽽此时⼤篇幅得讲述⾃⼰如何⽤Node⽀撑公司的web项⽬就显得很不明智。\n（4）在⾃我介绍中做刻意引导如果你的⾃我介绍跟流⽔账⼀样,没有任何重点，其实⾯试官也很难办，因为他都没法往下接话…\n⽽只要你稍作引导,绝⼤部分⾯试官就会接你的话茬,⽐如「你在⾃我介绍中重点提及了⼀个项⽬，碰到了⼀些难点，然后被你攻克了，效果如何如何好等等」，如果我是⾯试官⼀定会问「你的xx项⽬的xx难点后来是怎么解决的？」。\n⾯试官的⽬的是考察候选⼈的能⼒，对候选⼈做出评估，因此需要知道候选⼈擅⻓什么，是否匹配岗位，⾯试官绝⼤多数情况下很乐意你这种有意⽆意的引导，这样双⽅的沟通和评估会很顺利，⽽不是故意刁难候选⼈。\n（5）如何准备⾃我介绍其实最好的⽅法也是最笨的⽅法就是把⾃我介绍写下来，这个⾃我介绍⼀定要体现上⾯提到的⼏⼤必备要素，在⾯试前简单过⼏遍，能把⾃我介绍的内容顺利得表达出来即可，切忌跟背课⽂⼀样。\n⾃我介绍的时间最好控制在1-3分钟之间，这些时间⾜够⾯试官把你的简历过⼀遍了，⾯试官看完简历后正好接着你的⾃我介绍进⾏提问是最舒服的节奏，别上来开始10分钟的演讲，⾯试官等待的时候会很尴尬，这么⻓的篇幅说明你的⾃我介绍⼀定是流⽔账式的。\n2. 技术考察⼀个好的技术考察的开始,必须得有⾃我介绍部分好的铺垫和引导,有⼀种情况我们经常遇⻅:\n\n\n\n\n\n\n\n\n\n候选⼈说了⼀⼤堆⾮重点的⾃我介绍,⾯试官⼀时语塞,完全get不到候选⼈的重点,也不知道候选⼈擅⻓什么、有什么亮点项⽬，然后就在他简历的技术栈中选了本公司也在⽤的技术，候选⼈这个时候也开始冒汗，因为这个技术栈并不是他的擅⻓，回答的也磕磕绊绊，⾯试官的引导和深⼊追问也没有达到很好的效果，⾯试就在这种尴尬的⽓氛中展开了，⾯试结束后⾯试官对候选⼈的评价是技术不熟练、没有深⼊理解原理，候选⼈的感受是，⾯试官专挑⾃⼰不会的问。\n所以在前⾯的部分，⼀定要做好引导，把⾯试官的问题引到我们擅⻓的领域，但是这样还不够，正所谓不打⽆准备之仗，我们依然需要针对可能出现的问题进⾏准备.\n那么如何准备可能的⾯试题？\n⽐如你擅⻓前端的性能优化,在⾃我介绍的部分已经做好了引导,接下来⾯试官⼀定会重点考察你性能优化的能⼒,很可能会涉及很有深度的问题,即使你擅⻓这⽅⾯的技术,但是如果没有准备也可能临场乱了阵脚.\n（1）多重提问⾃我多重提问的意思是,当⼀个技术问题抛出的时候，你可能⾯对更深层次的追问。\n依旧以前端性能优化为例，⾯试官可能的提问:\n\n你把这个⼿机端的⽩屏时间减少了150%以上,是从哪些⽅⾯⼊⼿优化的?这个问题即使你没做过前端性能优化也能回答个七七⼋⼋,⽆⾮是组件分割、缓存、tree shaking等等，这是第⼀重⽐较浅的问题。\n我看你⽤webpack中SplitChunksPlugin这个插件进⾏分chunk的,你分chunk的取舍是什么?哪些库分在同⼀个chunk,哪些应该分开你是如何考虑的?如果你提到了SplitChunksPlugin插件可能会有类似的追问,如果没有实际操作过的候选⼈这个时候就难以招架了,这个过程⼀定是需要⼀定的试错和取舍的.\n在分chunk的过程中有没有遇到什么坑?怎么解决的?其实SplitChunksPlugin这个插件有⼀个暗坑,那就是chunid⾃增性导致id不固定唯⼀,很可能⼀个新依赖就导致id全部打乱,使得http缓存失效.\n\n以上只是针对SplitChunksPlugin插件相关的优化提问,当然也可能从你的性能测试⻆度、代码层⾯进⾏考察，但是思路是类似的。因此不能把⾃⼰准备的问题答案停留在⼀个很浅显的层⾯，⼀⽅⾯⽆法展示⾃⼰的技术深度，另⼀⽅⾯在⾯试官的深度体情况下容易丢分，因此在⾃⼰的答案后⾯多进⾏⾃我的追问，看⼀看能不能把问题做的更深⼊。\n（2）答题法则很多⾯试相关的宝典都推荐使⽤STAR法则进⾏问题的应答,我们不想引⼊这个额外的概念,基础技术⾯试的部分⽼⽼实实回答⾯试官的问题即可,通常需要问题运⽤到这个法则的是项⽬⾯,⽐如让你介绍⼀下你最得意的项⽬,回答问题的法则有这⼏个要点:\n\n项⽬背景: 简要说⼀下项⽬的背景,让⾯试官知道这个项⽬是做什么的\n个⼈⻆⾊: 让⾯试官知道你在这个项⽬中扮演的⻆⾊\n难点: 让⾯试官知道你在项⽬开发过程中碰到的难点\n解决⽅案: 针对上⾯的难点你有哪⼀些解决⽅案,是如何结合业务进⾏取舍的\n总结沉淀: 在攻克上述的难点后有没有沉淀出⼀套通⽤的解决⽅案,有没有将⾃⼰的⽅案在⼤部⻔进⾏推⼴等等\n\n重点就在于后⾯三条,也是最体现你个⼈综合素质的⼀部分，我是⾯试官的话会⾮常欣赏那种可以发现问题、找到多种⽅案、能对多种⽅案进⾏⽐对取舍还可以总结沉淀出通⽤解决⽅案回馈团队的⼈。从上述⼏点可以体现出⼀个⼈的技术热情、解决问题的能⼒和总结提⾼的能⼒。\n（3）刻意引导是的，在回答⾯试官提问的时候也可以做到刻意引导。\n举⼏个简单的例⼦：\n\n除了Vue还⽤过Angular吗？ 这个时候很多候选⼈就很实诚回答「没有」，其实我们可以回答的更好，把你知道的说出来展示⾃⼰的能⼒才是最重要的，你可以说「我虽然没⽤过，但是在学习双向绑定原理的时候了解了⼀下 Angular脏检查的原理，在学习Nestjs的时候了解了依赖注⼊的原理，跟Angular也是类似的」，⾯试官⼀定会接着问你脏检查和依赖注⼊的问题，虽然你没有⽤过Angular，但是Angular的基本原理你都懂，这是很好的加分项，说明候选⼈有深⼊理解原理的意愿和触类旁通的能⼒\nVue如何实现双向绑定的？ 很多候选⼈⽼⽼实实答了 object.defineproperty 如何如何操作,然后就没有了,其实你可以在回答完之后加上⼀嘴「Vue 3.0则选择了更好⽤的Proxy来替代object.defineproperty」或者「除了object.defineproperty这种数据劫持的⽅式，观察者模式和脏检查都可以实现双向绑定」，⾯试官⼤概率会问「Proxy好在哪？」或者「聊聊脏检查」等等，这样下⼀个问题就会依然在你的可控范围内\n\n第⼀个例⼦把本来回答不上来的问题，转化为了成功展示⾃⼰能⼒的加分项，第⼆个例⼦让⾃⼰更多的展示了⾃⼰的能⼒，⽽且始终使⾯试官的问题在⾃⼰的可控范围内。\n3. 向⾯试官提问面试是一个双向选择的事情，所以面试后一般会有提问环节。在提问环节，候选人最好不要什么都不问，更不要只问薪水待遇、是否加班之类的问题。\n⾸先声明⼏个雷区:\n\n切忌问结果: 问了也⽩问,绝⼤部分公司规定不会透露结果的,你这样让⼤家很尴尬；\n切忌问⼯资: 除了HR跟你谈⼯资的时候，千万别跟技术⾯试官谈⼯资，⼯资是所有公司的⾼压线，没法谈论；\n切忌问技术问题: 别拿⾃⼰不会的技术难题反问⾯试官，完全没意义，⾯试官答也不是不答也不是；\n\n有⼏个⽐较好的提问可供参考:\n\n团队情况、团队做的业务、本职位具体做的工作、工作的规划；\n你对这个职位理想⼈选的要求是什么?；\n公司培训机会和晋升机会；\n\n尽量围绕你的岗位进⾏提问，这可以使得你更快得熟悉你的⼯作内容,也让⾯试官看到你对此岗位的兴趣和热情,重要的是这些问题对于⾯试官⽽⾔既可以简略回答，也可以详细的给你讲解，如果他很热情得跟你介绍此岗位相关的情况，说明你可能表现得不错，否则的话，你可能不在他的备选名单⾥。\n4. 面试礼仪\n注意社交礼仪：虽然说 IT 行业不怎么注重工作环境，上下级也没有繁文缛节，但是在面试中还是应该注意一些社交礼仪的。像进门敲门、出门关门、站着迎人这类基本礼仪还是要做的。\n舒适但不随意的着装：首先着装方面，不要太随意，也不要太正式，太正式的衣服可能会使人紧张，所以建议穿自己平时喜欢的衣服，关键是干净整洁。\n约个双方都舒服的面试时间：如果 HR 打电话预约面试时间，记得一定要约个双方都舒服的时间，宁愿请假也要安排好面试时间。面试时间很重要，提前十分钟到面试地点，熟悉下环境，做个登记之类的，留下个守时的好印象。如果因为堵车之类的原因不能按时到达，则要在约定时间之前电话通知对方。\n\n5. 其他注意事项在面试过程中，我们经常会被问及各种问题，在回答的过程中，这里简单列举了一些“坑”。\n\n“对不起，我真的很紧张”，即使紧张也不要说出来；\n“我想知道这个职位的具体收入有多少”一开始就谈钱，你的理想、价值观、使命、目标呢？\n“我的缺点是斤斤计较，不能加班，承受不了工作压力太大”不要主动告诉别人你的缺点，你    来是展示你的优势的；\n“我真的很想要这份工作”不要太过于表现你的欲望或绝望，这是你软弱的表现；\n“我现在（之前）的老板太不好了……”向 HR 说你老板的话会变成对方对你的看法；\n“我需要……能实现工作目标”招聘是为了满足公司需求，不是为你搭建舞台；\n“请问面试什么时候结束”不要表现赶时间，你不尊重公司，自然不会录用你；\n“我喜欢贵公司的福利待遇”你是来工作的，不是因为福利待遇才来的；“无可奉告”不违法不涉及隐私，如实告知，有准备的话不会“无可奉告”；\n“工作第一年的福利待遇及带薪年假和病假等情况是什么样的”这是入职时才可以问的规定，先问只会被误会；\n“我在离婚或者怀孕期间经历了非常艰难的时期”不要主动告诉对方隐私情况，你个人的事情处理不好会容易联想到工作表现；\n“我没有什么问题要问”最后被问到时这样回答等同于“再也不见”。\n\n如何和HR博弈HR通常是程序员⾯试的最后⼀⾯，讲道理刷⼈的⼏率不⼤，但是依然有⼈倒在了这最后⼀关上，下面从HR的⻆度出发来分析如何应对HR⾯。\n1. HR⾯的⽬的HR⾯往往是把控⼈才质量的最后⼀关，与前⾯的技术⾯不同，HR⾯往往侧重员⼯⻛险的评估与基本的员⼯素质：\n\n录⽤⻛险评估，这部分是评估候选⼈是否具备稳定性,是否会带来额外的管理⻛险，是否能⻢上胜任⼯作，⽐如频繁的跳槽会带了稳定性的⻛险，HR会慎重考虑这⼀点，⽐如在⾯试中候选⼈体现出了「杠精」潜质，HR会担⼼候选⼈在⼯作中会难以与他⼈协作或者不服从管理，带来管理⻛险，再⽐如，虽然国家明确规定在招聘中不得有性别、年龄等歧视，但是⼀个⼤龄已婚妇⼥会有近期产⼦的可能性，可能会有⻓期的产假，HR也会做出评估。\n员⼯素质评估，这部分评估候选⼈是否具备职场的基本素质，是否有基本的沟通能⼒，是否有团队精神和合作意识等等，⽐如⼀个表现极为内向的候选⼈,HR可能会对其沟通能⼒产⽣怀疑.\n\n所以在与HR交流中要尽量保持踏实稳重、积极乐观的态度，切忌暴露出夸夸其谈、负能量、浮躁等性格缺陷。\n2. HR⾯的常⻅问题（1）对未来3-5年的职业规划**⽬的: **这个问题就是考察候选⼈对未来的规划能⼒,主要想通过候选⼈的规划来嗅出候选⼈对⼯作的态度、稳定性和对技术的追求.**分析: **⼀定要在你的回到中体现对技术的追求、对团队的贡献、对⼯作的态度，不要谈⼀些假⼤空的东⻄，或者薪资、职位这些太过于功利的东⻄,⽽且最好体现出你的稳定性,如果是校招⽣或者⼯作没⼏年的新⼈最好不要涉及创业这种话题,⼀⽅⾯职场新⼈计划没⼏年就创业,这种很不切实际,说明候选⼈没法按实际出发,另⼀⽅⾯说明候选⼈的稳定性不够.\n建议分三部分谈:\n\n⾸先表示考虑过这个问题(有规划),如何谈⼀谈⾃⼰的现状(结合实际).\n接着从⼯作本身出发,谈谈⾃⼰会如何出⾊完成本职⼯作,如何对团队贡献、如何帮助带领团队其他成员创造更多的价值、如何帮助团队扩⼤影响⼒.\n最后从学习出发,谈谈⾃⼰会如何精进领域知识、如何通过提升⾃⼰专业能⼒,如何反哺团队.\n\n⾄于想成为技术leader还是技术专家,就看⾃⼰的喜好了.\n（2）如何看待加班(996)?⽬的: 考察候选⼈的抗压能⼒和责任⼼分析: 这个问题⼏乎是必问的,虽然996ICU事件闹得沸沸扬扬,但是官⽅的态度很暧昧,只⼝头批评从没有实际⾏动,基本上是默许企业违反劳动法的,除了个别外企在国内基本没可能找到不加班的公司,所以在这个⾯试题中尽量体现出⾃⼰愿意牺牲⾃我时间来帮助团队和企业的意愿就⾏了,⽽且要强调⾃⼰的责任⼼,如果真的是碰到⽆意义加班,好好学习怎么⽤vscode刷LeetCode划⽔是正道.**建议: **\n\n把加班分为紧急加班和⻓期加班\n对于紧急加班,表示这是每个公司都会遇到的情况,⾃⼰愿意牺牲时间帮助公司和团队\n对于⻓期加班,如果是⾃⼰⻓期加班那么会磨练⾃⼰的技能,提⾼⾃⼰的效率,如果是团队⻓期加班,⾃⼰会帮助团队找到问题,利⽤⾃动化⼯具或者更⾼效的协作流程来提⾼整个团队的效率,帮助⼤家摆脱加班\n\n当然了,就算你提⾼了团队效率，还是会被安排更多的任务，加班很多时候仅仅是⽬的,，但是你不能说出来啊，尤其是⼀些候选⼈很强硬得表示⻓期加班不接受,其实可以回答的更委婉，除⾮你是真的对这个公司没兴趣，如果以进⼊这个公司为第⼀⽬的,还是做个⾼姿态⽐较好。\n（3）如何⾯对时间有限的⼯作?**⽬的: **考察候选⼈时间管理和处理⼤量任务的能⼒,当然也会涉及⼀定的沟通能⼒**分析: **程序员的⼯作内容可能⼤部分时间并不在写代码上,⽽是要处理各种会议、需求和沟通,通常都属于⼯作超负荷的状态,⾯对上⾯这种问题不建议以加班的⽅式来解决,因为主要考察的是你的时间管理能⼒和沟通能⼒,这些要素要在回答中体现出来**建议: **\n\n将⼤量任务分解为紧急且重要、重要但不紧急、紧急但不重要、不重要且不紧急,依次完成上述任务,在这⾥体现出时间管理的能⼒\n与⾃⼰的领导沟通将不重要的任务放缓执⾏或者砍掉,或者派给组内的新⼈处理,在这⾥体现出沟通能⼒\n\n（4）之前在上海为什么来北京发展?⽬的: 考察候选⼈的稳定性和职业选择**分析: **这个问题⼀般是上份⼯作在异地的情况下⼤概率出现,HR主要担⼼候选⼈异地换⼯作可能会不稳定,有短期内离职⻛险,这个时候不建议说”北京互联⽹公司多,机会多”这种话(合着觉得北京好跳槽?),回答最好要体现出⾃⼰的稳定性,⽐如”⼥朋友在北京,⻓期异地,准备来北京⼀起发展” “家在北京,回北京发展” 等等,潜台词就是以后会在北京发展,不会在多地之间来回摇摆.\n（5）为什么从上⼀家公司离职?**⽬的: **考察离职原因,候选⼈离职⻛险评估**分析: **这个问题经常会在跳槽的时候问到,这个时候切忌吐槽上⼀家公司或者⾃⼰的上⼀任⽼板,尽量从职业发展的⻆度来回答，凸显⾃⼰的稳定性和渴望学习上升的决⼼,⾄于⼀些敏感话题,⽐如加班太多、薪资太低这种问题也是可以谈的，毕竟你跳槽的诉求就是解决上家公司碰到的问题，但是不能触碰刚才提到的底线问题，切忌吐槽向.**建议: **\n\n因为⼯资低、离家远、加班多、技术含量低等等原因离职\n因为离家远花费在路途上的时间过多,不如⽤来充电,因为加班多导致没有时间充电,⽆法提⾼等等\n\n除了不要有负能量和吐槽向,这个部分可以坦诚得说出来\n（6）还有其他公司的Offer吗?**⽬的: **评估候选⼈是否有短时间内⼊职其他公司的可能性**分析: **很多时候并不是候选⼈完美符合⼀个岗位的要求，HR当然想要⼀个技术更好、要钱更少、技术更匹配的候选⼈，但是候选⼈⼀般都会有这样或者那样的⼩问题。\n⽐如，你的表现是可以胜任⽬前的岗位的，但是这个岗位不是很紧急，HR可能把你当做备胎，来找⼀个性价⽐更⾼的候选⼈。⽐如,你的表现很好,履历优秀，HR不知道能不能100%拿下你。所以如果你很希望加⼊这个公司，最好要做到「欲擒故纵」,既要体现⾃身的市场竞争⼒,⼜要给到HR⼀定的压⼒。所以,即使你已经拿了全北京城互联⽹公司的offer了，也不要说⾃⼰offer多如⽜⽑，⼀副满不在乎的样⼦，这样会给HR造成他⼊职可能性不⼤的错觉，因为他的选择太多了。当然,也不要跪在地上舔:”加⼊公司是我的梦想,我只等这⼀个offer”，放⼼吧，⼀定被hr放到备胎⼈才库中.\n**建议: **\n\n表明⾃⼰有三四个已经确认过的offer了(没有offer也要吹,但是不要透露具体公司)\n但是第⼀意向还是本公司,如果薪资差距不⼤,会优先考虑本公司\n再透露出,有⼀两个offer催得⽐较急,希望这边快点出结果\n\n如何和HR谈薪资HR与你谈论薪资经常有如下套路：\n\nHR: 您期望的薪资是多少？\n你: 25K。\n\nOK，你已经被HR成功套路。这个时候你的最⾼价就是25K了，然后HR会顺着这个价往下砍，所以你最终的薪资⼀般都会低于25K。等你接到offer，你的⼼⾥肯定充满了各种“悔恨”：其实当时报价26、27甚⾄28、29也是可以的。\n正确的回答可以这样，并且还能够反套路⼀下HR：\n\nHR: 您期望的薪资是多少？\n你: 就我的⾯试表现，贵公司最⾼可以给多少薪⽔？\n\n如果经验不够⽼道的HR可能就真会说出⼀个报价（如25K）来，然后，你就可以很开⼼地顺着这个价慢慢地往上谈了。所以这种情况下，你最终的薪资肯定是⼤于25K的。当然，经验⽼道的HR会给你⼀句很官⽅的套话：\n\nHR: 您期望的薪资是多少？\n你: 就我的⾯试表现，贵公司最⾼可以给多少薪⽔？\nHR: 这个暂且没法确定，要结合您⼏轮⾯试结果和⽤⼈部⻔的意⻅来综合评定。\n\n虽然薪资很重要，但是我个⼈觉得这不是最重要的。我有以下建议：\n\n如果你觉得你技术⾯试效果很好，可以报⼀个⾼⼀点的薪资，这样如果HR想要你，会找你商量的。\n如果你觉得技术⾯试效果⼀般，但是你⽐较想进这家公司，可以报⼀个折中的薪资。\n如果你觉得⾯试效果很好，但是你不想进这家公司，你可以适当“漫天要价”⼀下。\n如果你觉得⾯试效果不好，但是你想进这家公司，你可以开⼀个稍微低⼀点的⼯资。\n\n需要注意的是，⾯试求职是⼀个双向选择的过程。⾯试应该做到不卑不亢，千万不要因为⾯试结果不好，就低声下⽓地乞求⼯作，每个⼈的⼯作经历和经验都是不⼀样的，技术⾯试不好，知道⾃⼰的短板针对性地补缺补差就⾏，⽽不是在⼈事关系上动歪脑筋。\n谈薪资的技巧跟 HR 沟通的时候，不要夸大现在的薪酬，HR 知道的信息往往会超出你的认知，尤其大公司还会有背景调查，所以不要撒谎，实事求是。跟 HR 沟通的技巧有以下几点：\n（1）不要急于出价不要急于亮出自己的底牌，一旦你说出一个薪酬范围，自己就不能增加薪酬了，还给了对方砍价的空间。而且一个不合理的价格反而会让对方直接放弃。所以不要着急出价，先让对方出价。同时，对于公司级别也是，不要一开始就奔着某个目标去面试，这样会加大面试的难度，比如：目标是拿到阿里 P7 的职位，不要说不给 P7 我就不去面试之类的，这样的要求会让对方一开始就拿 P7 的标准来面试，可能会找 P8+ 的面试官来面试你，这样会大大提升面试难度。\n（2）要有底气足够自信要有底气，自信，自己按照上面的估值盘算好了想要的薪酬，那么应该有底气地说出来，并且给出具体的原因，比如：\n\n我已经对贵公司的薪酬范围和级别有了大概的了解，我现在的水平大概范围是多少\n现在公司很快就有调薪机会，自己已经很久没有调薪，年前跳槽会损失年终奖等情况\n现在我已经有某个公司多少 K 的 offer\n\n如果 HR 表示你想要的薪酬不能满足，这时候你应该给出自己评估的依据，是根据行业职级标准还是自己现有薪酬范围，这样做到有理有据。\n（3）谈好 offer 就要尽快落实对于已经谈拢的薪酬待遇，一定要 HR 以发邮件 offer 的形式来确认。\noffer的选择如果自己手上已经有了几个满意的offer，这时候就要做出一些取舍了。每个人根据自己的情况，具体问题具体分析，去选择最适合自己的那一个offer。总体来说，offer的选择尽量要从长远的目标来衡量。是否有利于自己的职业生涯发展。那到这份offer，除了钱以外我还能收获哪些，这些是很重要的。\n","slug":"面试/2022年金三银四面试葵花宝典","date":"2022-09-21T16:51:08.000Z","categories_index":"面试","tags_index":"面试，金三银四，金九银十","author_index":"前端少年汪"},{"id":"96d83872ad7618027388d39263338070","title":"我在国企的那些日子","content":"todo","slug":"年终总结/我在国企的那些日子","date":"2022-09-01T15:11:46.000Z","categories_index":"工作感悟","tags_index":"工作感悟 国企","author_index":"前端少年汪"},{"id":"b7365f5ec90869bc85bd7fc53178f85a","title":"如何使用Vite+React18创建Cesium项目？教你两种方式","content":"前言\n\n\n\n\n\n\n\n\n书接上文，上篇文章介绍了《使用Vite+Vue3创建Cesium项目》，感觉还是对很多小伙伴有帮助的，那么这篇文章就介绍一下使用Vite+React18创建Cesium项目。\n先填一下上一篇文章埋下的坑控制台会报错这个问题：\nVM19:1 Blocked script execution in &#39;about:blank&#39; because the document&#39;s frame is sandboxed and the &#39;allow-scripts&#39; permission is not set.\n解决方法：设置infoBox：false\nconst viewer &#x3D; new Cesium.Viewer(&#39;cesiumContainer&#39;, &#123;\n    infoBox: false\n&#125;)\n\n使用viet创建react18项目pnpm create vite vite+react18+cesium --template react-ts\n进入项目 cd vite+react18+cesium\n安装依赖 pnpm install\n运行项目 pnpm run dev\n\n这个就是vite+react18的初始化项目了。下面介绍基于react框架创建cesium项目的两种方式：   \n\n使用cesium的vite插件 vite-plugin-cesium\n把cesium依赖包放到public文件夹下直接引入\n\n第一种方法安装vite-plugin-cesium插件npm i cesium vite-plugin-cesium vite -D\n\nyarn add cesium vite-plugin-cesium vite -D\n\n在vite.config.js文件中配置使用插件import &#123; defineConfig &#125; from &#39;vite&#39;\nimport react from &#39;@vitejs&#x2F;plugin-react&#39;\nimport cesium from &#39;vite-plugin-cesium&#39;;\n\n&#x2F;&#x2F; https:&#x2F;&#x2F;vitejs.dev&#x2F;config&#x2F;\nexport default defineConfig(&#123;\n  plugins: [react(),cesium()],\n&#125;)\n\n在App组件中初始化Cesium首先清除默认样式，把index.css和App.js里面的默认样式都删除掉\n然后在App.jsx组件中\nimport * as Cesium from &#39;cesium&#39;\nimport &#39;.&#x2F;App.css&#39;\nimport &#123;useEffect&#125; from &quot;react&quot;;\n\nfunction App() &#123;\n    \n    useEffect(() &#x3D;&gt; &#123;\n        &#x2F;&#x2F; 初始化Cesium\n        const viewer &#x3D; new Cesium.Viewer(&#39;cesiumContainer&#39;, &#123;\n            &#x2F;*在给cesium使用html2canvas插件加截图保存控件时，提示错误Blocked script execution in &#39;about:blank&#39; because the document&#39;s frame is sandboxed and the &#39;allow-scripts&#39; permission is not set.*&#x2F;\n            infoBox: false\n        &#125;)\n    &#125;, [])\n\n    return (\n        &lt;div id&#x3D;&quot;cesiumContainer&quot;&#x2F;&gt;\n    );\n&#125;\n\nexport default App\n\n记得设置一下cesiumContainer容器的宽高App.css\n#cesiumContainer&#123;\n    width: 100vw;\n    height: 100vh;\n&#125;\n\n然后在运行项目打开浏览器就可以看到🌍地球了\n\n第二种方法第二种方法就是本地引入，把下载好的cesium依赖包（node_modules里面）复制放到public里面， 然后在index.html里面引入cesium和css文件\n&lt;!doctype html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;link rel&#x3D;&quot;icon&quot; type&#x3D;&quot;image&#x2F;svg+xml&quot; href&#x3D;&quot;&#x2F;vite.svg&quot; &#x2F;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;public&#x2F;cesium&#x2F;Build&#x2F;Cesium&#x2F;Cesium.js&quot;&gt;&lt;&#x2F;script&gt;\n\n    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;public&#x2F;cesium&#x2F;Build&#x2F;CesiumUnminified&#x2F;Widgets&#x2F;widgets.css&quot;&gt;\n\n    &lt;title&gt;Vite + React&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;script type&#x3D;&quot;module&quot; src&#x3D;&quot;&#x2F;src&#x2F;main.jsx&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n重要的是这两行\n&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;.&#x2F;public&#x2F;cesium&#x2F;Build&#x2F;Cesium&#x2F;Cesium.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;.&#x2F;public&#x2F;cesium&#x2F;Build&#x2F;CesiumUnminified&#x2F;Widgets&#x2F;widgets.css&quot;&gt;\n\n然后同样的，去页面初始化cesium就可以了。\nCesium初始化的配置项说明这是用于配置Cesium三维地球应用程序的选项。以下是各个参数的解释：\n\nanimation：是否显示动画控制器。\nbaseLayerPicker：是否允许用户选择基础图层。\nfullscreenButton：是否显示全屏按钮。\nvrButton：是否显示VR按钮。\ngeocoder：是否显示地理编码器，或应该包含哪些Geocoder服务对象。\nhomeButton：是否显示主页按钮。\ninfoBox：是否显示信息框。\nsceneModePicker：是否显示场景模式选择器。\nselectionIndicator：是否显示选择指示器。\ntimeline：是否显示时间轴。\nnavigationHelpButton：是否显示导航帮助按钮。\nnavigationInstructionsInitiallyVisible：在初始加载时，是否自动显示导航说明。\nscene3DOnly：是否禁用2D地图模式。\nshouldAnimate：是否自动运行动画。\nclockViewModel：ClockViewModel对象，用于控制时间和动画。\nselectedImageryProviderViewModel：当前选择的图像提供者。\nimageryProviderViewModels：可用图像提供者。\nselectedTerrainProviderViewModel：当前选择的地形提供者。\nterrainProviderViewModels：可用地形提供者。\nbaseLayer：ImageryLayer对象，用于设置基础图层。\nterrainProvider：TerrainProvider对象，用于设置地形提供者。\nterrain：Terrain对象，用于控制地形的外观和行为。\nskyBox：SkyBox对象，用于控制天空盒的外观和行为。\nskyAtmosphere：SkyAtmosphere对象，用于控制大气影响的外观和行为。\nfullscreenElement：全屏元素。\nuseDefaultRenderLoop：是否使用Cesium的默认渲染循环。\ntargetFrameRate：目标帧速率，以帧/秒为单位。\nshowRenderLoopErrors：是否在控制台输出渲染循环错误消息。\nuseBrowserRecommendedResolution：是否使用浏览器建议的分辨率。\nautomaticallyTrackDataSourceClocks：是否自动跟踪数据源时钟。\ncontextOptions：WebGL上下文选项。\nsceneMode：场景模式（2D、3D或双眼立体）。\nmapProjection：地图投影类型。\nglobe：Globe对象，用于控制球形地球的外观和行为。\norderIndependentTranslucency：是否启用无序透明度。\ncreditContainer：显示版权信息的元素。\ncreditViewport：版权信息元素的视口。\ndataSources：DataSourceCollection对象，表示要可视化的数据源集合。\nshadows：是否启用阴影。\nterrainShadows：地形阴影类型。\nmapMode2D：2D地图模式下地图行为。\nprojectionPicker：是否显示投影选择器。\nblurActiveElementOnCanvasFocus：获取焦点时是否模糊当前活动元素。\nrequestRenderMode：渲染模式（RENDER_ONCE、ANIMATE、SCENE2D、SCENE3D和MORPH）。\nmaximumRenderTimeChange：每帧允许的最大渲染时间（毫秒）。\ndepthPlaneEllipsoidOffset：深度平面和椭球体之间的偏移量。\nmsaaSamples：抗锯齿采样级别。\n\n希望可以帮助各位小伙伴在开发web 3D项目的时候有一点帮助\n","slug":"react/如何使用Vite+React18创建Cesium项目？教你两种方式","date":"2022-07-30T02:46:35.000Z","categories_index":"react","tags_index":"cesium","author_index":"前端少年汪"},{"id":"2fb96575f2877512c0acb0b5dc6b763c","title":"如何使用node操作sqlite","content":"什么是sqlitSQLite是一种轻量级的嵌入式关系型数据库管理系统，它以库的形式存在，可以嵌入到应用程序中。它使用简单的、基于文件的数据库格式，不需要独立的服务器进程，非常适合在资源有限的环境中使用。\nSQLite的优点\n简单易用：SQLite的API简单明了，学习曲线低，使用方便。\n零配置：无需复杂的配置和管理，只需一个数据库文件即可开始使用。\n占用资源少：SQLite数据库文件通常很小，内存占用也较少，适用于嵌入式设备或低性能环境。\n支持事务：具备ACID特性，支持事务操作，保证数据的完整性和并发控制。\n跨平台：SQLite可以在多个操作系统上运行，包括Windows、macOS、Linux等。\n\nSQLite的缺点包括\n并发性限制：由于它是单用户模式，不支持多个写操作同时进行，因此在高并发读写场景下性能可能受限。\n存储容量有限：由于文件格式的限制，SQLite数据库文件的大小通常有上限。\n功能相对较少：相比于传统的大型数据库管理系统，SQLite提供的功能较为有限，不适合处理大规模复杂数据。\n\nSQLite适用于以下应用场景\n移动应用：由于SQLite的轻量级特性，它常被用于移动应用开发中，用来存储和管理少量结构化数据。\n嵌入式系统：SQLite的小巧和低资源占用使它成为嵌入式设备上的理想选择，如物联网设备、嵌入式系统等。\n测试和原型开发：在快速开发和测试阶段，SQLite可以作为临时的数据库解决方案，提供方便的开发和测试环境。\n小型网站：对于小型网站或个人项目，SQLite提供了一个简单可靠的数据库解决方案，不需要复杂的数据库服务器。\n\n总之，SQLite在轻量级应用和资源受限环境下具有优势，适合那些对性能要求不高、数据量较小或者需要方便集成的场景。\n如何操作sqlite使用Node.js操作SQLite数据库有多种方式，其中常用的方式包括使用sqlite3模块、sequelize模块和knex模块。每种方式都有其特点和适用场景。\n1. sqlite3：\n纯粹的SQLite数据库驱动模块，提供了底层的数据库访问接口。\n可以直接使用SQL语句进行数据库操作。\n适合对数据库操作有更细粒度控制需求的开发者。\n\n2. sequelize：\n是一个功能强大的ORM(Object-Relational Mapping)库，支持多种数据库包括SQLite。\n提供了面向对象的方式定义模型，便于操作数据库。\n自动构建SQL查询语句，简化数据库操作。\n支持事务管理、关联查询等高级功能。\n适合需要使用ORM进行数据库操作或有复杂业务需求的开发者。\n\n3. knex：\n是一个SQL查询构建器，支持多种数据库包括SQLite。\n使用链式调用方法构建SQL查询语句。\n支持灵活的查询条件、聚合查询、分页等功能。\n可以直接执行SQL语句。\n适合对数据库操作有更高灵活性要求的开发者。\n\n哪种方式最好用取决于实际需求。如果需要更底层的数据库访问接口或对数据库操作有更细粒度的控制，可以选择sqlite3模块。如果需要使用ORM进行数据库操作或有复杂业务需求，可以选择sequelize模块。如果需要更灵活地构建SQL查询语句或有特定的查询需求，可以选择knex模块。\n一般是根据项目需求选择适合的方式使用Node.js操作SQLite数据库。\nknex详细介绍官网介绍：\n\n\n\n\n\n\n\n\n\nKneX可以在Node.js和浏览器中用作SQL查询构建器，但受WebSQL的限制(如不能删除表或读取模式)。强烈反对在浏览器中编写在服务器上执行的SQL查询，因为这可能会导致严重的安全漏洞。在WebSQL之外构建的浏览器主要用于学习目的-例如，您可以打开控制台并使用kneX对象在此页面上构建查询。\n\n\n\n\n\n\n\n\n\nKneX的主要目标环境是Node.js，您将需要安装KneX库，然后安装相应的数据库库：PG for PostgreSQL、CockroachDB和Amazon RedShift、PG-Native for PostgreSQL和Native C++libpq绑定(需要安装PostgresSQL才能链接到它)、MySQL for MySQL或MariaDB、SQLite3 for SQLite3或Destous for MSSQL。\n使用knex对sqlite的增删改查使用knex之前先得安装knex和数据库驱动，我这里用的是sqlite数据库，所以需要安装sqlite3\n$ npm install knex --save\n\n# Then add one of the following (adding a --save) flag:\n$ npm install pg\n$ npm install pg-native\n$ npm install sqlite3\n$ npm install better-sqlite3\n$ npm install mysql\n$ npm install mysql2\n$ npm install oracledb\n$ npm install tedious\n\n根据自己的需要选择合适的数据库驱动即可\n初始化knex实例\nconst knex &#x3D; require(&#39;knex&#39;)(&#123;\n  client: &#39;sqlite3&#39;,\n  connection: &#123;\n    filename: &#39;.&#x2F;database.sqlite&#39;\n  &#125;\n&#125;);\n在实例化knex时，可以传入一些配置参数来进行数据库连接和其他相关配置。常用的配置参数如下：\n\n\n\n\n\n\n\n\n\n\nclient：指定数据库类型，比如sqlite3、mysql、postgresql等。\nconnection：指定数据库连接信息，可以是一个URL字符串或一个包含连接信息的对象，如host、port、user、password、database等。\npool：连接池的配置，控制数据库连接的复用和管理，常用的配置项有min、max、idleTimeoutMillis等。\nmigrations：迁移文件相关的配置，用于数据库迁移管理，包括directory（迁移文件目录）、tableName（存储迁移记录的表名）等。\nseeds：种子数据相关的配置，用于初始化数据库，包括directory（种子数据文件目录）等。\ndebug：是否开启调试模式，输出SQL查询语句和参数。\n\n以下是一个示例代码，演示了实例化knex时的配置参数：\nconst knex &#x3D; require(&#39;knex&#39;)(&#123;\n  client: &#39;sqlite3&#39;,\n  connection: &#123;\n    filename: &#39;.&#x2F;data&#x2F;db.sqlite3&#39;\n  &#125;,\n  pool: &#123;\n    min: 2,\n    max: 10\n  &#125;,\n  migrations: &#123;\n    directory: &#39;.&#x2F;migrations&#39;,\n    tableName: &#39;knex_migrations&#39;\n  &#125;,\n  seeds: &#123;\n    directory: &#39;.&#x2F;seeds&#39;\n  &#125;,\n  debug: true\n&#125;);\n\nmodule.exports &#x3D; knex;\n\n上述示例代码中，使用SQLite3作为数据库类型，指定了数据库文件路径。同时配置了连接池的最小连接数和最大连接数。定义了迁移文件和种子数据文件的目录，以及迁移记录表的表名。开启了调试模式，输出SQL查询语句和参数。\n根据实际需求，可以根据以上配置参数进行灵活的配置。具体的配置项及其含义可以参考knex的官方文档。\n创建数据库表在使用knex创建表之前，可以通过knex.schema.hasTable()方法检查表是否已经存在。以下是一个使用knex创建表前判断表是否存在的示例代码：\nknex.schema.hasTable(&#39;users&#39;).then((exists) &#x3D;&gt; &#123;\n  if (!exists) &#123;\n    return knex.schema.createTable(&#39;users&#39;, (table) &#x3D;&gt; &#123;\n      table.increments(&#39;id&#39;).primary();\n      table.string(&#39;name&#39;);\n      table.string(&#39;email&#39;);\n    &#125;);\n  &#125;\n&#125;).then(() &#x3D;&gt; &#123;\n  console.log(&#39;Table created successfully&#39;);\n&#125;).catch((err) &#x3D;&gt; &#123;\n  console.error(err);\n&#125;);\n\n在上述代码中，首先使用knex.schema.hasTable()方法检查名为”users”的表是否存在。如果不存在，则执行创建表的操作；如果存在，则直接跳过创建表的步骤。这样可以确保在创建表之前先判断表是否已存在。\n通过这种方式，可以避免重复创建表或导致错误。需要注意的是，在实际开发中，根据业务需求可能需要对表结构进行更精确的判断，比如检查是否存在特定的列等，可以根据具体情况进行扩展。\n增删改查当使用knex操作SQLite数据库时，可以按照以下方式进行增删改查操作：\n\n插入数据：\n\nknex(&#39;users&#39;).insert(&#123;\n  name: &#39;John Doe&#39;,\n  email: &#39;john.doe@example.com&#39;\n&#125;).then(() &#x3D;&gt; &#123;\n  console.log(&#39;Data inserted successfully&#39;);\n&#125;).catch((err) &#x3D;&gt; &#123;\n  console.error(err);\n&#125;);\n\n\n查询数据：\n\nknex.select().from(&#39;users&#39;).then((rows) &#x3D;&gt; &#123;\n  rows.forEach((row) &#x3D;&gt; &#123;\n    console.log(row.name, row.email);\n  &#125;);\n&#125;).catch((err) &#x3D;&gt; &#123;\n  console.error(err);\n&#125;);\n\n\n更新数据：\n\nknex(&#39;users&#39;)\n  .where(&#39;id&#39;, 1)\n  .update(&#123; name: &#39;前端少年汪&#39; &#125;)\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;Data updated successfully&#39;);\n  &#125;).catch((err) &#x3D;&gt; &#123;\n    console.error(err);\n  &#125;);\n\n\n删除数据：\n\nknex(&#39;users&#39;)\n  .where(&#39;id&#39;, 1)\n  .del()\n  .then(() &#x3D;&gt; &#123;\n    console.log(&#39;Data deleted successfully&#39;);\n  &#125;).catch((err) &#x3D;&gt; &#123;\n    console.error(err);\n  &#125;);\n\n以上代码演示了使用knex操作SQLite数据库的基本增删改查操作。根据实际需求，可以使用knex提供的更多方法和功能来完成更复杂的数据库操作。\n","slug":"node/如何使用node操作sqlite","date":"2022-07-19T02:46:35.000Z","categories_index":"node","tags_index":"node slq","author_index":"前端少年汪"},{"id":"632f278e9eaf0bde9468f346788aa8ea","title":"如何使用Java进行网络爬虫","content":"如何使用Java进行网络爬虫\n\n\n\n\n\n\n\n\n大家好我是迁客，一个初学Java的小白！痴迷技术，对programming有着极大的兴趣和爱好。从今天起，开始写自己个人成长的第一篇博客！既是对自己的一个学习技术的一个记录，也是督促自己，坚持下去！加油Fighting！==从明天起，做一个新思维的人继承，多态，层层封装从明天起,不再关心内存管理让每一条数据，自动放到合适的位子上从明天起，我将为每一个对象取一个温暖的名字它们用驼峰命名，优雅，大方陌生人，我也祝福你哈愿你不再为系统级bug烦恼愿你在平台之间肆意游荡愿你不再关心溢出与异常==\n@[toc]好了废话不多说，我们先来看看用Java爬虫需要先准备什么？\n\nJKD13\nidea开发工具\nmaven\nhttpclient\n\n以上就是我主要用到的东西了！\n1.环境准备\n创建Maven工程并给pom.xml加入依赖&lt;dependencies&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.httpcomponents&#x2F;httpclient --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.httpcomponents&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;httpclient&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.5.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.slf4j&#x2F;slf4j-log4j12 --&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.slf4j&#x2F;slf4j-log4j12 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.7.25&lt;&#x2F;version&gt;\n            &lt;!--&lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.jsoup&#x2F;jsoup --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.10.2&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;junit&#x2F;junit --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.12&lt;&#x2F;version&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;commons-io&#x2F;commons-io --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.6&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.commons&#x2F;commons-lang3 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;3.7&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n2.加入log4j.properties\n\nlog4j.rootLogger&#x3D;DEBUG,A1\nlog4j.logger.spider &#x3D; DEBUG\n\nlog4j.appender.A1&#x3D;org.apache.log4j.ConsoleAppender\nlog4j.appender.A1.layout&#x3D;org.apache.log4j.PatternLayout\nlog4j.appender.A1.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; [%t] [%c]-[%p] %m%n\n3.编写最简单的爬虫，抓取CSDN首页：https://blog.csdn.net/&#x2F;***\n     * @Title: getHttp()\n     * @Author: 汪满青\n     * @Description: get请求,抓取CSDN首页\n     * @Date: 2020&#x2F;10&#x2F;25-21:55\n     * @Param: []\n     * @return: void\n     **&#x2F;\n    public static void getHttp() throws IOException &#123;\n        &#x2F;&#x2F;创建HttpClient对象\n        CloseableHttpClient httpClient &#x3D; HttpClients.createDefault();\n        &#x2F;&#x2F;创建HttpGet请求\n        HttpGet httpGet &#x3D; new HttpGet(&quot;http:&#x2F;&#x2F;www.itcast.cn&#x2F;&quot;);\n        CloseableHttpResponse response &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;使用HttpClient发起请求\n            response &#x3D; httpClient.execute(httpGet);\n            &#x2F;&#x2F;判断响应状态码是否为200\n            if (response.getStatusLine().getStatusCode() &#x3D;&#x3D; 200) &#123;\n                &#x2F;&#x2F;如果为200表示请求成功，获取返回数据\n                String content &#x3D; EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);\n                &#x2F;&#x2F;打印数据长度\n                System.out.println(content);\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F;释放连接\n            if (response &#x3D;&#x3D; null) &#123;\n                try &#123;\n                    response.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                httpClient.close();\n            &#125;\n        &#125;\n    &#125;\n\n4.连接池\n如果每次请求都要创建HttpClient，会有频繁创建和销毁的问题，可以使用连接池来解决这个问题。测试以下代码，并断点查看每次获取的HttpClient都是不一样的。\n\npackage com.test;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\nimport org.apache.http.util.EntityUtils;\nimport java.io.IOException;\n&#x2F;**\n * @ClassName:httpPool\n * @Description:httpPool连接池\n * @Author: 汪满青\n * @Date: 2020-10-25 22:28\n *&#x2F;\npublic class httpPool &#123;\n    public static void main(String[] args) throws IOException &#123;\n        PoolingHttpClientConnectionManager cm &#x3D; new PoolingHttpClientConnectionManager();\n        &#x2F;&#x2F;    设置最大连接数\n        cm.setMaxTotal(200);\n        &#x2F;&#x2F;    设置每个主机的并发数\n        cm.setDefaultMaxPerRoute(20);\n        doGet(cm);\n    &#125;\n    private static void doGet(PoolingHttpClientConnectionManager cm) throws IOException &#123;\n        CloseableHttpClient httpClient &#x3D; HttpClients.custom().setConnectionManager(cm).build();\n        HttpGet httpGet &#x3D; new HttpGet(&quot;https:&#x2F;&#x2F;blog.csdn.net&#x2F;&quot;);\n        CloseableHttpResponse response &#x3D; null;\n        try &#123;\n            response &#x3D; httpClient.execute(httpGet);\n            &#x2F;&#x2F; 判断状态码是否是200\n            if (response.getStatusLine().getStatusCode() &#x3D;&#x3D; 200) &#123;\n                &#x2F;&#x2F; 解析数据\n                String content &#x3D; EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;);\n                System.out.println(content.length());\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F;释放连接\n            if (response &#x3D;&#x3D; null) &#123;\n                try &#123;\n                    response.close();\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n                &#x2F;&#x2F;不能关闭HttpClient\n                &#x2F;&#x2F;httpClient.close();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n5.jsoup介绍jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\njsoup的主要功能如下：1.从一个URL，文件或字符串中解析HTML；2.使用DOM或CSS选择器来查找、取出数据；3.可操作HTML元素、属性、文本；\n&lt;!--Jsoup--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.jsoup&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;jsoup&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.10.3&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--测试--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;4.12&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!--工具--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.7&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;2.6&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n5.1.soup解析Jsoup可以直接输入url，它会发起请求并获取数据，封装为Document对象\n@Test\npublic void testJsoupUrl() throws Exception &#123;\n    &#x2F;&#x2F;    解析url地址\n    Document document &#x3D; Jsoup.parse(new URL(&quot;http:&#x2F;&#x2F;www.itcast.cn&#x2F;&quot;), 1000);\n\n    &#x2F;&#x2F;获取title的内容\n    Element title &#x3D; document.getElementsByTag(&quot;title&quot;).first();\n    System.out.println(title.text());\n&#125;\nPS：虽然使用Jsoup可以替代HttpClient直接发起请求解析数据，但是往往不会这样用，因为实际的开发过程中，需要使用到多线程，连接池，代理等等方式，而jsoup对这些的支持并不是很好，所以我们一般把jsoup仅仅作为Html解析工具使用\n\n\n\n\n\n\n\n\n\n==写到最后了，希望大家对大家有所帮助，谢谢感悟：开始写博客，希望自己可以坚持下去， 至少每周一篇，积少成多，并且保证质量，希望大家多多支持，同时也是自己的一个积累的过程==\n","slug":"go/如何使用Java进行网络爬虫","date":"2021-07-18T02:46:35.000Z","categories_index":"java","tags_index":"java 爬虫","author_index":"前端少年汪"}]